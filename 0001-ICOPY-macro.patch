From d73da941387c9faf0e784a121924edb7097733f9 Mon Sep 17 00:00:00 2001
From: arthurkkhi <arthur.kao@intel.com>
Date: Wed, 6 Mar 2019 18:25:05 -0800
Subject: [PATCH] ICOPY macro

default to off
---
 0001-ICOPY-macro.patch                        | 5205 +++++++++++++++++
 .../Codec/EbAdaptiveMotionVectorPrediction.c  |  165 +-
 .../Codec/EbAdaptiveMotionVectorPrediction.h  |   14 +
 Source/Lib/Codec/EbCdefProcess.c              |    2 +-
 Source/Lib/Codec/EbCodingLoop.c               |   97 +-
 Source/Lib/Codec/EbCodingUnit.h               |   82 +
 Source/Lib/Codec/EbDefinitions.h              |   31 +
 Source/Lib/Codec/EbEncDecProcess.c            |    3 +
 Source/Lib/Codec/EbEncHandle.c                |   12 +
 Source/Lib/Codec/EbEntropyCoding.c            |  146 +-
 Source/Lib/Codec/EbFullLoop.c                 |    4 +
 Source/Lib/Codec/EbInterPrediction.c          |  109 +
 Source/Lib/Codec/EbInterPrediction.h          |    3 +
 Source/Lib/Codec/EbIntraPrediction.c          |  107 +-
 Source/Lib/Codec/EbMdRateEstimation.c         |   11 +
 Source/Lib/Codec/EbMdRateEstimation.h         |   14 +
 Source/Lib/Codec/EbModeDecision.c             |  410 ++
 Source/Lib/Codec/EbModeDecision.h             |   10 +-
 .../EbModeDecisionConfigurationProcess.c      |  151 +
 Source/Lib/Codec/EbModeDecisionProcess.h      |    5 +
 Source/Lib/Codec/EbPictureAnalysisProcess.c   |   51 +
 Source/Lib/Codec/EbPictureControlSet.c        |    7 +
 Source/Lib/Codec/EbPictureControlSet.h        |   48 +-
 Source/Lib/Codec/EbPictureDecisionProcess.c   |   24 +
 Source/Lib/Codec/EbPictureManagerProcess.c    |    4 +
 Source/Lib/Codec/EbRateDistortionCost.c       |   60 +
 .../Lib/Codec/EbResourceCoordinationProcess.c |    2 +
 Source/Lib/Codec/EbRestProcess.c              |    8 +
 Source/Lib/Codec/EbSequenceControlSet.c       |    4 +
 Source/Lib/Codec/av1me.c                      | 1106 ++++
 Source/Lib/Codec/av1me.h                      |   87 +
 Source/Lib/Codec/hash.c                       |  125 +
 Source/Lib/Codec/hash.h                       |   53 +
 Source/Lib/Codec/hash_motion.c                |  491 ++
 Source/Lib/Codec/hash_motion.h                |   84 +
 Source/Lib/Codec/vector.c                     |  543 ++
 Source/Lib/Codec/vector.h                     |  159 +
 37 files changed, 9418 insertions(+), 19 deletions(-)
 create mode 100644 0001-ICOPY-macro.patch
 create mode 100644 Source/Lib/Codec/av1me.c
 create mode 100644 Source/Lib/Codec/av1me.h
 create mode 100644 Source/Lib/Codec/hash.c
 create mode 100644 Source/Lib/Codec/hash.h
 create mode 100644 Source/Lib/Codec/hash_motion.c
 create mode 100644 Source/Lib/Codec/hash_motion.h
 create mode 100644 Source/Lib/Codec/vector.c
 create mode 100644 Source/Lib/Codec/vector.h

diff --git a/0001-ICOPY-macro.patch b/0001-ICOPY-macro.patch
new file mode 100644
index 0000000..0221afb
--- /dev/null
+++ b/0001-ICOPY-macro.patch
@@ -0,0 +1,5205 @@
+From bacd3531fbff33657687c433272cdf00d014bfab Mon Sep 17 00:00:00 2001
+From: arthurkkhi <arthur.kao@intel.com>
+Date: Wed, 6 Mar 2019 18:18:10 -0800
+Subject: [PATCH] ICOPY macro
+
+default to off
+---
+ .../Codec/EbAdaptiveMotionVectorPrediction.c  |  165 ++-
+ .../Codec/EbAdaptiveMotionVectorPrediction.h  |   14 +
+ Source/Lib/Codec/EbCdefProcess.c              |    2 +-
+ Source/Lib/Codec/EbCodingLoop.c               |   97 +-
+ Source/Lib/Codec/EbCodingUnit.h               |   82 ++
+ Source/Lib/Codec/EbEncDecProcess.c            |    3 +
+ Source/Lib/Codec/EbEncHandle.c                |   12 +
+ Source/Lib/Codec/EbEntropyCoding.c            |  146 ++-
+ Source/Lib/Codec/EbFullLoop.c                 |    4 +
+ Source/Lib/Codec/EbInterPrediction.c          |  109 ++
+ Source/Lib/Codec/EbInterPrediction.h          |    3 +
+ Source/Lib/Codec/EbIntraPrediction.c          |  107 +-
+ Source/Lib/Codec/EbMdRateEstimation.c         |   11 +
+ Source/Lib/Codec/EbMdRateEstimation.h         |   14 +
+ Source/Lib/Codec/EbModeDecision.c             |  410 ++++++
+ Source/Lib/Codec/EbModeDecision.h             |   10 +-
+ .../EbModeDecisionConfigurationProcess.c      |  151 +++
+ Source/Lib/Codec/EbModeDecisionProcess.h      |    5 +
+ Source/Lib/Codec/EbPictureAnalysisProcess.c   |   51 +
+ Source/Lib/Codec/EbPictureControlSet.c        |    7 +
+ Source/Lib/Codec/EbPictureControlSet.h        |   48 +-
+ Source/Lib/Codec/EbPictureDecisionProcess.c   |   24 +
+ Source/Lib/Codec/EbPictureManagerProcess.c    |    4 +
+ Source/Lib/Codec/EbRateDistortionCost.c       |   60 +
+ .../Lib/Codec/EbResourceCoordinationProcess.c |    2 +
+ Source/Lib/Codec/EbRestProcess.c              |    8 +
+ Source/Lib/Codec/EbSequenceControlSet.c       |    4 +
+ Source/Lib/Codec/av1me.c                      | 1106 +++++++++++++++++
+ Source/Lib/Codec/av1me.h                      |   87 ++
+ Source/Lib/Codec/hash.c                       |  125 ++
+ Source/Lib/Codec/hash.h                       |   53 +
+ Source/Lib/Codec/hash_motion.c                |  491 ++++++++
+ Source/Lib/Codec/hash_motion.h                |   84 ++
+ Source/Lib/Codec/vector.c                     |  543 ++++++++
+ Source/Lib/Codec/vector.h                     |  159 +++
+ 35 files changed, 4182 insertions(+), 19 deletions(-)
+ create mode 100644 Source/Lib/Codec/av1me.c
+ create mode 100644 Source/Lib/Codec/av1me.h
+ create mode 100644 Source/Lib/Codec/hash.c
+ create mode 100644 Source/Lib/Codec/hash.h
+ create mode 100644 Source/Lib/Codec/hash_motion.c
+ create mode 100644 Source/Lib/Codec/hash_motion.h
+ create mode 100644 Source/Lib/Codec/vector.c
+ create mode 100644 Source/Lib/Codec/vector.h
+
+diff --git a/Source/Lib/Codec/EbAdaptiveMotionVectorPrediction.c b/Source/Lib/Codec/EbAdaptiveMotionVectorPrediction.c
+index d78c6e9..9b522bf 100644
+--- a/Source/Lib/Codec/EbAdaptiveMotionVectorPrediction.c
++++ b/Source/Lib/Codec/EbAdaptiveMotionVectorPrediction.c
+@@ -165,7 +165,11 @@ static INLINE PredictionMode compound_ref1_mode(PredictionMode mode) {
+ 
+ 
+ /*static INLINE*/ int32_t is_inter_block(const MbModeInfo *mbmi) {
++#if ICOPY
++    return (mbmi->use_intrabc || (mbmi->ref_frame[0] > INTRA_FRAME));
++#else
+     return /*is_intrabc_block(mbmi) ||*/ mbmi->ref_frame[0] > INTRA_FRAME;
++#endif
+ }
+ 
+ static int32_t have_newmv_in_inter_mode(PredictionMode mode) {
+@@ -233,7 +237,11 @@ static MvReferenceFrame ref_frame_map[TOTAL_COMP_REFS][2] = {
+     { ALTREF2_FRAME, ALTREF_FRAME }
+ };
+ 
++#if ICOPY
++void clamp_mv(
++#else
+ static void clamp_mv(
++#endif
+     MV *mv,
+     int32_t min_col,
+     int32_t max_col,
+@@ -1400,6 +1408,9 @@ void update_av1_mi_map(
+ 
+ 
+                 }
++#if ICOPY
++                miPtr[miX + miY * mi_stride].mbmi.use_intrabc = cu_ptr->av1xd->use_intrabc;
++#endif
+ 
+                 miPtr[miX + miY * mi_stride].mbmi.ref_frame[0] = rf[0];
+                 miPtr[miX + miY * mi_stride].mbmi.ref_frame[1] = rf[1];
+@@ -1472,7 +1483,9 @@ void update_mi_map(
+ 
+                     miPtr[miX + miY * mi_stride].mbmi.sb_type = blk_geom->bsize;
+                 }
+-
++#if ICOPY
++                miPtr[miX + miY * mi_stride].mbmi.use_intrabc = cu_ptr->av1xd->use_intrabc;
++#endif
+                 miPtr[miX + miY * mi_stride].mbmi.ref_frame[0] = rf[0];
+                 miPtr[miX + miY * mi_stride].mbmi.ref_frame[1] = rf[1];
+                 if (cu_ptr->prediction_unit_array->inter_pred_direction_index == UNI_PRED_LIST_0) {
+@@ -2059,3 +2072,153 @@ void av1_count_overlappable_neighbors(
+     cu_ptr->prediction_unit_array[0].overlappable_neighbors[1] =
+         count_overlappable_nb_left(cm, xd, mi_row, MAX_SIGNED_VALUE);
+ }
++
++#if ICOPY
++#define INTRABC_DELAY_PIXELS 256  //  Delay of 256 pixels
++#define INTRABC_DELAY_SB64  (INTRABC_DELAY_PIXELS / 64)
++
++void av1_find_ref_dv(IntMv *ref_dv, const TileInfo *const tile,
++    int mib_size, int mi_row, int mi_col) {
++    (void)mi_col;
++    if (mi_row - mib_size < tile->mi_row_start) {
++        ref_dv->as_mv.row = 0;
++        ref_dv->as_mv.col = -MI_SIZE * mib_size - INTRABC_DELAY_PIXELS;
++    }
++    else {
++        ref_dv->as_mv.row = -MI_SIZE * mib_size;
++        ref_dv->as_mv.col = 0;
++    }
++    ref_dv->as_mv.row *= 8;
++    ref_dv->as_mv.col *= 8;
++}
++
++int32_t is_chroma_reference(int32_t mi_row, int32_t mi_col, block_size bsize,
++    int32_t subsampling_x, int32_t subsampling_y);
++
++int av1_is_dv_valid(const MV dv,
++    const MacroBlockD *xd, int mi_row, int mi_col,
++    block_size bsize, int mib_size_log2) {
++    const int bw = block_size_wide[bsize];
++    const int bh = block_size_high[bsize];
++    const int SCALE_PX_TO_MV = 8;
++    // Disallow subpixel for now
++    // SUBPEL_MASK is not the correct scale
++    if (((dv.row & (SCALE_PX_TO_MV - 1)) || (dv.col & (SCALE_PX_TO_MV - 1))))
++        return 0;
++
++    const TileInfo *const tile = &xd->tile;
++    // Is the source top-left inside the current tile?
++    const int src_top_edge = mi_row * MI_SIZE * SCALE_PX_TO_MV + dv.row;
++    const int tile_top_edge = tile->mi_row_start * MI_SIZE * SCALE_PX_TO_MV;
++    if (src_top_edge < tile_top_edge) return 0;
++    const int src_left_edge = mi_col * MI_SIZE * SCALE_PX_TO_MV + dv.col;
++    const int tile_left_edge = tile->mi_col_start * MI_SIZE * SCALE_PX_TO_MV;
++    if (src_left_edge < tile_left_edge) return 0;
++    // Is the bottom right inside the current tile?
++    const int src_bottom_edge = (mi_row * MI_SIZE + bh) * SCALE_PX_TO_MV + dv.row;
++    const int tile_bottom_edge = tile->mi_row_end * MI_SIZE * SCALE_PX_TO_MV;
++    if (src_bottom_edge > tile_bottom_edge) return 0;
++    const int src_right_edge = (mi_col * MI_SIZE + bw) * SCALE_PX_TO_MV + dv.col;
++    const int tile_right_edge = tile->mi_col_end * MI_SIZE * SCALE_PX_TO_MV;
++    if (src_right_edge > tile_right_edge) return 0;
++
++    // Special case for sub 8x8 chroma cases, to prevent referring to chroma
++    // pixels outside current tile.
++    for (int plane = 1; plane < 3/* av1_num_planes(cm)*/; ++plane) {
++        //const struct macroblockd_plane *const pd = &xd->plane[plane];
++
++        if (is_chroma_reference(mi_row, mi_col, bsize, 1, 1/* pd->subsampling_x,
++            pd->subsampling_y*/)) {
++            if (bw < 8 /*&& pd->subsampling_x*/)
++                if (src_left_edge < tile_left_edge + 4 * SCALE_PX_TO_MV) return 0;
++            if (bh < 8/* && pd->subsampling_y*/)
++                if (src_top_edge < tile_top_edge + 4 * SCALE_PX_TO_MV) return 0;
++        }
++    }
++
++    // Is the bottom right within an already coded SB? Also consider additional
++    // constraints to facilitate HW decoder.
++    const int max_mib_size = 1 << mib_size_log2;
++    const int active_sb_row = mi_row >> mib_size_log2;
++    const int active_sb64_col = (mi_col * MI_SIZE) >> 6;
++    const int sb_size = max_mib_size * MI_SIZE;
++    const int src_sb_row = ((src_bottom_edge >> 3) - 1) / sb_size;
++    const int src_sb64_col = ((src_right_edge >> 3) - 1) >> 6;
++    const int total_sb64_per_row =
++        ((tile->mi_col_end - tile->mi_col_start - 1) >> 4) + 1;
++    const int active_sb64 = active_sb_row * total_sb64_per_row + active_sb64_col;
++    const int src_sb64 = src_sb_row * total_sb64_per_row + src_sb64_col;
++    if (src_sb64 >= active_sb64 - INTRABC_DELAY_SB64) return 0;
++
++    // Wavefront constraint: use only top left area of frame for reference.
++    const int gradient = 1 + INTRABC_DELAY_SB64 + (sb_size > 64);
++    const int wf_offset = gradient * (active_sb_row - src_sb_row);
++    if (src_sb_row > active_sb_row ||
++        src_sb64_col >= active_sb64_col - INTRABC_DELAY_SB64 + wf_offset)
++        return 0;
++
++    return 1;
++}
++
++IntMv av1_get_ref_mv_from_stack(int ref_idx,
++    const MvReferenceFrame *ref_frame,
++    int ref_mv_idx,
++    CandidateMv ref_mv_stack[][MAX_REF_MV_STACK_SIZE],
++    MacroBlockD * xd
++/*const MB_MODE_INFO_EXT *mbmi_ext*/) {
++
++    const int8_t ref_frame_type = av1_ref_frame_type(ref_frame);
++    const CandidateMv *curr_ref_mv_stack =
++        /*mbmi_ext->*/ref_mv_stack[ref_frame_type];
++    IntMv ref_mv;
++    ref_mv.as_int = INVALID_MV;
++
++    if (ref_frame[1] > INTRA_FRAME) {
++        if (ref_idx == 0) {
++            ref_mv = curr_ref_mv_stack[ref_mv_idx].this_mv;
++        }
++        else {
++            assert(ref_idx == 1);
++            ref_mv = curr_ref_mv_stack[ref_mv_idx].comp_mv;
++        }
++    }
++    else {
++        assert(ref_idx == 0);
++        if (ref_mv_idx < /*mbmi_ext->*/xd->ref_mv_count[ref_frame_type]) {
++            ref_mv = curr_ref_mv_stack[ref_mv_idx].this_mv;
++        }
++        else {
++            //CHKN got this from decoder read_intrabc_info global_mvs[ref_frame].as_int = INVALID_MV;
++            ref_mv.as_int = INVALID_MV;// mbmi_ext->global_mvs[ref_frame_type];
++        }
++    }
++    return ref_mv;
++}
++
++static INLINE void lower_mv_precision(MV *mv, int allow_hp, int is_integer) {
++    if (is_integer) {
++        integer_mv_precision(mv);
++    }
++    else {
++        if (!allow_hp) {
++            if (mv->row & 1) mv->row += (mv->row > 0 ? -1 : 1);
++            if (mv->col & 1) mv->col += (mv->col > 0 ? -1 : 1);
++        }
++    }
++}
++void av1_find_best_ref_mvs_from_stack(int allow_hp,
++    //const MB_MODE_INFO_EXT *mbmi_ext,
++    CandidateMv ref_mv_stack[][MAX_REF_MV_STACK_SIZE],
++    MacroBlockD * xd,
++    MvReferenceFrame ref_frame,
++    IntMv *nearest_mv, IntMv *near_mv,
++    int is_integer)
++{
++    const int ref_idx = 0;
++    MvReferenceFrame ref_frames[2] = { ref_frame, NONE_FRAME };
++    *nearest_mv = av1_get_ref_mv_from_stack(ref_idx, ref_frames, 0, ref_mv_stack/*mbmi_ext*/, xd);
++    lower_mv_precision(&nearest_mv->as_mv, allow_hp, is_integer);
++    *near_mv = av1_get_ref_mv_from_stack(ref_idx, ref_frames, 1, ref_mv_stack/*mbmi_ext*/, xd);
++    lower_mv_precision(&near_mv->as_mv, allow_hp, is_integer);
++}
++#endif
+\ No newline at end of file
+diff --git a/Source/Lib/Codec/EbAdaptiveMotionVectorPrediction.h b/Source/Lib/Codec/EbAdaptiveMotionVectorPrediction.h
+index efc10fe..9233de7 100644
+--- a/Source/Lib/Codec/EbAdaptiveMotionVectorPrediction.h
++++ b/Source/Lib/Codec/EbAdaptiveMotionVectorPrediction.h
+@@ -151,6 +151,20 @@ extern "C" {
+         int32_t                           mi_row,
+         int32_t                           mi_col);
+ 
++#if ICOPY
++    void av1_find_best_ref_mvs_from_stack(int allow_hp,
++        CandidateMv ref_mv_stack[][MAX_REF_MV_STACK_SIZE],
++        MacroBlockD * xd,
++        MvReferenceFrame ref_frame,
++        IntMv *nearest_mv, IntMv *near_mv,
++        int is_integer);
++    void av1_find_ref_dv(IntMv *ref_dv, const TileInfo *const tile,
++        int mib_size, int mi_row, int mi_col);
++    int av1_is_dv_valid(const MV dv,
++        const MacroBlockD *xd, int mi_row, int mi_col,
++        block_size bsize, int mib_size_log2);
++#endif
++
+ #ifdef __cplusplus
+ }
+ #endif
+diff --git a/Source/Lib/Codec/EbCdefProcess.c b/Source/Lib/Codec/EbCdefProcess.c
+index e7e1558..2306caa 100644
+--- a/Source/Lib/Codec/EbCdefProcess.c
++++ b/Source/Lib/Codec/EbCdefProcess.c
+@@ -593,7 +593,7 @@ void* cdef_kernel(void *input_ptr)
+         }
+         else {
+ 
+-#if CDEF_REF_ONLY
++#if CDEF_REF_ONLY || ICOPY
+             picture_control_set_ptr->parent_pcs_ptr->cdef_bits = 0;
+             picture_control_set_ptr->parent_pcs_ptr->cdef_strengths[0] = 0;
+             picture_control_set_ptr->parent_pcs_ptr->nb_cdef_strengths = 1;
+diff --git a/Source/Lib/Codec/EbCodingLoop.c b/Source/Lib/Codec/EbCodingLoop.c
+index ef62803..15529f1 100644
+--- a/Source/Lib/Codec/EbCodingLoop.c
++++ b/Source/Lib/Codec/EbCodingLoop.c
+@@ -3246,8 +3246,11 @@ EB_EXTERN void AV1EncodePass(
+ #endif
+ 
+                 if (cu_ptr->prediction_mode_flag == INTRA_MODE) {
+-
++#if ICOPY
++                    context_ptr->is_inter = cu_ptr->av1xd->use_intrabc;
++#else
+                     context_ptr->is_inter = 0;
++#endif
+                     context_ptr->tot_intra_coded_area += blk_geom->bwidth* blk_geom->bheight;
+                     if (picture_control_set_ptr->slice_type != I_SLICE) {
+                         context_ptr->intra_coded_area_sb[tbAddr] += blk_geom->bwidth* blk_geom->bheight;
+@@ -3279,10 +3282,88 @@ EB_EXTERN void AV1EncodePass(
+ 
+                             uint32_t cu_originy_uv = (context_ptr->cu_origin_y >> 3 << 3) >> 1;
+                             uint32_t cu_originx_uv = (context_ptr->cu_origin_x >> 3 << 3) >> 1;
+-                            if (is16bit) {
+-                                uint16_t    topNeighArray[64 * 2 + 1];
+-                                uint16_t    leftNeighArray[64 * 2 + 1];
+-                                PredictionMode mode;
++#if ICOPY
++                            if (cu_ptr->av1xd->use_intrabc)
++                            {
++                                MvReferenceFrame ref_frame = INTRA_FRAME;
++                                generate_av1_mvp_table(
++#if TILES
++                                    &sb_ptr->tile_info,
++#endif
++                                    context_ptr->md_context,
++                                    cu_ptr,
++                                    context_ptr->blk_geom,
++                                    context_ptr->cu_origin_x,
++                                    context_ptr->cu_origin_y,
++                                    &ref_frame,
++                                    1,
++                                    picture_control_set_ptr);
++
++                                IntMv nearestmv, nearmv;
++                                av1_find_best_ref_mvs_from_stack(0, context_ptr->md_context->md_local_cu_unit[blk_geom->blkidx_mds].ed_ref_mv_stack, cu_ptr->av1xd, ref_frame, &nearestmv, &nearmv,
++                                    0);
++
++                                if (nearestmv.as_int == INVALID_MV) {
++                                    nearestmv.as_int = 0;
++                                }
++                                if (nearmv.as_int == INVALID_MV) {
++                                    nearmv.as_int = 0;
++                                }
++
++                                IntMv dv_ref = nearestmv.as_int == 0 ? nearmv : nearestmv;
++                                if (dv_ref.as_int == 0)
++                                    av1_find_ref_dv(&dv_ref, &cu_ptr->av1xd->tile, sequence_control_set_ptr->mib_size, context_ptr->cu_origin_y >> MI_SIZE_LOG2, context_ptr->cu_origin_x >> MI_SIZE_LOG2);
++                                // Ref DV should not have sub-pel.
++                                assert((dv_ref.as_mv.col & 7) == 0);
++                                assert((dv_ref.as_mv.row & 7) == 0);
++                                context_ptr->md_context->md_local_cu_unit[blk_geom->blkidx_mds].ed_ref_mv_stack[INTRA_FRAME][0].this_mv = dv_ref;
++                                cu_ptr->predmv[0] = dv_ref;
++
++                                //keep final usefull mvp for entropy
++                                memcpy(cu_ptr->av1xd->final_ref_mv_stack,
++                                    context_ptr->md_context->md_local_cu_unit[context_ptr->blk_geom->blkidx_mds].ed_ref_mv_stack[cu_ptr->prediction_unit_array[0].ref_frame_type],
++                                    sizeof(CandidateMv)*MAX_REF_MV_STACK_SIZE);
++
++                                pu_ptr = cu_ptr->prediction_unit_array;
++                                // Set MvUnit
++                                context_ptr->mv_unit.predDirection = (uint8_t)pu_ptr->inter_pred_direction_index;
++                                context_ptr->mv_unit.mv[REF_LIST_0].mvUnion = pu_ptr->mv[REF_LIST_0].mvUnion;
++                                context_ptr->mv_unit.mv[REF_LIST_1].mvUnion = pu_ptr->mv[REF_LIST_1].mvUnion;
++
++                                EbPictureBufferDesc_t * ref_pic_list0 = ((EbReferenceObject_t*)picture_control_set_ptr->parent_pcs_ptr->reference_picture_wrapper_ptr->object_ptr)->referencePicture;
++
++                                av1_inter_prediction(
++                                    picture_control_set_ptr,
++                                    cu_ptr->interp_filters,
++                                    cu_ptr,
++                                    cu_ptr->prediction_unit_array->ref_frame_type,
++                                    &context_ptr->mv_unit,
++#if ICOPY
++                                    1,// use_intrabc,
++#endif
++                                    context_ptr->cu_origin_x,
++                                    context_ptr->cu_origin_y,
++                                    blk_geom->bwidth,
++                                    blk_geom->bheight,
++                                    ref_pic_list0,
++                                    0,
++                                    recon_buffer,
++                                    context_ptr->cu_origin_x,
++                                    context_ptr->cu_origin_y,
++#if CHROMA_BLIND
++                                    EB_TRUE,
++#endif
++                                    asm_type);
++
++
++                            }
++                            else
++                            {
++#endif
++                                if (is16bit) {
++                                    uint16_t    topNeighArray[64 * 2 + 1];
++                                    uint16_t    leftNeighArray[64 * 2 + 1];
++                                    PredictionMode mode;
+ 
+                                 int32_t plane_end = blk_geom->has_uv ? 2 : 0;
+ 
+@@ -3434,7 +3515,10 @@ EB_EXTERN void AV1EncodePass(
+                                         0,  // MD ONLY - NOT USED BY ENCDEC
+                                         0);
+                                 }
++                                }
++#if ICOPY
+                             }
++#endif
+ 
+ #else
+                             uint8_t    topNeighArray[64 * 2 + 1];
+@@ -3766,6 +3850,9 @@ EB_EXTERN void AV1EncodePass(
+                                     cu_ptr,
+                                     cu_ptr->prediction_unit_array->ref_frame_type,
+                                     &context_ptr->mv_unit,
++#if ICOPY
++                                    0,//use_intrabc,
++#endif
+                                     context_ptr->cu_origin_x,
+                                     context_ptr->cu_origin_y,
+                                     blk_geom->bwidth,
+diff --git a/Source/Lib/Codec/EbCodingUnit.h b/Source/Lib/Codec/EbCodingUnit.h
+index 826b53c..380a721 100644
+--- a/Source/Lib/Codec/EbCodingUnit.h
++++ b/Source/Lib/Codec/EbCodingUnit.h
+@@ -14,6 +14,9 @@
+ #include "EbPredictionUnit.h"
+ #include "EbTransformUnit.h"
+ #include "EbCabacContextModel.h"
++#if ICOPY
++#include "hash.h"
++#endif
+ 
+ #ifdef __cplusplus
+ extern "C" {
+@@ -181,7 +184,11 @@ extern "C" {
+         // Only for INTRA blocks
+         UV_PredictionMode uv_mode;
+         //PALETTE_MODE_INFO palette_mode_info;
++#if ICOPY
++        uint8_t use_intrabc;
++#else
+         //uint8_t use_intrabc;
++#endif
+         // Only for INTER blocks
+         //InterpFilters interp_filters;
+         MvReferenceFrame ref_frame[2];
+@@ -239,6 +246,44 @@ extern "C" {
+         int32_t tile_col;
+ #endif
+     } TileInfo;
++
++#if ICOPY
++    typedef struct macroblockd_plane {
++
++        int subsampling_x;
++        int subsampling_y;
++        struct buf_2d dst;
++        struct buf_2d pre[2];
++        // block size in pixels
++        uint8_t width, height;
++
++    } MACROBLOCKD_PLANE;
++
++    typedef struct macroblock_plane {
++#if 0
++        DECLARE_ALIGNED(16, int16_t, src_diff[MAX_SB_SQUARE]);
++        tran_low_t *qcoeff;
++        tran_low_t *coeff;
++        uint16_t *eobs;
++        uint8_t *txb_entropy_ctx;
++#endif
++        struct buf_2d src;
++#if 0
++        // Quantizer setings
++        // These are used/accessed only in the quantization process
++        // RDO does not / must not depend on any of these values
++        // All values below share the coefficient scale/shift used in TX
++        const int16_t *quant_fp_QTX;
++        const int16_t *round_fp_QTX;
++        const int16_t *quant_QTX;
++        const int16_t *quant_shift_QTX;
++        const int16_t *zbin_QTX;
++        const int16_t *round_QTX;
++        const int16_t *dequant_QTX;
++#endif
++    } MACROBLOCK_PLANE;
++#endif
++
+     typedef struct MacroBlockD {
+         // block dimension in the unit of mode_info.
+         uint8_t n8_w, n8_h;
+@@ -258,13 +303,50 @@ extern "C" {
+         int32_t mb_to_top_edge;
+         int32_t mb_to_bottom_edge;
+         uint8_t neighbors_ref_counts[TOTAL_REFS_PER_FRAME];
++
++#if ICOPY 
++        uint8_t  use_intrabc;
++        MbModeInfo *above_mbmi;
++        MbModeInfo *left_mbmi;
++        MbModeInfo *chroma_above_mbmi;
++        MbModeInfo *chroma_left_mbmi;
++#endif
+     } MacroBlockD;
++
+     typedef struct Macroblock {
+         int32_t rdmult;
+         int32_t switchable_restore_cost[RESTORE_SWITCHABLE_TYPES];
+         int32_t wiener_restore_cost[2];
+         int32_t sgrproj_restore_cost[2];
+     } Macroblock;
++
++#if ICOPY
++    typedef struct IntraBcContext {
++        int32_t rdmult;
++        struct macroblockd_plane xdplane[MAX_MB_PLANE];
++        struct macroblock_plane plane[MAX_MB_PLANE];
++        MvLimits mv_limits;
++        // The equivalend SAD error of one (whole) bit at the current quantizer
++       // for large blocks.
++        int sadperbit16;
++        // The equivalent error at the current rdmult of one whole bit (not one
++        // bitcost unit).
++        int errorperbit;
++        // Store the best motion vector during motion search
++        IntMv best_mv;
++        // Store the second best motion vector during full-pixel motion search
++        IntMv second_best_mv;
++        MacroBlockD * xd;
++        int* nmv_vec_cost;
++        int **mv_cost_stack;
++        // buffer for hash value calculation of a block
++        // used only in av1_get_block_hash_value()
++        // [first hash/second hash]
++        // [two buffers used ping-pong]
++        uint32_t *hash_value_buffer[2][2];
++    } IntraBcContext;
++#endif
++
+     typedef struct CodingUnit_s
+     {
+         TransformUnit_t             transform_unit_array[TRANSFORM_UNIT_MAX_COUNT]; // 2-bytes * 21 = 42-bytes
+diff --git a/Source/Lib/Codec/EbEncDecProcess.c b/Source/Lib/Codec/EbEncDecProcess.c
+index c5834d1..389cd07 100644
+--- a/Source/Lib/Codec/EbEncDecProcess.c
++++ b/Source/Lib/Codec/EbEncDecProcess.c
+@@ -393,6 +393,9 @@ static void ResetEncDec(
+ 
+         // Initial Rate Estimatimation of the Motion vectors
+         av1_estimate_mv_rate(
++#if ICOPY
++            picture_control_set_ptr,
++#endif
+             md_rate_estimation_array,
+             &picture_control_set_ptr->coeff_est_entropy_coder_ptr->fc->nmvc);
+ 
+diff --git a/Source/Lib/Codec/EbEncHandle.c b/Source/Lib/Codec/EbEncHandle.c
+index 0ffb802..4f7dad4 100644
+--- a/Source/Lib/Codec/EbEncHandle.c
++++ b/Source/Lib/Codec/EbEncHandle.c
+@@ -410,6 +410,10 @@ void asmSetConvolveAsmTable(void);
+ void asmSetConvolveHbdAsmTable(void);
+ void init_intra_dc_predictors_c_internal(void);
+ void init_intra_predictors_internal(void);
++#if ICOPY
++void av1_init_me_luts(void);
++#endif
++
+ void SwitchToRealTime(){
+ #if defined(__linux__) || defined(__APPLE__)
+ 
+@@ -885,6 +889,10 @@ EbErrorType RestResultsCtor(
+     return EB_ErrorNone;
+ }
+ #endif
++#if ICOPY
++void init_fn_ptr(void);
++#endif
++
+ /**********************************
+ * Initialize Encoder Library
+ **********************************/
+@@ -932,6 +940,10 @@ EB_API EbErrorType eb_init_encoder(EbComponentType *svt_enc_component)
+ 
+     build_blk_geom(scs_init.sb_size == 128);
+ 
++#if ICOPY
++    av1_init_me_luts();
++    init_fn_ptr();
++#endif
+ 
+     /************************************
+     * Sequence Control Set
+diff --git a/Source/Lib/Codec/EbEntropyCoding.c b/Source/Lib/Codec/EbEntropyCoding.c
+index 5353b46..d941c25 100644
+--- a/Source/Lib/Codec/EbEntropyCoding.c
++++ b/Source/Lib/Codec/EbEntropyCoding.c
+@@ -478,7 +478,11 @@ void Av1WriteTxType(
+     TxType                     txType,
+     TxSize                      txSize) {
+ 
++#if ICOPY
++    const int32_t isInter = cu_ptr->av1xd->use_intrabc || (cu_ptr->prediction_mode_flag == INTER_MODE);
++#else
+     const int32_t isInter = (cu_ptr->prediction_mode_flag == INTER_MODE);
++#endif
+ 
+     const TxSize squareTxSize = txsize_sqr_map[txSize];
+ 
+@@ -4035,8 +4039,12 @@ static void WriteUncompressedHeaderObu(SequenceControlSet_t *scsPtr/*AV1_COMP *c
+         write_frame_size(pcsPtr, frame_size_override_flag, wb);
+         //assert(av1_superres_unscaled(cm) ||
+         //    !(cm->allow_intrabc && NO_FILTER_FOR_IBC));
++#if ICOPY
++        if (pcsPtr->allow_screen_content_tools)
++#else
+         if (pcsPtr->allow_screen_content_tools &&
+             0 /*(av1_superres_unscaled(cm) || !NO_FILTER_FOR_IBC)*/)
++#endif
+             aom_wb_write_bit(wb, pcsPtr->allow_intrabc);
+         // all eight fbs are refreshed, pick one that will live long enough
+         pcsPtr->fb_of_context_type[REGULAR_FRAME] = 0;
+@@ -4044,8 +4052,12 @@ static void WriteUncompressedHeaderObu(SequenceControlSet_t *scsPtr/*AV1_COMP *c
+     else {
+         if (pcsPtr->av1FrameType == INTRA_ONLY_FRAME) {
+             write_frame_size(pcsPtr, frame_size_override_flag, wb);
++#if ICOPY
++            if (pcsPtr->allow_screen_content_tools)
++#else
+             if (pcsPtr->allow_screen_content_tools &&
+                 0 /*(av1_superres_unscaled(cm) || !NO_FILTER_FOR_IBC)*/)
++#endif
+                 aom_wb_write_bit(wb, pcsPtr->allow_intrabc);
+         }
+         else if (pcsPtr->av1FrameType == INTER_FRAME || frame_is_sframe(pcsPtr)) {
+@@ -5009,6 +5021,109 @@ EbErrorType ec_update_neighbors(
+     return return_error;
+ 
+ }
++#if ICOPY
++int32_t is_chroma_reference(int32_t mi_row, int32_t mi_col, block_size bsize,
++    int32_t subsampling_x, int32_t subsampling_y);
++
++static INLINE int av1_allow_palette(int allow_screen_content_tools,
++    block_size sb_type) {
++    return allow_screen_content_tools && block_size_wide[sb_type] <= 64 &&
++        block_size_high[sb_type] <= 64 && sb_type >= BLOCK_8X8;
++}
++
++static INLINE int av1_get_palette_bsize_ctx(block_size bsize) {
++    return num_pels_log2_lookup[bsize] - num_pels_log2_lookup[BLOCK_8X8];
++}
++static void write_palette_mode_info(
++    FRAME_CONTEXT           *ec_ctx,
++    CodingUnit_t            *cu_ptr,
++    block_size bsize,
++    int mi_row,
++    int mi_col, aom_writer *w)
++{
++    const uint32_t intra_luma_mode = cu_ptr->pred_mode;
++    uint32_t intra_chroma_mode = cu_ptr->prediction_unit_array->intra_chroma_mode;
++
++    const int num_planes = 3;// av1_num_planes(cm);
++    //const BLOCK_SIZE bsize = mbmi->sb_type;
++    //assert(av1_allow_palette(cm->allow_screen_content_tools, bsize));
++   // const PALETTE_MODE_INFO *const pmi = &mbmi->palette_mode_info;
++    const int bsize_ctx = av1_get_palette_bsize_ctx(bsize);
++
++    if (intra_luma_mode == DC_PRED) {
++        const int n = 0;// pmi->palette_size[0];
++        const int palette_y_mode_ctx = 0;// av1_get_palette_mode_ctx(xd);
++        aom_write_symbol(
++            w, n > 0,
++            ec_ctx->palette_y_mode_cdf[bsize_ctx][palette_y_mode_ctx], 2);
++        if (n > 0) {
++            //aom_write_symbol(w, n - PALETTE_MIN_SIZE,
++            //    xd->tile_ctx->palette_y_size_cdf[bsize_ctx],
++            //    PALETTE_SIZES);
++            //write_palette_colors_y(xd, pmi, cm->seq_params.bit_depth, w);
++        }
++    }
++
++    const int uv_dc_pred =
++        num_planes > 1 && intra_chroma_mode == UV_DC_PRED &&
++        is_chroma_reference(mi_row, mi_col, bsize, 1, 1);
++    if (uv_dc_pred) {
++        const int n = 0;// pmi->palette_size[1];
++        const int palette_uv_mode_ctx = 0;// (pmi->palette_size[0] > 0);
++        aom_write_symbol(w, n > 0,
++            ec_ctx->palette_uv_mode_cdf[palette_uv_mode_ctx], 2);
++        if (n > 0) {
++            /*           aom_write_symbol(w, n - PALETTE_MIN_SIZE,
++                           xd->tile_ctx->palette_uv_size_cdf[bsize_ctx],
++                           PALETTE_SIZES);
++                       write_palette_colors_uv(xd, pmi, cm->seq_params.bit_depth, w);*/
++        }
++    }
++}
++void av1_encode_dv(aom_writer *w, const MV *mv, const MV *ref,
++    nmv_context *mvctx) {
++    // DV and ref DV should not have sub-pel.
++    assert((mv->col & 7) == 0);
++    assert((mv->row & 7) == 0);
++    assert((ref->col & 7) == 0);
++    assert((ref->row & 7) == 0);
++    const MV diff = { mv->row - ref->row, mv->col - ref->col };
++    const MV_JOINT_TYPE j = av1_get_mv_joint((int32_t*)&diff);
++
++    aom_write_symbol(w, j, mvctx->joints_cdf, MV_JOINTS);
++    if (mv_joint_vertical(j))
++        encode_mv_component(w, diff.row, &mvctx->comps[0], MV_SUBPEL_NONE);
++
++    if (mv_joint_horizontal(j))
++        encode_mv_component(w, diff.col, &mvctx->comps[1], MV_SUBPEL_NONE);
++}
++
++int av1_allow_intrabc(const Av1Common *const cm) {
++
++    return (cm->p_pcs_ptr->slice_type == I_SLICE && cm->p_pcs_ptr->allow_screen_content_tools && cm->p_pcs_ptr->allow_intrabc);
++}
++
++static void write_intrabc_info(
++    FRAME_CONTEXT           *ec_ctx,
++    CodingUnit_t            *cu_ptr,
++    aom_writer *w) {
++
++
++    int use_intrabc = cu_ptr->av1xd->use_intrabc;
++    aom_write_symbol(w, use_intrabc, ec_ctx->intrabc_cdf, 2);
++    if (use_intrabc) {
++        //assert(mbmi->mode == DC_PRED);
++        //assert(mbmi->uv_mode == UV_DC_PRED);
++        //assert(mbmi->motion_mode == SIMPLE_TRANSLATION);
++        IntMv dv_ref = cu_ptr->predmv[0];// mbmi_ext->ref_mv_stack[INTRA_FRAME][0].this_mv;
++        MV mv;
++        mv.row = cu_ptr->prediction_unit_array[0].mv[INTRA_FRAME].y;
++        mv.col = cu_ptr->prediction_unit_array[0].mv[INTRA_FRAME].x;
++
++        av1_encode_dv(w, &mv, &dv_ref.as_mv, &ec_ctx->ndvc);
++    }
++}
++#endif
+ 
+ EbErrorType write_modes_b(
+     PictureControlSet_t     *picture_control_set_ptr,
+@@ -5100,6 +5215,12 @@ EbErrorType write_modes_b(
+             const uint32_t intra_luma_mode = cu_ptr->pred_mode;
+             uint32_t intra_chroma_mode = cu_ptr->prediction_unit_array->intra_chroma_mode;
+ 
++#if ICOPY
++            if (av1_allow_intrabc(picture_control_set_ptr->parent_pcs_ptr->av1_cm))
++                write_intrabc_info(frameContext, cu_ptr, ecWriter);
++
++            if (cu_ptr->av1xd->use_intrabc == 0)
++#endif
+             EncodeIntraLumaModeAv1(
+                 frameContext,
+                 ecWriter,
+@@ -5119,15 +5240,28 @@ EbErrorType write_modes_b(
+                 blk_geom->bheight,
+                 NEIGHBOR_ARRAY_UNIT_TOP_AND_LEFT_ONLY_MASK);
+ 
++#if ICOPY
++            if (cu_ptr->av1xd->use_intrabc == 0)
++#endif
++                if (blk_geom->has_uv)
++                    EncodeIntraChromaModeAv1(
++                        frameContext,
++                        ecWriter,
++                        cu_ptr,
++                        intra_luma_mode,
++                        intra_chroma_mode,
++                        blk_geom->bwidth <= 32 && blk_geom->bheight <= 32);
+ 
+-            if (blk_geom->has_uv)
+-                EncodeIntraChromaModeAv1(
++#if ICOPY
++            if (cu_ptr->av1xd->use_intrabc == 0 && av1_allow_palette(picture_control_set_ptr->parent_pcs_ptr->allow_screen_content_tools, blk_geom->bsize))
++                write_palette_mode_info(
+                     frameContext,
+-                    ecWriter,
+                     cu_ptr,
+-                    intra_luma_mode,
+-                    intra_chroma_mode,
+-                    blk_geom->bwidth <= 32 && blk_geom->bheight <= 32);
++                    blk_geom->bsize,
++                    blkOriginY >> MI_SIZE_LOG2,
++                    blkOriginX >> MI_SIZE_LOG2,
++                    ecWriter);
++#endif
+ 
+             if (!skipCoeff) {
+                 Av1EncodeCoeff1D(
+diff --git a/Source/Lib/Codec/EbFullLoop.c b/Source/Lib/Codec/EbFullLoop.c
+index 66b3daf..4f50239 100644
+--- a/Source/Lib/Codec/EbFullLoop.c
++++ b/Source/Lib/Codec/EbFullLoop.c
+@@ -1149,7 +1149,11 @@ void ProductFullLoopTxSearch(
+     uint64_t                       y_tu_coeff_bits;
+     uint64_t                       tuFullDistortion[3][DIST_CALC_TOTAL];
+     int32_t                        plane = 0;
++#if ICOPY
++    const int32_t                  is_inter = (candidateBuffer->candidate_ptr->type == INTER_MODE || candidateBuffer->candidate_ptr->use_intrabc) ? EB_TRUE : EB_FALSE;
++#else
+     const int32_t                  is_inter = candidateBuffer->candidate_ptr->type == INTER_MODE ? EB_TRUE : EB_FALSE;//is_inter_block(mbmi);
++#endif
+     uint64_t                       bestFullCost = UINT64_MAX;
+     uint64_t                       y_full_cost = MAX_CU_COST;
+     uint32_t                       yCountNonZeroCoeffsTemp;
+diff --git a/Source/Lib/Codec/EbInterPrediction.c b/Source/Lib/Codec/EbInterPrediction.c
+index fb2df56..9410d83 100644
+--- a/Source/Lib/Codec/EbInterPrediction.c
++++ b/Source/Lib/Codec/EbInterPrediction.c
+@@ -963,12 +963,50 @@ int32_t is_inter_block(const MbModeInfo *mbmi);
+ block_size scale_chroma_bsize(block_size bsize, int32_t subsampling_x,
+     int32_t subsampling_y);
+ 
++#if ICOPY
++// A special 2-tap bilinear filter for IntraBC chroma. IntraBC uses full pixel
++// MV for luma. If sub-sampling exists, chroma may possibly use half-pel MV.
++DECLARE_ALIGNED(256, static const int16_t, av1_intrabc_bilinear_filter[2]) = {
++  64,
++  64,
++};
++
++static const InterpFilterParams av1_intrabc_filter_params = {
++  av1_intrabc_bilinear_filter, 2, 0, BILINEAR
++};
++static void convolve_2d_for_intrabc(const uint8_t *src, int src_stride,
++    uint8_t *dst, int dst_stride, int w, int h,
++    int subpel_x_q4, int subpel_y_q4,
++    ConvolveParams *conv_params)
++{
++    const InterpFilterParams *filter_params_x =
++        subpel_x_q4 ? &av1_intrabc_filter_params : NULL;
++    const InterpFilterParams *filter_params_y =
++        subpel_y_q4 ? &av1_intrabc_filter_params : NULL;
++    if (subpel_x_q4 != 0 && subpel_y_q4 != 0) {
++        av1_convolve_2d_sr_c(src, src_stride, dst, dst_stride, w, h,
++            (InterpFilterParams *)filter_params_x, (InterpFilterParams *)filter_params_y, 0, 0, conv_params);
++    }
++    else if (subpel_x_q4 != 0) {
++        av1_convolve_x_sr_c(src, src_stride, dst, dst_stride, w, h, (InterpFilterParams *)filter_params_x,
++            (InterpFilterParams *)filter_params_y, 0, 0, conv_params);
++    }
++    else {
++        av1_convolve_y_sr_c(src, src_stride, dst, dst_stride, w, h, (InterpFilterParams *)filter_params_x,
++            (InterpFilterParams *)filter_params_y, 0, 0, conv_params);
++    }
++}
++#endif
++
+ EbErrorType av1_inter_prediction(
+     PictureControlSet_t                    *picture_control_set_ptr,
+     uint32_t                                interp_filters,
+     CodingUnit_t                           *cu_ptr,
+     uint8_t                                 ref_frame_type,
+     MvUnit_t                               *mv_unit,
++#if ICOPY
++    uint8_t                                  use_intrabc,
++#endif
+     uint16_t                                pu_origin_x,
+     uint16_t                                pu_origin_y,
+     uint8_t                                 bwidth,
+@@ -1041,6 +1079,9 @@ EbErrorType av1_inter_prediction(
+             av1_set_ref_frame(rf, ref_frame_type);
+             for (miY = 0; miY < (blk_geom->bheight >> MI_SIZE_LOG2); miY++) {
+                 for (miX = 0; miX < (blk_geom->bwidth >> MI_SIZE_LOG2); miX++) {
++#if ICOPY
++                    miPtr[miX + miY * xd->mi_stride].mbmi.use_intrabc = use_intrabc;
++#endif
+                     miPtr[miX + miY * xd->mi_stride].mbmi.ref_frame[0] = rf[0];
+                     if (mv_unit->predDirection == UNI_PRED_LIST_0) {
+                         miPtr[miX + miY * xd->mi_stride].mbmi.mv[0].as_mv.col = mv_unit->mv[REF_LIST_0].x;
+@@ -1073,7 +1114,11 @@ EbErrorType av1_inter_prediction(
+         sub8x8_inter = (block_size_wide[bsize] < 8 && ss_x) ||
+             (block_size_high[bsize] < 8 && ss_y);
+ 
++#if ICOPY
++        if (use_intrabc) sub8x8_inter = 0;
++#else
+         //if (is_intrabc) sub8x8_inter = 0;
++#endif
+ 
+         // For sub8x8 chroma blocks, we may be covering more than one luma block's
+         // worth of pixels. Thus (mi_x, mi_y) may not be the correct coordinates for
+@@ -1272,6 +1317,12 @@ EbErrorType av1_inter_prediction(
+             av1_get_convolve_filter_params(interp_filters, &filter_params_x,
+                 &filter_params_y, blk_geom->bwidth_uv, blk_geom->bheight_uv);
+ 
++#if ICOPY 
++            if (use_intrabc && (subpel_x != 0 || subpel_y != 0))
++                convolve_2d_for_intrabc((const uint8_t *)src_ptr, src_stride, dst_ptr, dst_stride, blk_geom->bwidth_uv, blk_geom->bheight_uv, subpel_x,
++                    subpel_y, &conv_params);
++            else
++#endif
+             convolve[subpel_x != 0][subpel_y != 0][is_compound](
+                 src_ptr,
+                 src_stride,
+@@ -1297,6 +1348,13 @@ EbErrorType av1_inter_prediction(
+             subpel_y = mv_q4.row & SUBPEL_MASK;
+             src_ptr = src_ptr + (mv_q4.row >> SUBPEL_BITS) * src_stride + (mv_q4.col >> SUBPEL_BITS);
+             conv_params = get_conv_params_no_round(0, 0, 0, tmp_dstCr, 64, is_compound, EB_8BIT);
++
++#if ICOPY 
++            if (use_intrabc && (subpel_x != 0 || subpel_y != 0))
++                convolve_2d_for_intrabc((const uint8_t *)src_ptr, src_stride, dst_ptr, dst_stride, blk_geom->bwidth_uv, blk_geom->bheight_uv, subpel_x,
++                    subpel_y, &conv_params);
++            else
++#endif
+             convolve[subpel_x != 0][subpel_y != 0][is_compound](
+                 src_ptr,
+                 src_stride,
+@@ -3576,6 +3634,9 @@ static const int32_t filter_sets[DUAL_FILTER_SET_SIZE][2] = {
+         md_context_ptr->cu_ptr,
+         candidate_buffer_ptr->candidate_ptr->ref_frame_type,
+         &mv_unit,
++#if ICOPY
++        0,
++#endif
+         md_context_ptr->cu_origin_x,
+         md_context_ptr->cu_origin_y,
+         md_context_ptr->blk_geom->bwidth,
+@@ -3657,6 +3718,9 @@ static const int32_t filter_sets[DUAL_FILTER_SET_SIZE][2] = {
+                         md_context_ptr->cu_ptr,
+                         candidate_buffer_ptr->candidate_ptr->ref_frame_type,
+                         &mv_unit,
++#if ICOPY
++                        0,
++#endif
+                         md_context_ptr->cu_origin_x,
+                         md_context_ptr->cu_origin_y,
+                         md_context_ptr->blk_geom->bwidth,
+@@ -3735,6 +3799,9 @@ static const int32_t filter_sets[DUAL_FILTER_SET_SIZE][2] = {
+                         md_context_ptr->cu_ptr,
+                         candidate_buffer_ptr->candidate_ptr->ref_frame_type,
+                         &mv_unit,
++#if ICOPY
++                        0,
++#endif
+                         md_context_ptr->cu_origin_x,
+                         md_context_ptr->cu_origin_y,
+                         md_context_ptr->blk_geom->bwidth,
+@@ -3816,6 +3883,9 @@ static const int32_t filter_sets[DUAL_FILTER_SET_SIZE][2] = {
+                         md_context_ptr->cu_ptr,
+                         candidate_buffer_ptr->candidate_ptr->ref_frame_type,
+                         &mv_unit,
++#if ICOPY
++                        0,
++#endif
+                         md_context_ptr->cu_origin_x,
+                         md_context_ptr->cu_origin_y,
+                         md_context_ptr->blk_geom->bwidth,
+@@ -4287,6 +4357,42 @@ EbErrorType inter_pu_prediction_av1(
+     int32_t rs = 0;
+     int64_t rd = INT64_MAX;
+ 
++#if ICOPY
++    if (candidate_buffer_ptr->candidate_ptr->use_intrabc)
++    {
++        if (is16bit) {
++            printf("ibc_need_10bit\n");
++            ref_pic_list0 = NULL;
++        }
++        else {
++            ref_pic_list0 = ((EbReferenceObject_t*)picture_control_set_ptr->parent_pcs_ptr->reference_picture_wrapper_ptr->object_ptr)->referencePicture;
++        }
++
++        av1_inter_prediction(
++            picture_control_set_ptr,
++            candidate_buffer_ptr->candidate_ptr->interp_filters,
++            md_context_ptr->cu_ptr,
++            candidate_buffer_ptr->candidate_ptr->ref_frame_type,
++            &mv_unit,
++            1,//use_intrabc
++            md_context_ptr->cu_origin_x,
++            md_context_ptr->cu_origin_y,
++            md_context_ptr->blk_geom->bwidth,
++            md_context_ptr->blk_geom->bheight,
++            ref_pic_list0,
++            0,//ref_pic_list1,
++            candidate_buffer_ptr->prediction_ptr,
++            md_context_ptr->blk_geom->origin_x,
++            md_context_ptr->blk_geom->origin_y,
++#if CHROMA_BLIND
++            md_context_ptr->chroma_level == CHROMA_MODE_0,
++#endif
++            asm_type);
++
++        return return_error;
++
++    }
++#endif
+     if (is16bit) {
+         ref_pic_list0 = ((EbReferenceObject_t*)picture_control_set_ptr->ref_pic_ptr_array[REF_LIST_0]->object_ptr)->referencePicture16bit;
+         if (picture_control_set_ptr->slice_type == B_SLICE)
+@@ -4414,6 +4520,9 @@ EbErrorType inter_pu_prediction_av1(
+             md_context_ptr->cu_ptr,
+             candidate_buffer_ptr->candidate_ptr->ref_frame_type,
+             &mv_unit,
++#if ICOPY
++            candidate_buffer_ptr->candidate_ptr->use_intrabc,
++#endif
+             md_context_ptr->cu_origin_x,
+             md_context_ptr->cu_origin_y,
+             md_context_ptr->blk_geom->bwidth,
+diff --git a/Source/Lib/Codec/EbInterPrediction.h b/Source/Lib/Codec/EbInterPrediction.h
+index 8f83714..14809fc 100644
+--- a/Source/Lib/Codec/EbInterPrediction.h
++++ b/Source/Lib/Codec/EbInterPrediction.h
+@@ -49,6 +49,9 @@ extern "C" {
+         CodingUnit_t                           *cu_ptr,
+         uint8_t                                 ref_frame_type,
+         MvUnit_t                               *mv_unit,
++#if ICOPY
++        uint8_t                                  use_intrabc,
++#endif
+         uint16_t                                pu_origin_x,
+         uint16_t                                pu_origin_y,
+         uint8_t                                 bwidth,
+diff --git a/Source/Lib/Codec/EbIntraPrediction.c b/Source/Lib/Codec/EbIntraPrediction.c
+index 59eae67..ae67c9b 100644
+--- a/Source/Lib/Codec/EbIntraPrediction.c
++++ b/Source/Lib/Codec/EbIntraPrediction.c
+@@ -29,6 +29,10 @@
+ void *aom_memset16(void *dest, int32_t val, size_t length);
+ #endif
+ 
++#if ICOPY
++int32_t is_inter_block(const MbModeInfo *mbmi);
++#endif
++
+ // Some basic checks on weights for smooth predictor.
+ #define sm_weights_sanity_checks(weights_w, weights_h, weights_scale, \
+                                  pred_scale)                          \
+@@ -162,7 +166,48 @@ EbErrorType IntraReference16bitSamplesCtor(
+ }
+ 
+ 
++#if ICOPY
++static int is_smooth(const MbModeInfo *mbmi, int plane) {
++    if (plane == 0) {
++        const PredictionMode mode = mbmi->mode;
++        return (mode == SMOOTH_PRED || mode == SMOOTH_V_PRED ||
++            mode == SMOOTH_H_PRED);
++    }
++    else {
++        // uv_mode is not set for inter blocks, so need to explicitly
++        // detect that case.
++        if (is_inter_block(mbmi)) return 0;
++
++        const UV_PredictionMode uv_mode = mbmi->uv_mode;
++        return (uv_mode == UV_SMOOTH_PRED || uv_mode == UV_SMOOTH_V_PRED ||
++            uv_mode == UV_SMOOTH_H_PRED);
++    }
++}
++
++static int get_filt_type(const MacroBlockD *xd, int plane) {
++    int ab_sm, le_sm;
++
++    if (plane == 0) {
++        const MbModeInfo *ab = xd->above_mbmi;
++        const MbModeInfo *le = xd->left_mbmi;
++        ab_sm = ab ? is_smooth(ab, plane) : 0;
++        le_sm = le ? is_smooth(le, plane) : 0;
++    }
++    else {
++        const MbModeInfo *ab = xd->chroma_above_mbmi;
++        const MbModeInfo *le = xd->chroma_left_mbmi;
++        ab_sm = ab ? is_smooth(ab, plane) : 0;
++        le_sm = le ? is_smooth(le, plane) : 0;
++    }
++
++    return (ab_sm || le_sm) ? 1 : 0;
++}
++#else
+ static int32_t is_smooth(PredictionMode modeIn, int32_t plane) {
++#if ICOPY
++    printf("add_intra_bc_support\n");
++#endif
++
+     if (plane == 0) {
+         const PredictionMode mode = modeIn;//mbmi->mode;
+         return (mode == SMOOTH_PRED || mode == SMOOTH_V_PRED ||
+@@ -197,6 +242,7 @@ static int32_t get_filt_type(PredictionMode left, PredictionMode top, int32_t pl
+ 
+     return (ab_sm || le_sm) ? 1 : 0;
+ }
++#endif
+ 
+ 
+ static int32_t use_intra_edge_upsample(int32_t bs0, int32_t bs1, int32_t delta, int32_t type) {
+@@ -8332,10 +8378,13 @@ static void build_intra_predictors_md(
+ 
+             EbBool    neighborAvailableTop = (n_top_px == 0) ? EB_FALSE : // picture boundary check
+                 EB_TRUE;
+-
++#if ICOPY
++            const int32_t filt_type = get_filt_type(xd, plane);
++#else
+             const int32_t filt_type = get_filt_type(neighborAvailableLeft ? (PredictionMode)intraLeftMode : D135_PRED,
+                 neighborAvailableTop ? (PredictionMode)intraTopMode : D135_PRED,
+                 0);
++#endif
+ 
+             if (p_angle != 90 && p_angle != 180) {
+                 const int32_t ab_le = need_above_left ? 1 : 0;
+@@ -8936,9 +8985,13 @@ static void build_intra_predictors(
+             EbBool    neighborAvailableTop = (n_top_px == 0) ? EB_FALSE : // picture boundary check
+                 EB_TRUE;
+ 
++#if ICOPY
++            const int32_t filt_type = get_filt_type(xd, plane);
++#else
+             const int32_t filt_type = get_filt_type(neighborAvailableLeft ? (PredictionMode)intraLeftMode : D135_PRED,
+                 neighborAvailableTop ? (PredictionMode)intraTopMode : D135_PRED,
+                 0);
++#endif
+ 
+             if (p_angle != 90 && p_angle != 180) {
+                 const int32_t ab_le = need_above_left ? 1 : 0;
+@@ -9173,9 +9226,13 @@ static void build_intra_predictors_high(
+                 EB_TRUE;
+ 
+             //const int32_t filt_type = get_filt_type(xd, plane);
++#if ICOPY
++            const int32_t filt_type = get_filt_type(xd, plane);
++#else
+             const int32_t filt_type = get_filt_type(neighborAvailableLeft ? (PredictionMode)intraLeftMode : D135_PRED,
+                 neighborAvailableTop ? (PredictionMode)intraTopMode : D135_PRED,
+                 0);
++#endif
+             if (p_angle != 90 && p_angle != 180) {
+                 const int32_t ab_le = need_above_left ? 1 : 0;
+                 if (need_above && need_left && (txwpx + txhpx >= 24)) {
+@@ -9577,6 +9634,54 @@ extern void av1_predict_intra_block(
+         chroma_up_available = (mirow - 1) > 0;//tile->mi_row_start;
+ #endif
+ 
++#if ICOPY
++   
++    int mi_stride = cm->mi_stride;
++    const int32_t offset = mirow * mi_stride + micol;
++    xd->mi = cm->pcs_ptr->mi_grid_base + offset;
++    ModeInfo *miPtr = *xd->mi;
++
++    if (xd->up_available) {
++       // xd->above_mbmi = xd->mi[-xd->mi_stride].mbmi;
++        xd->above_mbmi = &miPtr[-mi_stride].mbmi;
++    }
++    else {
++        xd->above_mbmi = NULL;
++    }
++
++    if (xd->left_available) {
++        //xd->left_mbmi = xd->mi[-1].mbmi;
++        xd->left_mbmi = &miPtr[-1].mbmi;
++    }
++    else {
++        xd->left_mbmi = NULL;
++    }
++
++
++    const int chroma_ref = ((mirow & 0x01) || !(bh & 0x01) || !ss_y) &&
++        ((micol & 0x01) || !(bw & 0x01) || !ss_x);
++    if (chroma_ref) {
++        // To help calculate the "above" and "left" chroma blocks, note that the
++        // current block may cover multiple luma blocks (eg, if partitioned into
++        // 4x4 luma blocks).
++        // First, find the top-left-most luma block covered by this chroma block   
++
++        ModeInfo *miPtr = xd->mi[-(mirow & ss_y) * mi_stride - (micol & ss_x)];
++
++        // Then, we consider the luma region covered by the left or above 4x4 chroma
++        // prediction. We want to point to the chroma reference block in that
++        // region, which is the bottom-right-most mi unit.
++        // This leads to the following offsets:
++        MbModeInfo *chroma_above_mi =
++            chroma_up_available ? &miPtr[-mi_stride + ss_x].mbmi : NULL;
++        xd->chroma_above_mbmi = chroma_above_mi;
++
++        MbModeInfo *chroma_left_mi =
++            chroma_left_available ? &miPtr[ss_y * mi_stride - 1].mbmi : NULL;
++        xd->chroma_left_mbmi = chroma_left_mi;
++    }
++
++#endif
+ 
+     //CHKN  const MbModeInfo *const mbmi = xd->mi[0];
+     const int32_t txwpx = tx_size_wide[tx_size];
+diff --git a/Source/Lib/Codec/EbMdRateEstimation.c b/Source/Lib/Codec/EbMdRateEstimation.c
+index 4e52d10..1926aa1 100644
+--- a/Source/Lib/Codec/EbMdRateEstimation.c
++++ b/Source/Lib/Codec/EbMdRateEstimation.c
+@@ -352,6 +352,9 @@ void av1_build_nmv_cost_table(int32_t *mvjoint, int32_t *mvcost[2],
+ * based on the frame CDF
+ ***************************************************************************/
+ void av1_estimate_mv_rate(
++#if ICOPY
++    PictureControlSet_t     *picture_control_set_ptr,
++#endif
+     MdRateEstimationContext_t  *md_rate_estimation_array,
+     nmv_context                *nmv_ctx)
+ {
+@@ -374,7 +377,14 @@ void av1_estimate_mv_rate(
+     md_rate_estimation_array->nmvcoststack[0] = &md_rate_estimation_array->nmv_costs[0][MV_MAX];
+     md_rate_estimation_array->nmvcoststack[1] = &md_rate_estimation_array->nmv_costs[1][MV_MAX];
+ 
++#if ICOPY 
++    if (picture_control_set_ptr->parent_pcs_ptr->allow_intrabc) {
++        int32_t *dvcost[2] = { &md_rate_estimation_array->dv_cost[0][MV_MAX], &md_rate_estimation_array->dv_cost[1][MV_MAX] };
++        av1_build_nmv_cost_table(md_rate_estimation_array->dv_joint_cost, dvcost, &picture_control_set_ptr->coeff_est_entropy_coder_ptr->fc->ndvc,
++            MV_SUBPEL_NONE);
++    }
+ 
++#else
+     // NM: To be added when adding the screen_content_tools
+ 
+     /*if (frame_is_intra_only(cm) && cm->allow_screen_content_tools &&
+@@ -383,6 +393,7 @@ void av1_estimate_mv_rate(
+         av1_build_nmv_cost_table(cpi->dv_joint_cost, dvcost, &cm->fc->ndvc,
+             MV_SUBPEL_NONE);
+     }*/
++#endif
+ }
+ /**************************************************************************
+ * av1_estimate_coefficients_rate()
+diff --git a/Source/Lib/Codec/EbMdRateEstimation.h b/Source/Lib/Codec/EbMdRateEstimation.h
+index bc58b0a..f6e1567 100644
+--- a/Source/Lib/Codec/EbMdRateEstimation.h
++++ b/Source/Lib/Codec/EbMdRateEstimation.h
+@@ -8,12 +8,19 @@
+ 
+ #include "EbDefinitions.h"
+ #include "EbCabacContextModel.h"
++#if ICOPY
++#include "EbPictureControlSet.h"
++#endif
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+     /**************************************
+      * MD Rate Estimation Defines
+      **************************************/
++#if ICOPY
++#define MV_COST_WEIGHT_SUB 120
++#endif
++
+ #define TOTAL_NUMBER_OF_MD_RATE_ESTIMATION_CASE_BUFFERS (TOTAL_NUMBER_OF_QP_VALUES * TOTAL_NUMBER_OF_SLICE_TYPES)
+ #define NUMBER_OF_SPLIT_FLAG_CASES                            6       // number of cases for bit estimation for split flag
+ #define NUMBER_OF_MVD_CASES                                  12       // number of cases for bit estimation for motion vector difference
+@@ -63,6 +70,10 @@ extern "C" {
+         int32_t nmv_costs[2][MV_VALS];
+         int32_t nmv_costs_hp[2][MV_VALS];
+         int32_t *nmvcoststack[2];
++#if ICOPY
++        int dv_cost[2][MV_VALS];
++        int dv_joint_cost[MV_JOINTS];
++#endif
+ 
+         // Compouned Mode
+         int32_t interCompoundModeFacBits[INTER_MODE_CONTEXTS][CDF_SIZE(INTER_COMPOUND_MODES)];
+@@ -315,6 +326,9 @@ extern "C" {
+     * based on the frame CDF
+     ***************************************************************************/
+     extern void av1_estimate_mv_rate(
++#if ICOPY
++        struct PictureControlSet_s     *picture_control_set_ptr,
++#endif
+         MdRateEstimationContext_t  *md_rate_estimation_array,
+         nmv_context                *nmv_ctx);
+ 
+diff --git a/Source/Lib/Codec/EbModeDecision.c b/Source/Lib/Codec/EbModeDecision.c
+index 4fb1161..b8362f4 100644
+--- a/Source/Lib/Codec/EbModeDecision.c
++++ b/Source/Lib/Codec/EbModeDecision.c
+@@ -29,6 +29,11 @@
+ #include "EbModeDecisionProcess.h"
+ #include "EbMotionEstimation.h"
+ 
++#if ICOPY
++#include "av1me.h"
++#include "hash.h"
++#endif
++
+ /********************************************
+ * Constants
+ ********************************************/
+@@ -677,6 +682,9 @@ void Unipred3x3CandidatesInjection(
+ #endif
+ #else
+             candidateArray[canTotalCnt].distortion_ready = 0;
++#endif
++#if ICOPY
++            candidateArray[canTotalCnt].use_intrabc = 0;
+ #endif
+             candidateArray[canTotalCnt].merge_flag = EB_FALSE;
+ #if !INTRA_INTER_FAST_LOOP
+@@ -759,6 +767,9 @@ void Unipred3x3CandidatesInjection(
+ #endif
+ #else
+                 candidateArray[canTotalCnt].distortion_ready = 0;
++#endif
++#if ICOPY
++                candidateArray[canTotalCnt].use_intrabc = 0;
+ #endif
+                 candidateArray[canTotalCnt].merge_flag = EB_FALSE;
+ #if !INTRA_INTER_FAST_LOOP
+@@ -871,6 +882,9 @@ void Bipred3x3CandidatesInjection(
+ #endif
+ #else
+             candidateArray[canTotalCnt].distortion_ready = 0;
++#endif
++#if ICOPY
++            candidateArray[canTotalCnt].use_intrabc = 0;
+ #endif
+             candidateArray[canTotalCnt].merge_flag = EB_FALSE;
+ #if !INTRA_INTER_FAST_LOOP
+@@ -961,6 +975,9 @@ void Bipred3x3CandidatesInjection(
+ #endif
+ #else
+             candidateArray[canTotalCnt].distortion_ready = 0;
++#endif
++#if ICOPY
++            candidateArray[canTotalCnt].use_intrabc = 0;
+ #endif
+             candidateArray[canTotalCnt].merge_flag = EB_FALSE;
+ #if !INTRA_INTER_FAST_LOOP
+@@ -1115,6 +1132,9 @@ void InjectAv1MvpCandidates(
+ #endif
+ #else
+     candidateArray[canIdx].distortion_ready = 0;
++#endif
++#if ICOPY
++    candidateArray[canIdx].use_intrabc = 0;
+ #endif
+     candidateArray[canIdx].merge_flag = EB_FALSE;
+ #if !INTRA_INTER_FAST_LOOP
+@@ -1180,6 +1200,9 @@ void InjectAv1MvpCandidates(
+ #endif
+ #else
+         candidateArray[canIdx].distortion_ready = 0;
++#endif
++#if ICOPY
++        candidateArray[canIdx].use_intrabc = 0;
+ #endif
+         candidateArray[canIdx].merge_flag = EB_FALSE;
+ #if !INTRA_INTER_FAST_LOOP
+@@ -1234,6 +1257,9 @@ void InjectAv1MvpCandidates(
+ #endif
+ #else
+         candidateArray[canIdx].distortion_ready = 0;
++#endif
++#if ICOPY
++        candidateArray[canIdx].use_intrabc = 0;
+ #endif
+         candidateArray[canIdx].merge_flag = EB_FALSE;
+ #if !INTRA_INTER_FAST_LOOP
+@@ -1298,6 +1324,9 @@ void InjectAv1MvpCandidates(
+ #endif
+ #else
+             candidateArray[canIdx].distortion_ready = 0;
++#endif
++#if ICOPY
++            candidateArray[canIdx].use_intrabc = 0;
+ #endif
+             candidateArray[canIdx].merge_flag = EB_FALSE;
+ #if !INTRA_INTER_FAST_LOOP
+@@ -1356,6 +1385,9 @@ void InjectAv1MvpCandidates(
+ #endif
+ #else
+                 candidateArray[canIdx].distortion_ready = 0;
++#endif
++#if ICOPY
++                candidateArray[canIdx].use_intrabc = 0;
+ #endif
+                 candidateArray[canIdx].merge_flag = EB_TRUE;
+ #if !INTRA_INTER_FAST_LOOP
+@@ -1431,6 +1463,9 @@ void InjectAv1MvpCandidates(
+ #endif
+ #else
+                 candidateArray[canIdx].distortion_ready = 0;
++#endif
++#if ICOPY
++                candidateArray[canIdx].use_intrabc = 0;
+ #endif
+                 candidateArray[canIdx].merge_flag = EB_FALSE;
+ #if !INTRA_INTER_FAST_LOOP
+@@ -1511,6 +1546,9 @@ void inject_warped_motion_candidates(
+ #endif
+ #else
+         candidateArray[canIdx].distortion_ready = 0;
++#endif
++#if ICOPY
++        candidateArray[canIdx].use_intrabc = 0;
+ #endif
+         candidateArray[canIdx].merge_flag = EB_FALSE;
+ #if !INTRA_INTER_FAST_LOOP
+@@ -1591,6 +1629,9 @@ void inject_warped_motion_candidates(
+ #endif
+ #else
+             candidateArray[canIdx].distortion_ready = 0;
++#endif
++#if ICOPY
++            candidateArray[canIdx].use_intrabc = 0;
+ #endif
+             candidateArray[canIdx].merge_flag = EB_FALSE;
+ #if !INTRA_INTER_FAST_LOOP
+@@ -1663,6 +1704,9 @@ void inject_warped_motion_candidates(
+ #endif
+ #else
+         candidateArray[canIdx].distortion_ready = 0;
++#endif
++#if ICOPY
++        candidateArray[canIdx].use_intrabc = 0;
+ #endif
+         candidateArray[canIdx].merge_flag = EB_FALSE;
+ #if !INTRA_INTER_FAST_LOOP
+@@ -1901,6 +1945,9 @@ void  inject_inter_candidates(
+ #endif
+ #else
+         candidateArray[canTotalCnt].distortion_ready = 0;
++#endif
++#if ICOPY
++        candidateArray[canTotalCnt].use_intrabc = 0;
+ #endif
+         candidateArray[canTotalCnt].merge_flag = EB_FALSE;
+ #if !INTRA_INTER_FAST_LOOP
+@@ -1978,6 +2025,9 @@ void  inject_inter_candidates(
+ #endif
+ #else
+             candidateArray[canTotalCnt].distortion_ready = 0;
++#endif
++#if ICOPY
++            candidateArray[canTotalCnt].use_intrabc = 0;
+ #endif
+             candidateArray[canTotalCnt].merge_flag = EB_FALSE;
+ #if !INTRA_INTER_FAST_LOOP
+@@ -2058,6 +2108,9 @@ void  inject_inter_candidates(
+ #endif
+ #else
+                 candidateArray[canTotalCnt].distortion_ready = 0;
++#endif
++#if ICOPY
++                candidateArray[canTotalCnt].use_intrabc = 0;
+ #endif
+                 candidateArray[canTotalCnt].merge_flag = EB_FALSE;
+ #if !INTRA_INTER_FAST_LOOP
+@@ -2146,6 +2199,9 @@ void  inject_inter_candidates(
+ #endif
+ #else
+             candidateArray[canTotalCnt].distortion_ready = 0;
++#endif
++#if ICOPY
++            candidateArray[canTotalCnt].use_intrabc = 0;
+ #endif
+             candidateArray[canTotalCnt].merge_flag = EB_FALSE;
+ #if !INTRA_INTER_FAST_LOOP
+@@ -2228,6 +2284,9 @@ void  inject_inter_candidates(
+ #endif
+ #else
+         candidateArray[canTotalCnt].distortion_ready = 0;
++#endif
++#if ICOPY
++        candidateArray[canTotalCnt].use_intrabc = 0;
+ #endif
+         candidateArray[canTotalCnt].merge_flag = EB_FALSE;
+ #if !INTRA_INTER_FAST_LOOP
+@@ -2292,6 +2351,9 @@ void  inject_inter_candidates(
+ #endif
+ #else
+         candidateArray[canTotalCnt].distortion_ready = 0;
++#endif
++#if ICOPY
++        candidateArray[canTotalCnt].use_intrabc = 0;
+ #endif
+         candidateArray[canTotalCnt].merge_flag = EB_FALSE;
+ #if !INTRA_INTER_FAST_LOOP
+@@ -2665,6 +2727,328 @@ void  inject_intra_candidates_ois(
+     return;
+ }
+ 
++#endif
++
++#if ICOPY
++double av1_convert_qindex_to_q(int32_t qindex, aom_bit_depth_t bit_depth);
++
++static INLINE void setup_pred_plane(struct buf_2d *dst, block_size bsize,
++    uint8_t *src, int width, int height,
++    int stride, int mi_row, int mi_col,
++    int subsampling_x, int subsampling_y) {
++    // Offset the buffer pointer
++    if (subsampling_y && (mi_row & 0x01) && (mi_size_high[bsize] == 1))
++        mi_row -= 1;
++    if (subsampling_x && (mi_col & 0x01) && (mi_size_wide[bsize] == 1))
++        mi_col -= 1;
++
++    const int x = (MI_SIZE * mi_col) >> subsampling_x;
++    const int y = (MI_SIZE * mi_row) >> subsampling_y;
++    dst->buf = src + (y * stride + x);// scaled_buffer_offset(x, y, stride, scale);
++    dst->buf0 = src;
++    dst->width = width;
++    dst->height = height;
++    dst->stride = stride;
++}
++void av1_setup_pred_block(block_size sb_type,
++    struct buf_2d dst[MAX_MB_PLANE],
++    const Yv12BufferConfig *src, int mi_row, int mi_col) {
++    int i;
++
++    dst[0].buf = src->y_buffer;
++    dst[0].stride = src->y_stride;
++    dst[1].buf = src->u_buffer;
++    dst[2].buf = src->v_buffer;
++    dst[1].stride = dst[2].stride = src->uv_stride;
++
++    i = 0;
++    setup_pred_plane(dst + i, sb_type, dst[i].buf,
++        i ? src->uv_crop_width : src->y_crop_width,
++        i ? src->uv_crop_height : src->y_crop_height,
++        dst[i].stride, mi_row, mi_col,
++        0, 0);
++
++}
++// Values are now correlated to quantizer.
++static int sad_per_bit16lut_8[QINDEX_RANGE];
++static int sad_per_bit4lut_8[QINDEX_RANGE];
++
++static void init_me_luts_bd(int *bit16lut, int *bit4lut, int range,
++    aom_bit_depth_t bit_depth) {
++    int i;
++    // Initialize the sad lut tables using a formulaic calculation for now.
++    // This is to make it easier to resolve the impact of experimental changes
++    // to the quantizer tables.
++    for (i = 0; i < range; i++) {
++        const double q = av1_convert_qindex_to_q(i, bit_depth);
++        bit16lut[i] = (int)(0.0418 * q + 2.4107);
++        bit4lut[i] = (int)(0.063 * q + 2.742);
++    }
++}
++
++void av1_init_me_luts(void) {
++    init_me_luts_bd(sad_per_bit16lut_8, sad_per_bit4lut_8, QINDEX_RANGE,
++        AOM_BITS_8);
++}
++
++static INLINE int mv_check_bounds(const MvLimits *mv_limits, const MV *mv) {
++    return (mv->row >> 3) < mv_limits->row_min ||
++        (mv->row >> 3) > mv_limits->row_max ||
++        (mv->col >> 3) < mv_limits->col_min ||
++        (mv->col >> 3) > mv_limits->col_max;
++}
++void assert_release(int statement)
++{
++    if (statement == 0)
++        printf("ASSERT_ERRRR\n");
++}
++
++void  intra_bc_search(
++    PictureControlSet_t            *pcs,
++    ModeDecisionContext_t          *context_ptr,
++    const SequenceControlSet_t     *scs,
++    LargestCodingUnit_t            *sb_ptr,
++    CodingUnit_t                   *cu_ptr,
++    MV                             *dv_cand,
++    uint8_t                        *num_dv_cand)
++{
++
++    IntraBcContext  x_st;
++    IntraBcContext  *x = &x_st;
++    //fill x with what needed.
++    x->xd = cu_ptr->av1xd;
++    x->nmv_vec_cost = context_ptr->md_rate_estimation_ptr->nmv_vec_cost;
++    x->mv_cost_stack = context_ptr->md_rate_estimation_ptr->nmvcoststack;
++    block_size bsize = context_ptr->blk_geom->bsize;
++    const Av1Common *const cm = pcs->parent_pcs_ptr->av1_cm;
++    MvReferenceFrame ref_frame = INTRA_FRAME;
++    generate_av1_mvp_table(
++#if TILES
++        &sb_ptr->tile_info,
++#endif
++        context_ptr,
++        context_ptr->cu_ptr,
++        context_ptr->blk_geom,
++        context_ptr->cu_origin_x,
++        context_ptr->cu_origin_y,
++        &ref_frame,
++        1,
++        pcs);
++
++    const int num_planes = 3;
++    MacroBlockD * xd = cu_ptr->av1xd;
++    const TileInfo *tile = &xd->tile;
++    const int mi_row = -xd->mb_to_top_edge / (8 * MI_SIZE);
++    const int mi_col = -xd->mb_to_left_edge / (8 * MI_SIZE);
++    const int w = block_size_wide[bsize];
++    const int h = block_size_high[bsize];
++    const int sb_row = mi_row >> scs->mib_size_log2;
++    const int sb_col = mi_col >> scs->mib_size_log2;
++
++    // Set up limit values for MV components.
++    // Mv beyond the range do not produce new/different prediction block.
++    const int mi_width = mi_size_wide[bsize];
++    const int mi_height = mi_size_high[bsize];
++    x->mv_limits.row_min =
++        -(((mi_row + mi_height) * MI_SIZE) + AOM_INTERP_EXTEND);
++    x->mv_limits.col_min = -(((mi_col + mi_width) * MI_SIZE) + AOM_INTERP_EXTEND);
++    x->mv_limits.row_max = (cm->mi_rows - mi_row) * MI_SIZE + AOM_INTERP_EXTEND;
++    x->mv_limits.col_max = (cm->mi_cols - mi_col) * MI_SIZE + AOM_INTERP_EXTEND;
++    //set search paramters
++    x->sadperbit16 = sad_per_bit16lut_8[pcs->parent_pcs_ptr->base_qindex];
++    x->errorperbit = context_ptr->full_lambda >> RD_EPB_SHIFT;
++    x->errorperbit += (x->errorperbit == 0);
++    //temp buffer for hash me
++    for (int xi = 0; xi < 2; xi++)
++        for (int yj = 0; yj < 2; yj++)
++            x->hash_value_buffer[xi][yj] = (uint32_t*)malloc(AOM_BUFFER_SIZE_FOR_BLOCK_HASH * sizeof(uint32_t));
++
++    IntMv nearestmv, nearmv;
++    av1_find_best_ref_mvs_from_stack(0, context_ptr->md_local_cu_unit[context_ptr->blk_geom->blkidx_mds].ed_ref_mv_stack /*mbmi_ext*/, xd, ref_frame, &nearestmv, &nearmv,
++        0);
++    if (nearestmv.as_int == INVALID_MV) {
++        nearestmv.as_int = 0;
++    }
++    if (nearmv.as_int == INVALID_MV) {
++        nearmv.as_int = 0;
++    }
++    IntMv dv_ref = nearestmv.as_int == 0 ? nearmv : nearestmv;
++    if (dv_ref.as_int == 0)
++        av1_find_ref_dv(&dv_ref, tile, scs->mib_size, mi_row, mi_col);
++    // Ref DV should not have sub-pel.
++    assert((dv_ref.as_mv.col & 7) == 0);
++    assert((dv_ref.as_mv.row & 7) == 0);
++    context_ptr->md_local_cu_unit[context_ptr->blk_geom->blkidx_mds].ed_ref_mv_stack[INTRA_FRAME][0].this_mv = dv_ref;
++
++    /* pointer to current frame */
++    Yv12BufferConfig cur_buf;
++    LinkEbToAomBufferDesc(
++        pcs->parent_pcs_ptr->enhanced_picture_ptr,
++        &cur_buf);
++    struct buf_2d yv12_mb[MAX_MB_PLANE];
++    av1_setup_pred_block(bsize, yv12_mb, &cur_buf, mi_row, mi_col);
++    for (int i = 0; i < num_planes; ++i) {
++        x->xdplane[i].pre[0] = yv12_mb[i];  //ref in ME
++    }
++    //setup src for DV search same as ref
++    x->plane[0].src = x->xdplane[0].pre[0];
++
++
++    enum IntrabcMotionDirection {
++        IBC_MOTION_ABOVE,
++        IBC_MOTION_LEFT,
++        IBC_MOTION_DIRECTIONS
++    };
++
++    //up to two dv candidates will be generated 
++    for (enum IntrabcMotionDirection dir = IBC_MOTION_ABOVE;
++        dir < IBC_MOTION_DIRECTIONS; ++dir) {
++
++        const MvLimits tmp_mv_limits = x->mv_limits;
++
++        switch (dir) {
++        case IBC_MOTION_ABOVE:
++            x->mv_limits.col_min = (tile->mi_col_start - mi_col) * MI_SIZE;
++            x->mv_limits.col_max = (tile->mi_col_end - mi_col) * MI_SIZE - w;
++            x->mv_limits.row_min = (tile->mi_row_start - mi_row) * MI_SIZE;
++            x->mv_limits.row_max =
++                (sb_row * scs->mib_size - mi_row) * MI_SIZE - h;
++            break;
++        case IBC_MOTION_LEFT:
++            x->mv_limits.col_min = (tile->mi_col_start - mi_col) * MI_SIZE;
++            x->mv_limits.col_max =
++                (sb_col * scs->mib_size - mi_col) * MI_SIZE - w;
++            // TODO: Minimize the overlap between above and
++            // left areas.
++            x->mv_limits.row_min = (tile->mi_row_start - mi_row) * MI_SIZE;
++            int bottom_coded_mi_edge =
++                AOMMIN((sb_row + 1) * scs->mib_size, tile->mi_row_end);
++            x->mv_limits.row_max = (bottom_coded_mi_edge - mi_row) * MI_SIZE - h;
++            break;
++        default: assert(0);
++        }
++        assert_release(x->mv_limits.col_min >= tmp_mv_limits.col_min);
++        assert_release(x->mv_limits.col_max <= tmp_mv_limits.col_max);
++        assert_release(x->mv_limits.row_min >= tmp_mv_limits.row_min);
++        assert_release(x->mv_limits.row_max <= tmp_mv_limits.row_max);
++
++        av1_set_mv_search_range(&x->mv_limits, &dv_ref.as_mv);
++
++        if (x->mv_limits.col_max < x->mv_limits.col_min ||
++            x->mv_limits.row_max < x->mv_limits.row_min) {
++            x->mv_limits = tmp_mv_limits;
++            continue;
++        }
++
++        int step_param = 0;
++        MV mvp_full = dv_ref.as_mv;
++        mvp_full.col >>= 3;
++        mvp_full.row >>= 3;
++        const int sadpb = x->sadperbit16;
++        x->best_mv.as_int = 0;
++
++#define INT_VAR_MAX  2147483647    // maximum (signed) int value
++
++        const int bestsme = av1_full_pixel_search(
++            pcs, x, bsize, &mvp_full, step_param, 1, 0,
++            sadpb, NULL, &dv_ref.as_mv, INT_VAR_MAX, 1,
++            (MI_SIZE * mi_col), (MI_SIZE * mi_row), 1);
++
++        x->mv_limits = tmp_mv_limits;
++        if (bestsme == INT_VAR_MAX) continue;
++        mvp_full = x->best_mv.as_mv;
++
++        const MV dv = { .row = mvp_full.row * 8,.col = mvp_full.col * 8 };
++        if (mv_check_bounds(&x->mv_limits, &dv)) continue;
++        if (!av1_is_dv_valid(dv, xd, mi_row, mi_col, bsize,
++            scs->mib_size_log2))
++            continue;
++
++        // DV should not have sub-pel.
++        assert_release((dv.col & 7) == 0);
++        assert_release((dv.row & 7) == 0);
++
++        //store output
++        dv_cand[*num_dv_cand] = dv;
++        (*num_dv_cand)++;
++
++    }
++
++    for (int i = 0; i < 2; i++)
++        for (int j = 0; j < 2; j++)
++            free(x->hash_value_buffer[i][j]);
++
++}
++
++void  inject_intra_bc_candidates(
++    PictureControlSet_t            *picture_control_set_ptr,
++    ModeDecisionContext_t          *context_ptr,
++    const SequenceControlSet_t     *sequence_control_set_ptr,
++    LargestCodingUnit_t            *sb_ptr,
++    CodingUnit_t                   *cu_ptr,
++    uint32_t                       *cand_cnt)
++{
++    MV dv_cand[2];
++    uint8_t num_dv_cand = 0;
++
++    //perform dv-pred + search up to 2 dv(s)
++    intra_bc_search(
++        picture_control_set_ptr,
++        context_ptr,
++        sequence_control_set_ptr,
++        sb_ptr,
++        cu_ptr,
++        dv_cand,
++        &num_dv_cand);
++
++    ModeDecisionCandidate_t    *candidateArray = context_ptr->fast_candidate_array;
++    uint32_t dv_i;
++
++    for (dv_i = 0; dv_i < num_dv_cand; dv_i++)
++    {
++        candidateArray[*cand_cnt].type = INTRA_MODE;
++        candidateArray[*cand_cnt].intra_luma_mode = DC_PRED;
++#if TWO_FAST_LOOP 
++        candidateArray[*cand_cnt].enable_two_fast_loops = 0;
++#else
++        candidateArray[*cand_cnt].distortion_ready = 0;
++#endif
++        candidateArray[*cand_cnt].use_intrabc = 1;
++        candidateArray[*cand_cnt].is_directional_mode_flag = 0;
++        candidateArray[*cand_cnt].use_angle_delta = 0;
++        candidateArray[*cand_cnt].angle_delta[PLANE_TYPE_Y] = 0;
++        candidateArray[*cand_cnt].intra_chroma_mode = UV_DC_PRED;
++        candidateArray[*cand_cnt].cfl_alpha_signs = 0;
++        candidateArray[*cand_cnt].cfl_alpha_idx = 0;
++        candidateArray[*cand_cnt].is_directional_chroma_mode_flag = 0;
++        candidateArray[*cand_cnt].angle_delta[PLANE_TYPE_UV] = 0;
++        candidateArray[*cand_cnt].transform_type[PLANE_TYPE_Y] = DCT_DCT;
++        candidateArray[*cand_cnt].transform_type[PLANE_TYPE_UV] = DCT_DCT;
++        candidateArray[*cand_cnt].mpm_flag = EB_FALSE;
++        candidateArray[*cand_cnt].ref_frame_type = INTRA_FRAME;
++        candidateArray[*cand_cnt].pred_mode = DC_PRED;
++        candidateArray[*cand_cnt].motion_mode = SIMPLE_TRANSLATION;
++        //inter ralated
++        candidateArray[*cand_cnt].is_compound = 0;
++        candidateArray[*cand_cnt].merge_flag = EB_FALSE;
++        candidateArray[*cand_cnt].merge_index = 0;
++        candidateArray[*cand_cnt].prediction_direction[0] = UNI_PRED_LIST_0;
++        candidateArray[*cand_cnt].is_skip_mode_flag = 0;
++        candidateArray[*cand_cnt].is_new_mv = 0;
++        candidateArray[*cand_cnt].is_zero_mv = 0;
++        candidateArray[*cand_cnt].motionVector_x_L0 = dv_cand[dv_i].col;
++        candidateArray[*cand_cnt].motionVector_y_L0 = dv_cand[dv_i].row;
++        candidateArray[*cand_cnt].motion_vector_pred_x[REF_LIST_0] = context_ptr->md_local_cu_unit[context_ptr->blk_geom->blkidx_mds].ed_ref_mv_stack[INTRA_FRAME][0].this_mv.as_mv.col;
++        candidateArray[*cand_cnt].motion_vector_pred_y[REF_LIST_0] = context_ptr->md_local_cu_unit[context_ptr->blk_geom->blkidx_mds].ed_ref_mv_stack[INTRA_FRAME][0].this_mv.as_mv.row;
++        candidateArray[*cand_cnt].drl_index = 0;
++        candidateArray[*cand_cnt].ref_mv_index = 0;
++        candidateArray[*cand_cnt].pred_mv_weight = 0;
++        candidateArray[*cand_cnt].interp_filters = av1_broadcast_interp_filter(BILINEAR);
++        ++(*cand_cnt);
++
++    }
++
++}
+ #endif
+ // END of Function Declarations
+ void  inject_intra_candidates(
+@@ -2759,6 +3143,9 @@ void  inject_intra_candidates(
+ #endif
+ #else
+                         candidateArray[canTotalCnt].distortion_ready = 0;
++#endif
++#if ICOPY
++                        candidateArray[canTotalCnt].use_intrabc = 0;
+ #endif
+                         candidateArray[canTotalCnt].is_directional_mode_flag = (uint8_t)av1_is_directional_mode((PredictionMode)openLoopIntraCandidate);
+                         candidateArray[canTotalCnt].use_angle_delta = use_angle_delta ? candidateArray[canTotalCnt].is_directional_mode_flag : 0;
+@@ -2819,6 +3206,9 @@ void  inject_intra_candidates(
+ #endif
+ #else
+             candidateArray[canTotalCnt].distortion_ready = 0;
++#endif
++#if ICOPY
++            candidateArray[canTotalCnt].use_intrabc = 0;
+ #endif
+             candidateArray[canTotalCnt].is_directional_mode_flag = (uint8_t)av1_is_directional_mode((PredictionMode)openLoopIntraCandidate);
+             candidateArray[canTotalCnt].use_angle_delta = candidateArray[canTotalCnt].is_directional_mode_flag;
+@@ -2980,6 +3370,18 @@ EbErrorType ProductGenerateMdCandidatesCu(
+     context_ptr->fast_candidate_intra_count = canTotalCnt;
+ #endif
+ 
++#if ICOPY
++    if (picture_control_set_ptr->parent_pcs_ptr->allow_intrabc)
++        inject_intra_bc_candidates(
++            picture_control_set_ptr,
++            context_ptr,
++            sequence_control_set_ptr,
++            sb_ptr,
++            context_ptr->cu_ptr,
++            &canTotalCnt
++        );
++#endif
++
+     if (slice_type != I_SLICE) {
+         if (inject_inter_candidate)
+             inject_inter_candidates(
+@@ -3074,6 +3476,10 @@ uint8_t product_full_mode_decision(
+ 
+     context_ptr->md_local_cu_unit[cu_ptr->mds_idx].count_non_zero_coeffs = candidate_ptr->count_non_zero_coeffs;
+ 
++#if ICOPY    
++    cu_ptr->av1xd->use_intrabc = candidate_ptr->use_intrabc;
++#endif
++
+     // Set the PU level variables
+     cu_ptr->interp_filters = candidate_ptr->interp_filters;
+     {
+@@ -3100,7 +3506,11 @@ uint8_t product_full_mode_decision(
+         // Inter Prediction
+         pu_ptr->inter_pred_direction_index = candidate_ptr->prediction_direction[0];
+         pu_ptr->merge_flag = candidate_ptr->merge_flag;
++#if ICOPY
++        if (cu_ptr->prediction_mode_flag != INTER_MODE && cu_ptr->av1xd->use_intrabc == 0)
++#else
+         if (cu_ptr->prediction_mode_flag != INTER_MODE)
++#endif
+         {
+             pu_ptr->inter_pred_direction_index = 0x03;
+             pu_ptr->merge_flag = EB_FALSE;
+diff --git a/Source/Lib/Codec/EbModeDecision.h b/Source/Lib/Codec/EbModeDecision.h
+index f3eb63a..437ae6e 100644
+--- a/Source/Lib/Codec/EbModeDecision.h
++++ b/Source/Lib/Codec/EbModeDecision.h
+@@ -79,7 +79,7 @@ extern "C" {
+ 
+         uint8_t                                skip_flag;
+         EbBool                                 merge_flag;
+-#if !INTRA_INTER_FAST_LOOP
++#if !INTRA_INTER_FAST_LOOP || ICOPY
+         uint8_t                                merge_index; // Hsan: does not seem to be used why not removed ?
+ #endif
+         uint16_t                               count_non_zero_coeffs;
+@@ -87,7 +87,7 @@ extern "C" {
+         EbBool                                 prediction_is_ready_luma;
+ #endif
+         uint8_t                                type;
+-#if !INTRA_INTER_FAST_LOOP
++#if !INTRA_INTER_FAST_LOOP || ICOPY
+         EbBool                                 mpm_flag;
+ #endif
+         // MD Rate Estimation Ptr
+@@ -113,7 +113,9 @@ extern "C" {
+ 
+         PredictionMode                         pred_mode; // AV1 mode, no need to convert
+         uint8_t                                drl_index;
+-
++#if ICOPY
++        uint8_t                                use_intrabc;
++#endif
+         // Intra Mode
+         int32_t                                angle_delta[PLANE_TYPES];
+         EbBool                                 is_directional_mode_flag;
+@@ -132,7 +134,7 @@ extern "C" {
+         uint32_t                               pred_mv_weight;
+         uint8_t                                ref_frame_type;
+         uint8_t                                ref_mv_index;
+-#if !INTRA_INTER_FAST_LOOP
++#if !INTRA_INTER_FAST_LOOP || ICOPY
+         EbBool                                 is_skip_mode_flag;
+ #endif
+         EbBool                                 is_new_mv;
+diff --git a/Source/Lib/Codec/EbModeDecisionConfigurationProcess.c b/Source/Lib/Codec/EbModeDecisionConfigurationProcess.c
+index abb4ff3..316151f 100644
+--- a/Source/Lib/Codec/EbModeDecisionConfigurationProcess.c
++++ b/Source/Lib/Codec/EbModeDecisionConfigurationProcess.c
+@@ -26,7 +26,37 @@
+ #include "EbModeDecisionConfiguration.h"
+ #include "EbReferenceObject.h"
+ #include "EbModeDecisionProcess.h"
++#if ICOPY
++#include "av1me.h"
++
++
++#define MAX_MESH_SPEED 5  // Max speed setting for mesh motion method
++static MESH_PATTERN
++good_quality_mesh_patterns[MAX_MESH_SPEED + 1][MAX_MESH_STEP] = {
++    { { 64, 8 }, { 28, 4 }, { 15, 1 }, { 7, 1 } },
++    { { 64, 8 }, { 28, 4 }, { 15, 1 }, { 7, 1 } },
++    { { 64, 8 }, { 14, 2 }, { 7, 1 }, { 7, 1 } },
++    { { 64, 16 }, { 24, 8 }, { 12, 4 }, { 7, 1 } },
++    { { 64, 16 }, { 24, 8 }, { 12, 4 }, { 7, 1 } },
++    { { 64, 16 }, { 24, 8 }, { 12, 4 }, { 7, 1 } },
++};
++static unsigned char good_quality_max_mesh_pct[MAX_MESH_SPEED + 1] = {
++    50, 50, 25, 15, 5, 1
++};
++// TODO: These settings are pretty relaxed, tune them for
++// each speed setting
++static MESH_PATTERN intrabc_mesh_patterns[MAX_MESH_SPEED + 1][MAX_MESH_STEP] = {
++  { { 256, 1 }, { 256, 1 }, { 0, 0 }, { 0, 0 } },
++  { { 256, 1 }, { 256, 1 }, { 0, 0 }, { 0, 0 } },
++  { { 64, 1 }, { 64, 1 }, { 0, 0 }, { 0, 0 } },
++  { { 64, 1 }, { 64, 1 }, { 0, 0 }, { 0, 0 } },
++  { { 64, 4 }, { 16, 1 }, { 0, 0 }, { 0, 0 } },
++  { { 64, 4 }, { 16, 1 }, { 0, 0 }, { 0, 0 } },
++};
++static uint8_t intrabc_max_mesh_pct[MAX_MESH_SPEED + 1] = { 100, 100, 100,
++                                                            25,  25,  10 };
+ 
++#endif
+ #if ADAPTIVE_DEPTH_PARTITIONING
+ // Adaptive Depth Partitioning
+ // Shooting states
+@@ -3158,6 +3188,9 @@ void* ModeDecisionConfigurationKernel(void *input_ptr)
+ 
+         // Initial Rate Estimatimation of the Motion vectors
+         av1_estimate_mv_rate(
++#if ICOPY
++            picture_control_set_ptr,
++#endif
+             md_rate_estimation_array,
+             &picture_control_set_ptr->coeff_est_entropy_coder_ptr->fc->nmvc);
+ 
+@@ -3274,6 +3307,124 @@ void* ModeDecisionConfigurationKernel(void *input_ptr)
+             picture_control_set_ptr->parent_pcs_ptr->average_qp = (uint8_t)picture_control_set_ptr->parent_pcs_ptr->picture_qp;
+         }
+ 
++#if ICOPY
++        if (picture_control_set_ptr->parent_pcs_ptr->allow_intrabc)
++        {
++            int i;
++            int speed = 1;
++            SPEED_FEATURES *sf = &picture_control_set_ptr->sf;
++            sf->allow_exhaustive_searches = 1;
++
++            const int mesh_speed = AOMMIN(speed, MAX_MESH_SPEED);
++            //if (cpi->twopass.fr_content_type == FC_GRAPHICS_ANIMATION)
++            //    sf->exhaustive_searches_thresh = (1 << 24);
++            //else
++            sf->exhaustive_searches_thresh = (1 << 25);
++
++            sf->max_exaustive_pct = good_quality_max_mesh_pct[mesh_speed];
++            if (mesh_speed > 0)
++                sf->exhaustive_searches_thresh = sf->exhaustive_searches_thresh << 1;
++
++            for (i = 0; i < MAX_MESH_STEP; ++i) {
++                sf->mesh_patterns[i].range =
++                    good_quality_mesh_patterns[mesh_speed][i].range;
++                sf->mesh_patterns[i].interval =
++                    good_quality_mesh_patterns[mesh_speed][i].interval;
++            }
++
++            if (picture_control_set_ptr->slice_type == I_SLICE)
++            {
++                for (i = 0; i < MAX_MESH_STEP; ++i) {
++                    sf->mesh_patterns[i].range = intrabc_mesh_patterns[mesh_speed][i].range;
++                    sf->mesh_patterns[i].interval =
++                        intrabc_mesh_patterns[mesh_speed][i].interval;
++                }
++                sf->max_exaustive_pct = intrabc_max_mesh_pct[mesh_speed];
++            }
++
++            {
++                // add to hash table
++                const int pic_width = picture_control_set_ptr->parent_pcs_ptr->sequence_control_set_ptr->luma_width;
++                const int pic_height = picture_control_set_ptr->parent_pcs_ptr->sequence_control_set_ptr->luma_height;
++                uint32_t *block_hash_values[2][2];
++                int8_t *is_block_same[2][3];
++                int k, j;
++
++                for (k = 0; k < 2; k++) {
++                    for (j = 0; j < 2; j++) {
++                        block_hash_values[k][j] = malloc(sizeof(uint32_t) * pic_width * pic_height);
++                    }
++
++                    for (j = 0; j < 3; j++) {
++                        is_block_same[k][j] = malloc(sizeof(int8_t) * pic_width * pic_height);
++                    }
++                }
++
++                //picture_control_set_ptr->hash_table.p_lookup_table = NULL;
++                //av1_hash_table_create(&picture_control_set_ptr->hash_table);
++
++                Yv12BufferConfig cpi_source;
++                LinkEbToAomBufferDesc(
++                    picture_control_set_ptr->parent_pcs_ptr->enhanced_picture_ptr,
++                    &cpi_source);
++
++                av1_crc_calculator_init(&picture_control_set_ptr->crc_calculator1, 24, 0x5D6DCB);
++                av1_crc_calculator_init(&picture_control_set_ptr->crc_calculator2, 24, 0x864CFB);
++
++                av1_generate_block_2x2_hash_value(&cpi_source, block_hash_values[0],
++                    is_block_same[0], picture_control_set_ptr);
++                av1_generate_block_hash_value(&cpi_source, 4, block_hash_values[0],
++                    block_hash_values[1], is_block_same[0],
++                    is_block_same[1], picture_control_set_ptr);
++                av1_add_to_hash_map_by_row_with_precal_data(
++                    &picture_control_set_ptr->hash_table, block_hash_values[1], is_block_same[1][2],
++                    pic_width, pic_height, 4);
++                av1_generate_block_hash_value(&cpi_source, 8, block_hash_values[1],
++                    block_hash_values[0], is_block_same[1],
++                    is_block_same[0], picture_control_set_ptr);
++                av1_add_to_hash_map_by_row_with_precal_data(
++                    &picture_control_set_ptr->hash_table, block_hash_values[0], is_block_same[0][2],
++                    pic_width, pic_height, 8);
++                av1_generate_block_hash_value(&cpi_source, 16, block_hash_values[0],
++                    block_hash_values[1], is_block_same[0],
++                    is_block_same[1], picture_control_set_ptr);
++                av1_add_to_hash_map_by_row_with_precal_data(
++                    &picture_control_set_ptr->hash_table, block_hash_values[1], is_block_same[1][2],
++                    pic_width, pic_height, 16);
++                av1_generate_block_hash_value(&cpi_source, 32, block_hash_values[1],
++                    block_hash_values[0], is_block_same[1],
++                    is_block_same[0], picture_control_set_ptr);
++                av1_add_to_hash_map_by_row_with_precal_data(
++                    &picture_control_set_ptr->hash_table, block_hash_values[0], is_block_same[0][2],
++                    pic_width, pic_height, 32);
++                av1_generate_block_hash_value(&cpi_source, 64, block_hash_values[0],
++                    block_hash_values[1], is_block_same[0],
++                    is_block_same[1], picture_control_set_ptr);
++                av1_add_to_hash_map_by_row_with_precal_data(
++                    &picture_control_set_ptr->hash_table, block_hash_values[1], is_block_same[1][2],
++                    pic_width, pic_height, 64);
++
++                av1_generate_block_hash_value(&cpi_source, 128, block_hash_values[1],
++                    block_hash_values[0], is_block_same[1],
++                    is_block_same[0], picture_control_set_ptr);
++                av1_add_to_hash_map_by_row_with_precal_data(
++                    &picture_control_set_ptr->hash_table, block_hash_values[0], is_block_same[0][2],
++                    pic_width, pic_height, 128);
++
++                for (k = 0; k < 2; k++) {
++                    for (j = 0; j < 2; j++) {
++                        free(block_hash_values[k][j]);
++                    }
++
++                    for (j = 0; j < 3; j++) {
++                        free(is_block_same[k][j]);
++                    }
++                }
++            }
++
++            av1_init3smotion_compensation(&picture_control_set_ptr->ss_cfg, picture_control_set_ptr->parent_pcs_ptr->enhanced_picture_ptr->stride_y);
++        }
++#endif
+ 
+         // Derive MD parameters
+         SetMdSettings( // HT Done
+diff --git a/Source/Lib/Codec/EbModeDecisionProcess.h b/Source/Lib/Codec/EbModeDecisionProcess.h
+index 23deaf3..b3185d7 100644
+--- a/Source/Lib/Codec/EbModeDecisionProcess.h
++++ b/Source/Lib/Codec/EbModeDecisionProcess.h
+@@ -24,7 +24,12 @@ extern "C" {
+      * Defines
+      **************************************/
+ #if IMPROVED_BIPRED_INJECTION || IMPROVED_UNIPRED_INJECTION
++#if ICOPY
++#define IBC_CAND 2 //two intra bc candidates
++#define MODE_DECISION_CANDIDATE_MAX_COUNT               (124+IBC_CAND) /* 61 Intra & 18+2x8+2x8 Inter*/
++#else
+ #define MODE_DECISION_CANDIDATE_MAX_COUNT               124// 61 Intra & 18+2x8+2x8 Inter
++#endif
+ #else
+ #define MODE_DECISION_CANDIDATE_MAX_COUNT               90//35//20 // 61 Intra & 18 Inter
+ #endif
+diff --git a/Source/Lib/Codec/EbPictureAnalysisProcess.c b/Source/Lib/Codec/EbPictureAnalysisProcess.c
+index 836a788..180e73c 100644
+--- a/Source/Lib/Codec/EbPictureAnalysisProcess.c
++++ b/Source/Lib/Codec/EbPictureAnalysisProcess.c
+@@ -4872,7 +4872,50 @@ void DecimateInputPicture(
+         }
+     }
+ }
++#if ICOPY
++int av1_count_colors(const uint8_t *src, int stride, int rows, int cols,
++    int *val_count) {
++    const int max_pix_val = 1 << 8;
++    memset(val_count, 0, max_pix_val * sizeof(val_count[0]));
++    for (int r = 0; r < rows; ++r) {
++        for (int c = 0; c < cols; ++c) {
++            const int this_val = src[r * stride + c];
++            assert(this_val < max_pix_val);
++            ++val_count[this_val];
++        }
++    }
++    int n = 0;
++    for (int i = 0; i < max_pix_val; ++i) {
++        if (val_count[i]) ++n;
++    }
++    return n;
++}
++// Estimate if the source frame is screen content, based on the portion of
++// blocks that have no more than 4 (experimentally selected) luma colors.
++static int is_screen_content(const uint8_t *src, int use_hbd,
++    int stride, int width, int height) {
++    assert(src != NULL);
++    int counts = 0;
++    const int blk_w = 16;
++    const int blk_h = 16;
++    const int limit = 4;
++    for (int r = 0; r + blk_h <= height; r += blk_h) {
++        for (int c = 0; c + blk_w <= width; c += blk_w) {
++            int count_buf[1 << 12];  // Maximum (1 << 12) color levels.
++            const int n_colors =
++                use_hbd ? 0 /*av1_count_colors_highbd(src + r * stride + c, stride, blk_w,
++                    blk_h, bd, count_buf)*/
++                : av1_count_colors(src + r * stride + c, stride, blk_w, blk_h,
++                    count_buf);
++            if (n_colors > 1 && n_colors <= limit) counts++;
++        }
++    }
++    // The threshold is 10%.
++    return counts * blk_h * blk_w * 10 > width * height;
++}
+ 
++
++#endif
+ /************************************************
+  * Picture Analysis Kernel
+  * The Picture Analysis Process pads & decimates the input pictures.
+@@ -4933,6 +4976,14 @@ void* picture_analysis_kernel(void *input_ptr)
+         SetPictureParametersForStatisticsGathering(
+             sequence_control_set_ptr);
+ 
++#if ICOPY
++        picture_control_set_ptr->sc_content_detected = is_screen_content(
++            input_picture_ptr->buffer_y + input_picture_ptr->origin_x + input_picture_ptr->origin_y*input_picture_ptr->stride_y,
++            0,
++            input_picture_ptr->stride_y,
++            sequence_control_set_ptr->luma_width, sequence_control_set_ptr->luma_height);
++#endif
++
+         // Pad pictures to multiple min cu size
+         PadPictureToMultipleOfMinCuSizeDimensions(
+             sequence_control_set_ptr,
+diff --git a/Source/Lib/Codec/EbPictureControlSet.c b/Source/Lib/Codec/EbPictureControlSet.c
+index 017cb6e..30fbae2 100644
+--- a/Source/Lib/Codec/EbPictureControlSet.c
++++ b/Source/Lib/Codec/EbPictureControlSet.c
+@@ -28,6 +28,9 @@ void *aom_malloc(size_t size);
+ #endif
+ EbErrorType av1_alloc_restoration_buffers(Av1Common *cm);
+ 
++#if ICOPY
++EbErrorType av1_hash_table_create(hash_table *p_hash_table);
++#endif
+ 
+ static void set_restoration_unit_size(int32_t width, int32_t height, int32_t sx, int32_t sy,
+     RestorationInfo *rst) {
+@@ -893,6 +896,10 @@ EbErrorType picture_control_set_ctor(
+     }
+ 
+     object_ptr->mi_stride = pictureLcuWidth * (BLOCK_SIZE_64 / 4);
++#if ICOPY
++    object_ptr->hash_table.p_lookup_table = NULL;
++    av1_hash_table_create(&object_ptr->hash_table);
++#endif
+     return EB_ErrorNone;
+ }
+ 
+diff --git a/Source/Lib/Codec/EbPictureControlSet.h b/Source/Lib/Codec/EbPictureControlSet.h
+index 643cf95..593395d 100644
+--- a/Source/Lib/Codec/EbPictureControlSet.h
++++ b/Source/Lib/Codec/EbPictureControlSet.h
+@@ -27,6 +27,10 @@
+ #include "EbCdef.h"
+ #endif
+ 
++#if ICOPY
++#include"av1me.h"
++#include "hash_motion.h"
++#endif
+ 
+ #ifdef __cplusplus
+ extern "C" {
+@@ -13620,6 +13624,10 @@ extern "C" {
+ #if FAST_SG
+         int8_t  wn_filter_mode;
+ #endif
++
++#if ICOPY
++        struct PictureControlSet_s               *pcs_ptr;
++#endif
+     } Av1Common;
+ 
+     /**************************************
+@@ -13668,6 +13676,35 @@ extern "C" {
+      **************************************/
+     struct CodedTreeblock_s;
+     struct LargestCodingUnit_s;
++#if ICOPY
++#define MAX_MESH_STEP 4
++
++    typedef struct MESH_PATTERN {
++        int range;
++        int interval;
++    } MESH_PATTERN;
++
++    typedef struct SPEED_FEATURES {
++
++        // TODO(jingning): combine the related motion search speed features
++        // This allows us to use motion search at other sizes as a starting
++        // point for this motion search and limits the search range around it.
++        int adaptive_motion_search;
++
++        // Flag for allowing some use of exhaustive searches;
++        int allow_exhaustive_searches;
++
++        // Threshold for allowing exhaistive motion search.
++        int exhaustive_searches_thresh;
++
++        // Maximum number of exhaustive searches for a frame.
++        int max_exaustive_pct;
++
++        // Pattern to be used for any exhaustive mesh searches.
++        MESH_PATTERN mesh_patterns[MAX_MESH_STEP];
++
++    } SPEED_FEATURES;
++#endif
+ 
+     typedef struct PictureControlSet_s
+     {
+@@ -13850,6 +13887,13 @@ extern "C" {
+         int32_t                               cdef_preset[4];
+         WienerInfo                            wiener_info[MAX_MB_PLANE];
+         SgrprojInfo                           sgrproj_info[MAX_MB_PLANE];
++#if ICOPY
++        SPEED_FEATURES sf;
++        search_site_config ss_cfg;//CHKN this might be a seq based
++        hash_table hash_table;
++        CRC_CALCULATOR crc_calculator1;
++        CRC_CALCULATOR crc_calculator2;
++#endif
+ 
+     } PictureControlSet_t;
+ 
+@@ -14289,7 +14333,9 @@ extern "C" {
+ #if NSQ_OPTIMASATION
+         uint8_t                               nsq_max_shapes_md; // max number of shapes to be tested in MD
+ #endif
+-
++#if ICOPY
++        uint8_t                              sc_content_detected;
++#endif
+     } PictureParentControlSet_t;
+ 
+ 
+diff --git a/Source/Lib/Codec/EbPictureDecisionProcess.c b/Source/Lib/Codec/EbPictureDecisionProcess.c
+index 90e20b4..b3db2f3 100644
+--- a/Source/Lib/Codec/EbPictureDecisionProcess.c
++++ b/Source/Lib/Codec/EbPictureDecisionProcess.c
+@@ -766,7 +766,27 @@ EbErrorType signal_derivation_multi_processes_oq(
+     // 2                                            LIGHT FRAME-BASED
+     // 3                                            FULL FRAME-BASED
+ 
++#if ICOPY
++    //for now only I frames are allowed to use sc tools.
++    //TODO: we can force all frames in GOP with the same detection status of leading I frame.
++    if (picture_control_set_ptr->slice_type == I_SLICE) {
++        picture_control_set_ptr->allow_screen_content_tools = picture_control_set_ptr->sc_content_detected;
++        picture_control_set_ptr->allow_intrabc = picture_control_set_ptr->sc_content_detected;
++        
++        //turn OFF intra bc for some specific modes
++        if (picture_control_set_ptr->enc_mode >= ENC_M1)
++            picture_control_set_ptr->allow_intrabc = 0;
++      
++    }
++    else {
++        picture_control_set_ptr->allow_screen_content_tools = 0;
++        picture_control_set_ptr->allow_intrabc = 0;
++    }
++
++    if (!picture_control_set_ptr->sequence_control_set_ptr->static_config.disable_dlf_flag && picture_control_set_ptr->allow_intrabc == 0) {
++#else
+     if (!picture_control_set_ptr->sequence_control_set_ptr->static_config.disable_dlf_flag) {
++#endif
+         if (picture_control_set_ptr->enc_mode >= ENC_M4)
+             picture_control_set_ptr->loop_filter_mode = 1;
+         else
+@@ -783,7 +803,11 @@ EbErrorType signal_derivation_multi_processes_oq(
+     // 3                                            16 step refinement
+     SequenceControlSet_t                    *sequence_control_set_ptr;
+     sequence_control_set_ptr = (SequenceControlSet_t*)picture_control_set_ptr->sequence_control_set_wrapper_ptr->object_ptr;
++#if ICOPY 
++    if (sequence_control_set_ptr->enable_cdef && picture_control_set_ptr->allow_intrabc == 0) {
++#else
+     if (sequence_control_set_ptr->enable_cdef) {
++#endif
+         if (picture_control_set_ptr->enc_mode <= ENC_M3)
+             picture_control_set_ptr->cdef_filter_mode = 3;
+         else
+diff --git a/Source/Lib/Codec/EbPictureManagerProcess.c b/Source/Lib/Codec/EbPictureManagerProcess.c
+index 03e820f..23cb765 100644
+--- a/Source/Lib/Codec/EbPictureManagerProcess.c
++++ b/Source/Lib/Codec/EbPictureManagerProcess.c
+@@ -712,6 +712,10 @@ void* picture_manager_kernel(void *input_ptr)
+                             }
+                         }
+ 
++#if ICOPY
++                        ChildPictureControlSetPtr->parent_pcs_ptr->av1_cm->pcs_ptr = ChildPictureControlSetPtr;
++#endif
++
+ #if TILES             
+                         set_tile_info(ChildPictureControlSetPtr->parent_pcs_ptr);
+ 
+diff --git a/Source/Lib/Codec/EbRateDistortionCost.c b/Source/Lib/Codec/EbRateDistortionCost.c
+index 9cafdf7..4941f1f 100644
+--- a/Source/Lib/Codec/EbRateDistortionCost.c
++++ b/Source/Lib/Codec/EbRateDistortionCost.c
+@@ -29,7 +29,12 @@ block_size GetBlockSize(uint8_t cu_size) {
+     return (cu_size == 64 ? BLOCK_64X64 : cu_size == 32 ? BLOCK_32X32 : cu_size == 16 ? BLOCK_16X16 : cu_size == 8 ? BLOCK_8X8 : BLOCK_4X4);
+ }
+ 
++#if ICOPY
++int av1_allow_intrabc(const Av1Common *const cm);
++int32_t is_chroma_reference(int32_t mi_row, int32_t mi_col, block_size bsize,
++#else
+ static INLINE int32_t is_chroma_reference(int32_t mi_row, int32_t mi_col, block_size bsize,
++#endif
+     int32_t subsampling_x, int32_t subsampling_y) {
+     const int32_t bw = mi_size_wide[bsize];
+     const int32_t bh = mi_size_high[bsize];
+@@ -595,6 +600,54 @@ EbErrorType av1_intra_fast_cost(
+     UNUSED(miCol);
+     UNUSED(left_neighbor_mode);
+     UNUSED(top_neighbor_mode);
++
++#if ICOPY 
++   
++    if (av1_allow_intrabc(picture_control_set_ptr->parent_pcs_ptr->av1_cm) && candidate_ptr->use_intrabc) {
++
++        uint64_t lumaSad = (LUMA_WEIGHT * luma_distortion) << AV1_COST_PRECISION;
++        uint64_t chromaSad = chroma_distortion << AV1_COST_PRECISION;
++        uint64_t totalDistortion = lumaSad + chromaSad;
++
++        uint64_t rate = 0;
++
++        EbReflist refListIdx = 0;
++        int16_t predRefX = candidate_ptr->motion_vector_pred_x[refListIdx];
++        int16_t predRefY = candidate_ptr->motion_vector_pred_y[refListIdx];
++        int16_t mvRefX = candidate_ptr->motionVector_x_L0;
++        int16_t mvRefY = candidate_ptr->motionVector_y_L0;
++        MV mv;
++        mv.row = mvRefY;
++        mv.col = mvRefX;
++        MV ref_mv;
++        ref_mv.row = predRefY;
++        ref_mv.col = predRefX;
++
++        int *dvcost[2] = { (int *)&candidate_ptr->md_rate_estimation_ptr->dv_cost[0][MV_MAX],
++                           (int *)&candidate_ptr->md_rate_estimation_ptr->dv_cost[1][MV_MAX] };
++
++        int32_t mvRate = av1_mv_bit_cost(
++            &mv,
++            &ref_mv,
++            candidate_ptr->md_rate_estimation_ptr->dv_joint_cost,
++            dvcost, MV_COST_WEIGHT_SUB);
++
++        rate = mvRate + candidate_ptr->md_rate_estimation_ptr->intrabcFacBits[candidate_ptr->use_intrabc];
++
++        candidate_ptr->fast_luma_rate = rate;
++        candidate_ptr->fast_chroma_rate = 0;
++
++        lumaSad = (LUMA_WEIGHT * luma_distortion) << AV1_COST_PRECISION;
++        chromaSad = chroma_distortion << AV1_COST_PRECISION;
++        totalDistortion = lumaSad + chromaSad;
++
++       
++        return(RDCOST(lambda, rate, totalDistortion));
++
++    }
++    else {
++#endif
++
+     EbBool isMonochromeFlag = EB_FALSE; // NM - isMonochromeFlag is harcoded to false.
+ #if REST_FAST_RATE_EST
+     EbBool isCflAllowed = (blk_geom->bwidth <= 32 && blk_geom->bheight <= 32) ? 1 : 0;
+@@ -731,6 +784,10 @@ EbErrorType av1_intra_fast_cost(
+     uint32_t isInterRate = picture_control_set_ptr->slice_type != I_SLICE ? candidate_buffer_ptr->candidate_ptr->md_rate_estimation_ptr->intraInterFacBits[cu_ptr->is_inter_ctx][0] : 0;
+ #endif
+     lumaRate = intraModeBitsNum + skipModeRate + intraLumaModeBitsNum + intraLumaAngModeBitsNum + isInterRate;
++#if ICOPY
++    if (av1_allow_intrabc(picture_control_set_ptr->parent_pcs_ptr->av1_cm))
++        lumaRate += candidate_ptr->md_rate_estimation_ptr->intrabcFacBits[candidate_ptr->use_intrabc];
++#endif
+ 
+     chromaRate = intraChromaModeBitsNum + intraChromaAngModeBitsNum;
+ 
+@@ -792,6 +849,9 @@ EbErrorType av1_intra_fast_cost(
+ #if USE_SSE_FL
+     }
+ #endif
++#if ICOPY
++    }
++#endif
+ }
+ 
+ //extern INLINE int32_t have_newmv_in_inter_mode(PredictionMode mode);
+diff --git a/Source/Lib/Codec/EbResourceCoordinationProcess.c b/Source/Lib/Codec/EbResourceCoordinationProcess.c
+index 30e7d70..d322c29 100644
+--- a/Source/Lib/Codec/EbResourceCoordinationProcess.c
++++ b/Source/Lib/Codec/EbResourceCoordinationProcess.c
+@@ -300,8 +300,10 @@ void ResetPcsAv1(
+     picture_control_set_ptr->disable_cdf_update = 0;
+     picture_control_set_ptr->allow_high_precision_mv = 0;
+     picture_control_set_ptr->cur_frame_force_integer_mv = 0;  // 0 the default in AOM, 1 only integer
++#if !ICOPY
+     picture_control_set_ptr->allow_screen_content_tools = 0;
+     picture_control_set_ptr->allow_intrabc = 0;
++#endif
+     picture_control_set_ptr->allow_warped_motion = 0;
+ 
+     /* profile settings */
+diff --git a/Source/Lib/Codec/EbRestProcess.c b/Source/Lib/Codec/EbRestProcess.c
+index c384f21..9007b7c 100644
+--- a/Source/Lib/Codec/EbRestProcess.c
++++ b/Source/Lib/Codec/EbRestProcess.c
+@@ -238,7 +238,11 @@ void* rest_kernel(void *input_ptr)
+ 
+ #if  REST_M
+ 
++#if ICOPY
++        if (sequence_control_set_ptr->enable_restoration && picture_control_set_ptr->parent_pcs_ptr->allow_intrabc == 0)
++#else
+         if (sequence_control_set_ptr->enable_restoration)
++#endif
+         {
+             get_own_recon(sequence_control_set_ptr, picture_control_set_ptr, context_ptr, is16bit);
+ 
+@@ -279,9 +283,13 @@ void* rest_kernel(void *input_ptr)
+ 
+ #if REST_REF_ONLY
+             if (sequence_control_set_ptr->enable_restoration && picture_control_set_ptr->parent_pcs_ptr->is_used_as_reference_flag) {
++#else
++#if ICOPY
++            if (sequence_control_set_ptr->enable_restoration && picture_control_set_ptr->parent_pcs_ptr->allow_intrabc == 0) {
+ #else
+             if (sequence_control_set_ptr->enable_restoration) {
+ #endif
++#endif
+ 
+ #if  !REST_M
+                 av1_loop_restoration_save_boundary_lines(
+diff --git a/Source/Lib/Codec/EbSequenceControlSet.c b/Source/Lib/Codec/EbSequenceControlSet.c
+index 8f93782..8d52461 100644
+--- a/Source/Lib/Codec/EbSequenceControlSet.c
++++ b/Source/Lib/Codec/EbSequenceControlSet.c
+@@ -170,7 +170,11 @@ EbErrorType eb_sequence_control_set_ctor(
+ 
+     sequence_control_set_ptr->order_hint_bits_minus1 = sequence_control_set_ptr->enable_order_hint ? 6 : -1;
+ 
++#if ICOPY
++    sequence_control_set_ptr->force_screen_content_tools = 2;
++#else
+     sequence_control_set_ptr->force_screen_content_tools = 0;
++#endif
+     // 0 - force off
+     // 1 - force on
+     // 2 - adaptive
+diff --git a/Source/Lib/Codec/av1me.c b/Source/Lib/Codec/av1me.c
+new file mode 100644
+index 0000000..607c9bd
+--- /dev/null
++++ b/Source/Lib/Codec/av1me.c
+@@ -0,0 +1,1106 @@
++/*
++ * Copyright (c) 2016, Alliance for Open Media. All rights reserved
++ *
++ * This source code is subject to the terms of the BSD 2 Clause License and
++ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
++ * was not distributed with this source code in the LICENSE file, you can
++ * obtain it at www.aomedia.org/license/software. If the Alliance for Open
++ * Media Patent License 1.0 was not distributed with this source code in the
++ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
++ */
++
++#include <limits.h>
++#include <math.h>
++#include <stdio.h>
++#include "EbDefinitions.h"
++#if ICOPY
++#include "EbCodingUnit.h"
++#include "av1me.h"
++#include "EbPictureControlSet.h"
++#include "EbSequenceControlSet.h"
++#include "EbComputeSAD.h"
++
++
++int av1_is_dv_valid(const MV dv,
++    const MacroBlockD *xd, int mi_row, int mi_col,
++    block_size bsize, int mib_size_log2);
++
++void clamp_mv(
++    MV *mv,
++    int32_t min_col,
++    int32_t max_col,
++    int32_t min_row,
++    int32_t max_row);
++
++typedef struct dist_wtd_comp_params {
++    int use_dist_wtd_comp_avg;
++    int fwd_offset;
++    int bck_offset;
++} DIST_WTD_COMP_PARAMS;
++typedef unsigned int(*aom_sad_fn_t)(const uint8_t *a, int a_stride,
++    const uint8_t *b, int b_stride);
++
++typedef unsigned int(*aom_sad_avg_fn_t)(const uint8_t *a, int a_stride,
++    const uint8_t *b, int b_stride,
++    const uint8_t *second_pred);
++
++typedef void(*aom_copy32xn_fn_t)(const uint8_t *a, int a_stride, uint8_t *b,
++    int b_stride, int n);
++
++typedef void(*aom_sad_multi_d_fn_t)(const uint8_t *a, int a_stride,
++    const uint8_t *const b_array[],
++    int b_stride, unsigned int *sad_array);
++
++typedef unsigned int(*aom_variance_fn_t)(const uint8_t *a, int a_stride,
++    const uint8_t *b, int b_stride,
++    unsigned int *sse);
++
++typedef unsigned int(*aom_subpixvariance_fn_t)(const uint8_t *a, int a_stride,
++    int xoffset, int yoffset,
++    const uint8_t *b, int b_stride,
++    unsigned int *sse);
++
++typedef unsigned int(*aom_subp_avg_variance_fn_t)(
++    const uint8_t *a, int a_stride, int xoffset, int yoffset, const uint8_t *b,
++    int b_stride, unsigned int *sse, const uint8_t *second_pred);
++
++typedef unsigned int(*aom_dist_wtd_sad_avg_fn_t)(
++    const uint8_t *a, int a_stride, const uint8_t *b, int b_stride,
++    const uint8_t *second_pred, const DIST_WTD_COMP_PARAMS *jcp_param);
++
++typedef unsigned int(*aom_dist_wtd_subp_avg_variance_fn_t)(
++    const uint8_t *a, int a_stride, int xoffset, int yoffset, const uint8_t *b,
++    int b_stride, unsigned int *sse, const uint8_t *second_pred,
++    const DIST_WTD_COMP_PARAMS *jcp_param);
++
++typedef unsigned int(*aom_masked_sad_fn_t)(const uint8_t *src, int src_stride,
++    const uint8_t *ref, int ref_stride,
++    const uint8_t *second_pred,
++    const uint8_t *msk, int msk_stride,
++    int invert_mask);
++typedef unsigned int(*aom_masked_subpixvariance_fn_t)(
++    const uint8_t *src, int src_stride, int xoffset, int yoffset,
++    const uint8_t *ref, int ref_stride, const uint8_t *second_pred,
++    const uint8_t *msk, int msk_stride, int invert_mask, unsigned int *sse);
++typedef unsigned int(*aom_obmc_sad_fn_t)(const uint8_t *pred, int pred_stride,
++    const int32_t *wsrc,
++    const int32_t *msk);
++typedef unsigned int(*aom_obmc_variance_fn_t)(const uint8_t *pred,
++    int pred_stride,
++    const int32_t *wsrc,
++    const int32_t *msk,
++    unsigned int *sse);
++typedef unsigned int(*aom_obmc_subpixvariance_fn_t)(
++    const uint8_t *pred, int pred_stride, int xoffset, int yoffset,
++    const int32_t *wsrc, const int32_t *msk, unsigned int *sse);
++
++typedef struct aom_variance_vtable {
++    aom_sad_fn_t sdf;                   
++    aom_variance_fn_t vf; 
++    aom_sad_multi_d_fn_t sdx4df;         
++} aom_variance_fn_ptr_t;
++
++int av1_refining_search_sad(IntraBcContext  *x, MV *ref_mv, int error_per_bit,
++    int search_range,
++    const aom_variance_fn_ptr_t *fn_ptr,
++    const MV *center_mv);
++/* Sum the difference between every corresponding element of the buffers. */
++static INLINE unsigned int sad(const uint8_t *a, int a_stride, const uint8_t *b,
++    int b_stride, int width, int height) {
++    int y, x;
++    unsigned int sad = 0;
++
++    for (y = 0; y < height; y++) {
++        for (x = 0; x < width; x++) {
++            sad += abs(a[x] - b[x]);
++        }
++
++        a += a_stride;
++        b += b_stride;
++    }
++    return sad;
++}
++#if 1
++#define sadMxh(m)                                                          \
++  unsigned int aom_sad##m##xh_c(const uint8_t *a, int a_stride,            \
++                                const uint8_t *b, int b_stride, int width, \
++                                int height) {                              \
++    return NxMSadKernelSubSampled_funcPtrArray[ASM_AVX2][width >> 3]((uint8_t *)a, a_stride, (uint8_t *)b, b_stride, width, height);  \
++  }
++#define sadMxNx4D(m, n)                                                    \
++  void aom_sad##m##x##n##x4d_c(const uint8_t *src, int src_stride,         \
++                               const uint8_t *const ref_array[],           \
++                               int ref_stride, uint32_t *sad_array) {      \
++    int i;                                                                 \
++    for (i = 0; i < 4; ++i) {                                              \
++      sad_array[i] =                                                       \
++          NxMSadKernelSubSampled_funcPtrArray[ASM_AVX2][m >> 3]((uint8_t *)src, src_stride, (uint8_t *)(ref_array[i]), ref_stride, m, n);   \
++    }                                                                      \
++  }
++#define sadMxN(m, n)                                                          \
++  unsigned int aom_sad##m##x##n##_c(const uint8_t *src, int src_stride,       \
++                                    const uint8_t *ref, int ref_stride) {     \
++return NxMSadKernelSubSampled_funcPtrArray[ASM_AVX2][m >> 3]((uint8_t *)src, src_stride, (uint8_t *)ref, ref_stride, m, n);  \
++  } 
++#else
++#define sadMxh(m)                                                          \
++  unsigned int aom_sad##m##xh_c(const uint8_t *a, int a_stride,            \
++                                const uint8_t *b, int b_stride, int width, \
++                                int height) {                              \
++    return sad(a, a_stride, b, b_stride, width, height);                   \
++  }
++
++#define sadMxN(m, n)                                                          \
++  unsigned int aom_sad##m##x##n##_c(const uint8_t *src, int src_stride,       \
++                                    const uint8_t *ref, int ref_stride) {     \
++   return sad(src, src_stride, ref, ref_stride, m, n);    \
++  }                                                                           \
++  
++
++// Calculate sad against 4 reference locations and store each in sad_array
++#define sadMxNx4D(m, n)                                                    \
++  void aom_sad##m##x##n##x4d_c(const uint8_t *src, int src_stride,         \
++                               const uint8_t *const ref_array[],           \
++                               int ref_stride, uint32_t *sad_array) {      \
++    int i;                                                                 \
++    for (i = 0; i < 4; ++i) {                                              \
++      sad_array[i] =                                                       \
++          aom_sad##m##x##n##_c(src, src_stride, ref_array[i], ref_stride); \
++    }                                                                      \
++  }
++#endif
++// 128x128
++sadMxN(128, 128);
++sadMxNx4D(128, 128);
++// 128x64
++sadMxN(128, 64);
++sadMxNx4D(128, 64);
++// 64x128
++sadMxN(64, 128);
++sadMxNx4D(64, 128);
++// 64x64
++sadMxN(64, 64);
++sadMxNx4D(64, 64);
++// 64x32
++sadMxN(64, 32);
++sadMxNx4D(64, 32);
++// 32x64
++sadMxN(32, 64);
++sadMxNx4D(32, 64);
++// 32x32
++sadMxN(32, 32);
++sadMxNx4D(32, 32);
++// 32x16
++sadMxN(32, 16);
++sadMxNx4D(32, 16);
++// 16x32
++sadMxN(16, 32);
++sadMxNx4D(16, 32);
++// 16x16
++sadMxN(16, 16);
++sadMxNx4D(16, 16);
++// 16x8
++sadMxN(16, 8);
++sadMxNx4D(16, 8);
++// 8x16
++sadMxN(8, 16);
++sadMxNx4D(8, 16);
++// 8x8
++sadMxN(8, 8);
++sadMxNx4D(8, 8);
++// 8x4
++sadMxN(8, 4);
++sadMxNx4D(8, 4);
++// 4x8
++sadMxN(4, 8);
++sadMxNx4D(4, 8);
++// 4x4
++sadMxN(4, 4);
++sadMxNx4D(4, 4);
++
++sadMxh(128);
++sadMxh(64);
++sadMxh(32);
++sadMxh(16);
++sadMxh(8);
++sadMxh(4);
++
++sadMxN(4, 16);
++sadMxNx4D(4, 16);
++sadMxN(16, 4);
++sadMxNx4D(16, 4);
++sadMxN(8, 32);
++sadMxNx4D(8, 32);
++sadMxN(32, 8);
++sadMxNx4D(32, 8);
++sadMxN(16, 64);
++sadMxNx4D(16, 64);
++sadMxN(64, 16);
++sadMxNx4D(64, 16);
++
++static void variance(const uint8_t *a, int a_stride, const uint8_t *b,
++    int b_stride, int w, int h, uint32_t *sse, int *sum) {
++    int i, j;
++
++    *sum = 0;
++    *sse = 0;
++
++    for (i = 0; i < h; ++i) {
++        for (j = 0; j < w; ++j) {
++            const int diff = a[j] - b[j];
++            *sum += diff;
++            *sse += diff * diff;
++        }
++
++        a += a_stride;
++        b += b_stride;
++    }
++}
++#define VAR(W, H)                                                    \
++  uint32_t aom_variance##W##x##H##_c(const uint8_t *a, int a_stride, \
++                                     const uint8_t *b, int b_stride, \
++                                     uint32_t *sse) {                \
++    int sum;                                                         \
++    variance(a, a_stride, b, b_stride, W, H, sse, &sum);             \
++    return *sse - (uint32_t)(((int64_t)sum * sum) / (W * H));        \
++  }
++
++VAR(128, 128)
++VAR(128, 64)
++VAR(64, 128)
++VAR(64, 64)
++VAR(64, 32)
++VAR(32, 64)
++VAR(32, 32)
++VAR(32, 16)
++VAR(16, 32)
++VAR(16, 16)
++VAR(16, 8)
++VAR(8, 16)
++VAR(8, 8)
++VAR(8, 4)
++VAR(4, 8)
++VAR(4, 4)
++VAR(4, 2)
++VAR(2, 4)
++VAR(2, 2)
++VAR(4, 16)
++VAR(16, 4)
++VAR(8, 32)
++VAR(32, 8)
++VAR(16, 64)
++VAR(64, 16)
++
++aom_variance_fn_ptr_t mefn_ptr[BlockSizeS_ALL];
++
++void init_fn_ptr(void)
++{
++#define BFP0(BT, SDF, VF, SDX4DF)                            \
++  mefn_ptr[BT].sdf = SDF;                                    \
++  mefn_ptr[BT].vf = VF;                                      \
++  mefn_ptr[BT].sdx4df = SDX4DF;
++
++      
++        BFP0(BLOCK_4X16, aom_sad4x16_c, aom_variance4x16_c, aom_sad4x16x4d_c)  
++       
++        BFP0(BLOCK_16X4, aom_sad16x4_c, aom_variance16x4_c, aom_sad16x4x4d_c)
++       
++        BFP0(BLOCK_8X32, aom_sad8x32_c, aom_variance8x32_c, aom_sad8x32x4d_c)
++
++        BFP0(BLOCK_32X8, aom_sad32x8_c, aom_variance32x8_c, aom_sad32x8x4d_c)
++
++        BFP0(BLOCK_16X64, aom_sad16x64_c, aom_variance16x64_c, aom_sad16x64x4d_c)
++
++        BFP0(BLOCK_64X16, aom_sad64x16_c, aom_variance64x16_c, aom_sad64x16x4d_c)
++
++        BFP0(BLOCK_128X128, aom_sad128x128_c, aom_variance128x128_c, aom_sad128x128x4d_c)
++
++        BFP0(BLOCK_128X64, aom_sad128x64_c, aom_variance128x64_c, aom_sad128x64x4d_c)
++
++        BFP0(BLOCK_64X128, aom_sad64x128_c, aom_variance64x128_c, aom_sad64x128x4d_c)
++
++     
++        BFP0(BLOCK_32X16, aom_sad32x16_c, aom_variance32x16_c, aom_sad32x16x4d_c)
++
++        BFP0(BLOCK_16X32, aom_sad16x32_c, aom_variance16x32_c, aom_sad16x32x4d_c)
++
++        BFP0(BLOCK_64X32, aom_sad64x32_c, aom_variance64x32_c, aom_sad64x32x4d_c)
++
++     
++        BFP0(BLOCK_32X64, aom_sad32x64_c, aom_variance32x64_c, aom_sad32x64x4d_c)
++
++      
++        BFP0(BLOCK_32X32, aom_sad32x32_c, aom_variance32x32_c, aom_sad32x32x4d_c)
++
++        BFP0(BLOCK_64X64, aom_sad64x64_c, aom_variance64x64_c, aom_sad64x64x4d_c)
++
++       
++        BFP0(BLOCK_16X16, aom_sad16x16_c, aom_variance16x16_c, aom_sad16x16x4d_c)
++
++        BFP0(BLOCK_16X8, aom_sad16x8_c, aom_variance16x8_c, aom_sad16x8x4d_c)
++
++     
++        BFP0(BLOCK_8X16, aom_sad8x16_c, aom_variance8x16_c, aom_sad8x16x4d_c)
++
++        BFP0(BLOCK_8X8, aom_sad8x8_c, aom_variance8x8_c, aom_sad8x8x4d_c)
++
++        BFP0(BLOCK_8X4, aom_sad8x4_c, aom_variance8x4_c, aom_sad8x4x4d_c)
++        
++       
++        BFP0(BLOCK_4X8, aom_sad4x8_c, aom_variance4x8_c, aom_sad4x8x4d_c)
++       
++        BFP0(BLOCK_4X4, aom_sad4x4_c, aom_variance4x4_c, aom_sad4x4x4d_c)
++}
++
++
++// #define NEW_DIAMOND_SEARCH
++
++static INLINE const uint8_t *get_buf_from_mv(const struct buf_2d *buf,
++                                             const MV *mv) {
++  return &buf->buf[mv->row * buf->stride + mv->col];
++}
++
++void av1_set_mv_search_range(MvLimits *mv_limits, const MV *mv) {
++  int col_min = (mv->col >> 3) - MAX_FULL_PEL_VAL + (mv->col & 7 ? 1 : 0);
++  int row_min = (mv->row >> 3) - MAX_FULL_PEL_VAL + (mv->row & 7 ? 1 : 0);
++  int col_max = (mv->col >> 3) + MAX_FULL_PEL_VAL;
++  int row_max = (mv->row >> 3) + MAX_FULL_PEL_VAL;
++
++  col_min = AOMMAX(col_min, (MV_LOW >> 3) + 1);
++  row_min = AOMMAX(row_min, (MV_LOW >> 3) + 1);
++  col_max = AOMMIN(col_max, (MV_UPP >> 3) - 1);
++  row_max = AOMMIN(row_max, (MV_UPP >> 3) - 1);
++
++  // Get intersection of UMV window and valid MV window to reduce # of checks
++  // in diamond search.
++  if (mv_limits->col_min < col_min) mv_limits->col_min = col_min;
++  if (mv_limits->col_max > col_max) mv_limits->col_max = col_max;
++  if (mv_limits->row_min < row_min) mv_limits->row_min = row_min;
++  if (mv_limits->row_max > row_max) mv_limits->row_max = row_max;
++}
++
++
++
++MV_JOINT_TYPE av1_get_mv_joint(const MV *mv);
++
++static INLINE int mv_cost(const MV *mv, const int *joint_cost,
++                          int *const comp_cost[2]) {
++  return joint_cost[av1_get_mv_joint(mv)] + comp_cost[0][mv->row] +
++         comp_cost[1][mv->col];
++}
++
++
++#define PIXEL_TRANSFORM_ERROR_SCALE 4
++static int mv_err_cost(const MV *mv, const MV *ref, const int *mvjcost,
++                       int *mvcost[2], int error_per_bit) {
++  if (mvcost) {
++    const MV diff = { mv->row - ref->row, mv->col - ref->col };
++    return (int)ROUND_POWER_OF_TWO_64(
++        (int64_t)mv_cost(&diff, mvjcost, mvcost) * error_per_bit,
++        RDDIV_BITS + AV1_PROB_COST_SHIFT - RD_EPB_SHIFT +
++            PIXEL_TRANSFORM_ERROR_SCALE);
++  }
++  return 0;
++}
++
++static int mvsad_err_cost(const IntraBcContext *x, const MV *mv, const MV *ref,
++                          int sad_per_bit) {
++  const MV diff = { (mv->row - ref->row) * 8, (mv->col - ref->col) * 8 };
++  return ROUND_POWER_OF_TWO(
++      (unsigned)mv_cost(&diff, x->nmv_vec_cost, x->mv_cost_stack) * sad_per_bit,
++      AV1_PROB_COST_SHIFT);
++}
++
++void av1_init3smotion_compensation(search_site_config *cfg, int stride) {
++  int len, ss_count = 1;
++
++  cfg->ss[0].mv.col = cfg->ss[0].mv.row = 0;
++  cfg->ss[0].offset = 0;
++
++  for (len = MAX_FIRST_STEP; len > 0; len /= 2) {
++    // Generate offsets for 8 search sites per step.
++    const MV ss_mvs[8] = { { -len, 0 },   { len, 0 },     { 0, -len },
++                           { 0, len },    { -len, -len }, { -len, len },
++                           { len, -len }, { len, len } };
++    int i;
++    for (i = 0; i < 8; ++i) {
++      search_site *const ss = &cfg->ss[ss_count++];
++      ss->mv = ss_mvs[i];
++      ss->offset = ss->mv.row * stride + ss->mv.col;
++    }
++  }
++
++  cfg->ss_count = ss_count;
++  cfg->searches_per_step = 8;
++}
++
++static INLINE int check_bounds(const MvLimits *mv_limits, int row, int col,
++                               int range) {
++  return ((row - range) >= mv_limits->row_min) &
++         ((row + range) <= mv_limits->row_max) &
++         ((col - range) >= mv_limits->col_min) &
++         ((col + range) <= mv_limits->col_max);
++}
++
++static INLINE int is_mv_in(const MvLimits *mv_limits, const MV *mv) {
++  return (mv->col >= mv_limits->col_min) && (mv->col <= mv_limits->col_max) &&
++         (mv->row >= mv_limits->row_min) && (mv->row <= mv_limits->row_max);
++}
++
++#define CHECK_BETTER                                                      \
++  {                                                                       \
++    if (thissad < bestsad) {                                              \
++      if (use_mvcost)                                                     \
++        thissad += mvsad_err_cost(x, &this_mv, &fcenter_mv, sad_per_bit); \
++      if (thissad < bestsad) {                                            \
++        bestsad = thissad;                                                \
++        best_site = i;                                                    \
++      }                                                                   \
++    }                                                                     \
++  }
++
++#define MAX_PATTERN_SCALES 11
++#define MAX_PATTERN_CANDIDATES 8  // max number of canddiates per scale
++#define PATTERN_CANDIDATES_REF 3  // number of refinement candidates
++
++int av1_get_mvpred_var(const IntraBcContext *x, const MV *best_mv,
++                       const MV *center_mv, const aom_variance_fn_ptr_t *vfp,
++                       int use_mvcost) {
++   
++  const struct buf_2d *const what = &x->plane[0].src;
++  const struct buf_2d *const in_what = &x->xdplane[0].pre[0];
++  const MV mv = { best_mv->row * 8, best_mv->col * 8 };
++  unsigned int unused;
++
++  return vfp->vf(what->buf, what->stride, get_buf_from_mv(in_what, best_mv),
++                 in_what->stride, &unused) +
++         (use_mvcost ? mv_err_cost(&mv, center_mv, x->nmv_vec_cost,
++                                   x->mv_cost_stack, x->errorperbit)
++                     : 0);
++}
++
++// Exhuastive motion search around a given centre position with a given
++// step size.
++static int exhuastive_mesh_search(IntraBcContext  *x, MV *ref_mv, MV *best_mv,
++                                  int range, int step, int sad_per_bit,
++                                  const aom_variance_fn_ptr_t *fn_ptr,
++                                  const MV *center_mv) {
++   
++  const struct buf_2d *const what = &x->plane[0].src;
++  const struct buf_2d *const in_what = &x->xdplane[0].pre[0];
++  MV fcenter_mv = { center_mv->row, center_mv->col };
++  unsigned int best_sad = INT_MAX;
++  int r, c, i;
++  int start_col, end_col, start_row, end_row;
++  int col_step = (step > 1) ? step : 4;
++
++  assert(step >= 1);
++
++  clamp_mv(&fcenter_mv, x->mv_limits.col_min, x->mv_limits.col_max,
++           x->mv_limits.row_min, x->mv_limits.row_max);
++  *best_mv = fcenter_mv;
++  best_sad =
++      fn_ptr->sdf(what->buf, what->stride,
++                  get_buf_from_mv(in_what, &fcenter_mv), in_what->stride) +
++      mvsad_err_cost(x, &fcenter_mv, ref_mv, sad_per_bit);
++  start_row = AOMMAX(-range, x->mv_limits.row_min - fcenter_mv.row);
++  start_col = AOMMAX(-range, x->mv_limits.col_min - fcenter_mv.col);
++  end_row = AOMMIN(range, x->mv_limits.row_max - fcenter_mv.row);
++  end_col = AOMMIN(range, x->mv_limits.col_max - fcenter_mv.col);
++
++  for (r = start_row; r <= end_row; r += step) {
++    for (c = start_col; c <= end_col; c += col_step) {
++      // Step > 1 means we are not checking every location in this pass.
++      if (step > 1) {
++        const MV mv = { fcenter_mv.row + r, fcenter_mv.col + c };
++        unsigned int sad =
++            fn_ptr->sdf(what->buf, what->stride, get_buf_from_mv(in_what, &mv),
++                        in_what->stride);
++        if (sad < best_sad) {
++          sad += mvsad_err_cost(x, &mv, ref_mv, sad_per_bit);
++          if (sad < best_sad) {
++            best_sad = sad;
++            x->second_best_mv.as_mv = *best_mv;
++            *best_mv = mv;
++          }
++        }
++      } else {
++        // 4 sads in a single call if we are checking every location
++        if (c + 3 <= end_col) {
++          unsigned int sads[4];
++          const uint8_t *addrs[4];
++          for (i = 0; i < 4; ++i) {
++            const MV mv = { fcenter_mv.row + r, fcenter_mv.col + c + i };
++            addrs[i] = get_buf_from_mv(in_what, &mv);
++          }
++          fn_ptr->sdx4df(what->buf, what->stride, addrs, in_what->stride, sads);
++
++          for (i = 0; i < 4; ++i) {
++            if (sads[i] < best_sad) {
++              const MV mv = { fcenter_mv.row + r, fcenter_mv.col + c + i };
++              const unsigned int sad =
++                  sads[i] + mvsad_err_cost(x, &mv, ref_mv, sad_per_bit);
++              if (sad < best_sad) {
++                best_sad = sad;
++                x->second_best_mv.as_mv = *best_mv;
++                *best_mv = mv;
++              }
++            }
++          }
++        } else {
++          for (i = 0; i < end_col - c; ++i) {
++            const MV mv = { fcenter_mv.row + r, fcenter_mv.col + c + i };
++            unsigned int sad =
++                fn_ptr->sdf(what->buf, what->stride,
++                            get_buf_from_mv(in_what, &mv), in_what->stride);
++            if (sad < best_sad) {
++              sad += mvsad_err_cost(x, &mv, ref_mv, sad_per_bit);
++              if (sad < best_sad) {
++                best_sad = sad;
++                x->second_best_mv.as_mv = *best_mv;
++                *best_mv = mv;
++              }
++            }
++          }
++        }
++      }
++    }
++  }
++
++  return best_sad;
++}
++
++
++int av1_diamond_search_sad_c(IntraBcContext  *x, const search_site_config *cfg,
++                             MV *ref_mv, MV *best_mv, int search_param,
++                             int sad_per_bit, int *num00,
++                             const aom_variance_fn_ptr_t *fn_ptr,
++                             const MV *center_mv) {
++  int i, j, step;
++
++ 
++  uint8_t *what = x->plane[0].src.buf;
++  const int what_stride = x->plane[0].src.stride;
++  const uint8_t *in_what;
++  const int in_what_stride = x->xdplane[0].pre[0].stride;
++  const uint8_t *best_address;
++
++  unsigned int bestsad = INT_MAX;
++  int best_site = 0;
++  int last_site = 0;
++
++  int ref_row;
++  int ref_col;
++
++  // search_param determines the length of the initial step and hence the number
++  // of iterations.
++  // 0 = initial step (MAX_FIRST_STEP) pel
++  // 1 = (MAX_FIRST_STEP/2) pel,
++  // 2 = (MAX_FIRST_STEP/4) pel...
++  const search_site *ss = &cfg->ss[search_param * cfg->searches_per_step];
++  const int tot_steps = (cfg->ss_count / cfg->searches_per_step) - search_param;
++
++  const MV fcenter_mv = { center_mv->row >> 3, center_mv->col >> 3 };
++  clamp_mv(ref_mv, x->mv_limits.col_min, x->mv_limits.col_max,
++           x->mv_limits.row_min, x->mv_limits.row_max);
++  ref_row = ref_mv->row;
++  ref_col = ref_mv->col;
++  *num00 = 0;
++  best_mv->row = ref_row;
++  best_mv->col = ref_col;
++
++  // Work out the start point for the search
++  in_what = x->xdplane[0].pre[0].buf + ref_row * in_what_stride + ref_col;
++  best_address = in_what;
++
++  // Check the starting position
++  bestsad = fn_ptr->sdf(what, what_stride, in_what, in_what_stride) +
++            mvsad_err_cost(x, best_mv, &fcenter_mv, sad_per_bit);
++
++  i = 1;
++
++  for (step = 0; step < tot_steps; step++) {
++    int all_in = 1, t;
++
++    // All_in is true if every one of the points we are checking are within
++    // the bounds of the image.
++    all_in &= ((best_mv->row + ss[i].mv.row) > x->mv_limits.row_min);
++    all_in &= ((best_mv->row + ss[i + 1].mv.row) < x->mv_limits.row_max);
++    all_in &= ((best_mv->col + ss[i + 2].mv.col) > x->mv_limits.col_min);
++    all_in &= ((best_mv->col + ss[i + 3].mv.col) < x->mv_limits.col_max);
++
++    // If all the pixels are within the bounds we don't check whether the
++    // search point is valid in this loop,  otherwise we check each point
++    // for validity..
++    if (all_in) {
++      unsigned int sad_array[4];
++
++      for (j = 0; j < cfg->searches_per_step; j += 4) {
++        unsigned char const *block_offset[4];
++
++        for (t = 0; t < 4; t++)
++          block_offset[t] = ss[i + t].offset + best_address;
++
++        fn_ptr->sdx4df(what, what_stride, block_offset, in_what_stride,
++                       sad_array);
++
++        for (t = 0; t < 4; t++, i++) {
++          if (sad_array[t] < bestsad) {
++            const MV this_mv = { best_mv->row + ss[i].mv.row,
++                                 best_mv->col + ss[i].mv.col };
++            sad_array[t] +=
++                mvsad_err_cost(x, &this_mv, &fcenter_mv, sad_per_bit);
++            if (sad_array[t] < bestsad) {
++              bestsad = sad_array[t];
++              best_site = i;
++            }
++          }
++        }
++      }
++    } else {
++      for (j = 0; j < cfg->searches_per_step; j++) {
++        // Trap illegal vectors
++        const MV this_mv = { best_mv->row + ss[i].mv.row,
++                             best_mv->col + ss[i].mv.col };
++
++        if (is_mv_in(&x->mv_limits, &this_mv)) {
++          const uint8_t *const check_here = ss[i].offset + best_address;
++          unsigned int thissad =
++              fn_ptr->sdf(what, what_stride, check_here, in_what_stride);
++
++          if (thissad < bestsad) {
++            thissad += mvsad_err_cost(x, &this_mv, &fcenter_mv, sad_per_bit);
++            if (thissad < bestsad) {
++              bestsad = thissad;
++              best_site = i;
++            }
++          }
++        }
++        i++;
++      }
++    }
++    if (best_site != last_site) {
++      x->second_best_mv.as_mv = *best_mv;
++      best_mv->row += ss[best_site].mv.row;
++      best_mv->col += ss[best_site].mv.col;
++      best_address += ss[best_site].offset;
++      last_site = best_site;
++#if defined(NEW_DIAMOND_SEARCH)
++      while (1) {
++        const MV this_mv = { best_mv->row + ss[best_site].mv.row,
++                             best_mv->col + ss[best_site].mv.col };
++        if (is_mv_in(&x->mv_limits, &this_mv)) {
++          const uint8_t *const check_here = ss[best_site].offset + best_address;
++          unsigned int thissad =
++              fn_ptr->sdf(what, what_stride, check_here, in_what_stride);
++          if (thissad < bestsad) {
++            thissad += mvsad_err_cost(x, &this_mv, &fcenter_mv, sad_per_bit);
++            if (thissad < bestsad) {
++              bestsad = thissad;
++              best_mv->row += ss[best_site].mv.row;
++              best_mv->col += ss[best_site].mv.col;
++              best_address += ss[best_site].offset;
++              continue;
++            }
++          }
++        }
++        break;
++      }
++#endif
++    } else if (best_address == in_what) {
++      (*num00)++;
++    }
++  }
++  return bestsad;
++}
++
++
++
++/* do_refine: If last step (1-away) of n-step search doesn't pick the center
++              point as the best match, we will do a final 1-away diamond
++              refining search  */
++static int full_pixel_diamond(PictureControlSet_t *pcs, IntraBcContext /*MACROBLOCK*/ *x,
++                              MV *mvp_full, int step_param, int sadpb,
++                              int further_steps, int do_refine, int *cost_list,
++                              const aom_variance_fn_ptr_t *fn_ptr,
++                              const MV *ref_mv) {
++  MV temp_mv;
++  int thissme, n, num00 = 0;
++  (void)cost_list;
++  /*int bestsme = cpi->diamond_search_sad(x, &cpi->ss_cfg, mvp_full, &temp_mv,
++                                        step_param, sadpb, &n, fn_ptr, ref_mv);*/
++  int bestsme = av1_diamond_search_sad_c(x, &pcs->ss_cfg, mvp_full, &temp_mv,
++      step_param, sadpb, &n, fn_ptr, ref_mv);
++
++  if (bestsme < INT_MAX)
++    bestsme = av1_get_mvpred_var(x, &temp_mv, ref_mv, fn_ptr, 1);
++  x->best_mv.as_mv = temp_mv;
++
++  // If there won't be more n-step search, check to see if refining search is
++  // needed.
++  if (n > further_steps) do_refine = 0;
++
++  while (n < further_steps) {
++    ++n;
++
++    if (num00) {
++      num00--;
++    } else {
++      /*thissme = cpi->diamond_search_sad(x, &cpi->ss_cfg, mvp_full, &temp_mv,
++                                        step_param + n, sadpb, &num00, fn_ptr,
++                                        ref_mv);*/
++      thissme = av1_diamond_search_sad_c(x, &pcs->ss_cfg, mvp_full, &temp_mv,
++          step_param + n, sadpb, &num00, fn_ptr,
++          ref_mv);
++
++      if (thissme < INT_MAX)
++        thissme = av1_get_mvpred_var(x, &temp_mv, ref_mv, fn_ptr, 1);
++
++      // check to see if refining search is needed.
++      if (num00 > further_steps - n) do_refine = 0;
++
++      if (thissme < bestsme) {
++        bestsme = thissme;
++        x->best_mv.as_mv = temp_mv;
++      }
++    }
++  }
++
++  // final 1-away diamond refining search
++  if (do_refine) {
++    const int search_range = 8;
++    MV best_mv = x->best_mv.as_mv;
++    thissme = av1_refining_search_sad(x, &best_mv, sadpb, search_range, fn_ptr,
++                                      ref_mv);
++    if (thissme < INT_MAX)
++      thissme = av1_get_mvpred_var(x, &best_mv, ref_mv, fn_ptr, 1);
++    if (thissme < bestsme) {
++      bestsme = thissme;
++      x->best_mv.as_mv = best_mv;
++    }
++  }
++
++  // Return cost list.
++ /* if (cost_list) {
++    calc_int_cost_list(x, ref_mv, sadpb, fn_ptr, &x->best_mv.as_mv, cost_list);
++  }*/
++  return bestsme;
++}
++
++#define MIN_RANGE 7
++#define MAX_RANGE 256
++#define MIN_INTERVAL 1
++// Runs an limited range exhaustive mesh search using a pattern set
++// according to the encode speed profile.
++static int full_pixel_exhaustive(PictureControlSet_t *pcs, IntraBcContext  *x,
++                                 const MV *centre_mv_full, int sadpb,
++                                 int *cost_list,
++                                 const aom_variance_fn_ptr_t *fn_ptr,
++                                 const MV *ref_mv, MV *dst_mv) {
++    const SPEED_FEATURES *const sf = &pcs->sf;// cpi->sf;
++  MV temp_mv = { centre_mv_full->row, centre_mv_full->col };
++  MV f_ref_mv = { ref_mv->row >> 3, ref_mv->col >> 3 };
++  int bestsme;
++  int i;
++  int interval = sf->mesh_patterns[0].interval;
++  int range = sf->mesh_patterns[0].range;
++  int baseline_interval_divisor;
++
++  // Keep track of number of exhaustive calls (this frame in this thread).
++  //CHKN if (x->ex_search_count_ptr != NULL) ++(*x->ex_search_count_ptr);
++
++  // Trap illegal values for interval and range for this function.
++  if ((range < MIN_RANGE) || (range > MAX_RANGE) || (interval < MIN_INTERVAL) ||
++      (interval > range))
++    return INT_MAX;
++
++  baseline_interval_divisor = range / interval;
++
++  // Check size of proposed first range against magnitude of the centre
++  // value used as a starting point.
++  range = AOMMAX(range, (5 * AOMMAX(abs(temp_mv.row), abs(temp_mv.col))) / 4);
++  range = AOMMIN(range, MAX_RANGE);
++  interval = AOMMAX(interval, range / baseline_interval_divisor);
++
++  // initial search
++  bestsme = exhuastive_mesh_search(x, &f_ref_mv, &temp_mv, range, interval,
++                                   sadpb, fn_ptr, &temp_mv);
++
++  if ((interval > MIN_INTERVAL) && (range > MIN_RANGE)) {
++    // Progressive searches with range and step size decreasing each time
++    // till we reach a step size of 1. Then break out.
++    for (i = 1; i < MAX_MESH_STEP; ++i) {
++      // First pass with coarser step and longer range
++      bestsme = exhuastive_mesh_search(
++          x, &f_ref_mv, &temp_mv, sf->mesh_patterns[i].range,
++          sf->mesh_patterns[i].interval, sadpb, fn_ptr, &temp_mv);
++
++      if (sf->mesh_patterns[i].interval == 1) break;
++    }
++  }
++
++  if (bestsme < INT_MAX)
++    bestsme = av1_get_mvpred_var(x, &temp_mv, ref_mv, fn_ptr, 1);
++  *dst_mv = temp_mv;
++
++  // Return cost list.
++ /* if (cost_list) {
++    calc_int_cost_list(x, ref_mv, sadpb, fn_ptr, dst_mv, cost_list);
++  }*/
++  return bestsme;
++}
++
++
++int av1_refining_search_sad(IntraBcContext  *x, MV *ref_mv, int error_per_bit,
++                            int search_range,
++                            const aom_variance_fn_ptr_t *fn_ptr,
++                            const MV *center_mv) {
++  
++  const MV neighbors[4] = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };
++  const struct buf_2d *const what = &x->plane[0].src;
++  const struct buf_2d *const in_what = &x->xdplane[0].pre[0];
++  const MV fcenter_mv = { center_mv->row >> 3, center_mv->col >> 3 };
++  const uint8_t *best_address = get_buf_from_mv(in_what, ref_mv);
++  unsigned int best_sad =
++      fn_ptr->sdf(what->buf, what->stride, best_address, in_what->stride) +
++      mvsad_err_cost(x, ref_mv, &fcenter_mv, error_per_bit);
++  int i, j;
++
++  for (i = 0; i < search_range; i++) {
++    int best_site = -1;
++    const int all_in = ((ref_mv->row - 1) > x->mv_limits.row_min) &
++                       ((ref_mv->row + 1) < x->mv_limits.row_max) &
++                       ((ref_mv->col - 1) > x->mv_limits.col_min) &
++                       ((ref_mv->col + 1) < x->mv_limits.col_max);
++
++    if (all_in) {
++      unsigned int sads[4];
++      const uint8_t *const positions[4] = { best_address - in_what->stride,
++                                            best_address - 1, best_address + 1,
++                                            best_address + in_what->stride };
++
++      fn_ptr->sdx4df(what->buf, what->stride, positions, in_what->stride, sads);
++
++      for (j = 0; j < 4; ++j) {
++        if (sads[j] < best_sad) {
++          const MV mv = { ref_mv->row + neighbors[j].row,
++                          ref_mv->col + neighbors[j].col };
++          sads[j] += mvsad_err_cost(x, &mv, &fcenter_mv, error_per_bit);
++          if (sads[j] < best_sad) {
++            best_sad = sads[j];
++            best_site = j;
++          }
++        }
++      }
++    } else {
++      for (j = 0; j < 4; ++j) {
++        const MV mv = { ref_mv->row + neighbors[j].row,
++                        ref_mv->col + neighbors[j].col };
++
++        if (is_mv_in(&x->mv_limits, &mv)) {
++          unsigned int sad =
++              fn_ptr->sdf(what->buf, what->stride,
++                          get_buf_from_mv(in_what, &mv), in_what->stride);
++          if (sad < best_sad) {
++            sad += mvsad_err_cost(x, &mv, &fcenter_mv, error_per_bit);
++            if (sad < best_sad) {
++              best_sad = sad;
++              best_site = j;
++            }
++          }
++        }
++      }
++    }
++
++    if (best_site == -1) {
++      break;
++    } else {
++      x->second_best_mv.as_mv = *ref_mv;
++      ref_mv->row += neighbors[best_site].row;
++      ref_mv->col += neighbors[best_site].col;
++      best_address = get_buf_from_mv(in_what, ref_mv);
++    }
++  }
++
++  return best_sad;
++}
++
++int av1_full_pixel_search(PictureControlSet_t *pcs, IntraBcContext  *x, block_size bsize,
++                          MV *mvp_full, int step_param, int method,
++                          int run_mesh_search, int error_per_bit,
++                          int *cost_list, const MV *ref_mv, int var_max, int rd,
++                          int x_pos, int y_pos, int intra) {
++
++
++  const SPEED_FEATURES *const sf = &pcs->sf;
++  const aom_variance_fn_ptr_t *fn_ptr = &mefn_ptr[bsize];
++  int var = 0;
++
++  if (cost_list) {
++    cost_list[0] = INT_MAX;
++    cost_list[1] = INT_MAX;
++    cost_list[2] = INT_MAX;
++    cost_list[3] = INT_MAX;
++    cost_list[4] = INT_MAX;
++  }
++
++  // Keep track of number of searches (this frame in this thread).
++  //if (x->m_search_count_ptr != NULL) ++(*x->m_search_count_ptr);
++
++  switch (method) {
++    case FAST_DIAMOND:
++      //var = fast_dia_search(x, mvp_full, step_param, error_per_bit, 0,
++      //                      cost_list, fn_ptr, 1, ref_mv);
++      break;
++    case FAST_HEX:
++      //var = fast_hex_search(x, mvp_full, step_param, error_per_bit, 0,
++      //                      cost_list, fn_ptr, 1, ref_mv);
++      break;
++    case HEX:
++      //var = av1_hex_search(x, mvp_full, step_param, error_per_bit, 1, cost_list,
++      //                     fn_ptr, 1, ref_mv);
++      break;
++    case SQUARE:
++      //var = square_search(x, mvp_full, step_param, error_per_bit, 1, cost_list,
++      //                    fn_ptr, 1, ref_mv);
++      break;
++    case BIGDIA:
++      //var = bigdia_search(x, mvp_full, step_param, error_per_bit, 1, cost_list,
++      //                    fn_ptr, 1, ref_mv);
++      break;
++    case NSTEP:
++      var = full_pixel_diamond(pcs, x, mvp_full, step_param, error_per_bit,
++                               MAX_MVSEARCH_STEPS - 1 - step_param, 1,
++                               cost_list, fn_ptr, ref_mv);
++
++      // Should we allow a follow on exhaustive search?
++      if(1)// (is_exhaustive_allowed(cpi, x))   
++      {
++        //int exhuastive_thr = sf->exhaustive_searches_thresh;
++        //exhuastive_thr >>=
++        //    10 - (mi_size_wide_log2[bsize] + mi_size_high_log2[bsize]);
++
++        // Threshold variance for an exhaustive full search.
++        //if (var > exhuastive_thr)   
++        {
++          int var_ex;
++          MV tmp_mv_ex;
++          var_ex =
++              full_pixel_exhaustive(pcs, x, &x->best_mv.as_mv, error_per_bit,
++                                    cost_list, fn_ptr, ref_mv, &tmp_mv_ex);
++
++          if (var_ex < var) {
++            var = var_ex;
++            x->best_mv.as_mv = tmp_mv_ex;
++          }
++        }
++      }
++
++      break;
++    default: assert(0 && "Invalid search method.");
++  }
++
++
++  // Should we allow a follow on exhaustive search?
++  if (!run_mesh_search) {
++    if (method == NSTEP) {
++      //if (is_exhaustive_allowed(cpi, x))
++      {
++        int exhuastive_thr = sf->exhaustive_searches_thresh;
++        exhuastive_thr >>=
++            10 - (mi_size_wide_log2[bsize] + mi_size_high_log2[bsize]);
++        // Threshold variance for an exhaustive full search.
++        if (var > exhuastive_thr) run_mesh_search = 1;
++      }
++    }
++  }
++
++  //if (run_mesh_search)
++  if(1)
++  {
++    int var_ex;
++    MV tmp_mv_ex;
++    var_ex = full_pixel_exhaustive(pcs, x, &x->best_mv.as_mv, error_per_bit,
++                                   cost_list, fn_ptr, ref_mv, &tmp_mv_ex);
++    if (var_ex < var) {
++      var = var_ex;
++      x->best_mv.as_mv = tmp_mv_ex;
++    }
++  }
++
++  if (method != NSTEP && rd && var < var_max)
++    var = av1_get_mvpred_var(x, &x->best_mv.as_mv, ref_mv, fn_ptr, 1);
++
++
++  do {
++    //CHKN if (!intra || !av1_use_hash_me(&cpi->common)) break;
++
++    // already single ME
++    // get block size and original buffer of current block
++    const int block_height = block_size_high[bsize];
++    const int block_width = block_size_wide[bsize];
++    if (block_height == block_width && x_pos >= 0 && y_pos >= 0) {
++      if (block_width == 4 || block_width == 8 || block_width == 16 ||
++          block_width == 32 || block_width == 64 || block_width == 128) {
++        uint8_t *what = x->plane[0].src.buf;
++        const int what_stride = x->plane[0].src.stride;
++        uint32_t hash_value1, hash_value2;
++        MV best_hash_mv;
++        int best_hash_cost = INT_MAX;
++
++        // for the hashMap
++        hash_table *ref_frame_hash = &pcs->hash_table;
++
++        av1_get_block_hash_value(what, what_stride, block_width, &hash_value1,
++                                 &hash_value2, 0, pcs, x);
++
++        const int count = av1_hash_table_count(ref_frame_hash, hash_value1);
++        // for intra, at least one matching can be found, itself.
++        if (count <= (intra ? 1 : 0)) {
++          break;
++        }
++ 
++        Iterator iterator =
++            av1_hash_get_first_iterator(ref_frame_hash, hash_value1);
++        for (int i = 0; i < count; i++, iterator_increment(&iterator)) {
++          block_hash ref_block_hash = *(block_hash *)(iterator_get(&iterator));
++          if (hash_value2 == ref_block_hash.hash_value2) {
++            // For intra, make sure the prediction is from valid area.
++            if (intra) {
++              const int mi_col = x_pos / MI_SIZE;
++              const int mi_row = y_pos / MI_SIZE;
++              const MV dv = { 8 * (ref_block_hash.y - y_pos),
++                              8 * (ref_block_hash.x - x_pos) };
++              if (!av1_is_dv_valid(dv, x->xd, mi_row, mi_col,
++                                   bsize, pcs->parent_pcs_ptr->sequence_control_set_ptr->mib_size_log2))
++                continue;
++            }
++            MV hash_mv;
++            hash_mv.col = ref_block_hash.x - x_pos;
++            hash_mv.row = ref_block_hash.y - y_pos;
++            if (!is_mv_in(&x->mv_limits, &hash_mv)) continue;
++            const int refCost =
++                av1_get_mvpred_var(x, &hash_mv, ref_mv, fn_ptr, 1);
++            if (refCost < best_hash_cost) {
++              best_hash_cost = refCost;
++              best_hash_mv = hash_mv;
++            }
++          }
++        }
++
++        if (best_hash_cost < var) {
++          x->second_best_mv = x->best_mv;
++          x->best_mv.as_mv = best_hash_mv;
++          var = best_hash_cost;
++        }
++
++
++      }
++    }
++  } while (0);
++
++
++  return 0;//CHKN  var;
++}
++
++#endif
+diff --git a/Source/Lib/Codec/av1me.h b/Source/Lib/Codec/av1me.h
+new file mode 100644
+index 0000000..9e0fa1f
+--- /dev/null
++++ b/Source/Lib/Codec/av1me.h
+@@ -0,0 +1,87 @@
++/*
++ * Copyright (c) 2016, Alliance for Open Media. All rights reserved
++ *
++ * This source code is subject to the terms of the BSD 2 Clause License and
++ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
++ * was not distributed with this source code in the LICENSE file, you can
++ * obtain it at www.aomedia.org/license/software. If the Alliance for Open
++ * Media Patent License 1.0 was not distributed with this source code in the
++ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
++ */
++
++#ifndef AOM_AV1_ENCODER_MCOMP_H_
++#define AOM_AV1_ENCODER_MCOMP_H_
++
++#include "EbDefinitions.h"
++#include "EbCodingUnit.h"
++#include "EbUtility.h"
++
++
++
++//#include "av1/encoder/block.h"
++//#include "aom_dsp/variance.h"
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++// The maximum number of steps in a step search given the largest
++// allowed initial step
++#define MAX_MVSEARCH_STEPS 11
++// Max full pel mv specified in the unit of full pixel
++// Enable the use of motion vector in range [-1023, 1023].
++#define MAX_FULL_PEL_VAL ((1 << (MAX_MVSEARCH_STEPS - 1)) - 1)
++// Maximum size of the first step in full pel units
++#define MAX_FIRST_STEP (1 << (MAX_MVSEARCH_STEPS - 1))
++// Allowed motion vector pixel distance outside image border
++// for Block_16x16
++#define BORDER_MV_PIXELS_B16 (16 + AOM_INTERP_EXTEND)
++
++#define SEARCH_RANGE_8P 3
++#define SEARCH_GRID_STRIDE_8P (2 * SEARCH_RANGE_8P + 1)
++#define SEARCH_GRID_CENTER_8P \
++  (SEARCH_RANGE_8P * SEARCH_GRID_STRIDE_8P + SEARCH_RANGE_8P)
++
++// motion search site
++typedef struct search_site {
++  MV mv;
++  int offset;
++} search_site;
++
++typedef struct search_site_config {
++  search_site ss[8 * MAX_MVSEARCH_STEPS + 1];
++  int ss_count;
++  int searches_per_step;
++} search_site_config;
++
++typedef struct {
++  MV coord;
++  int coord_offset;
++} search_neighbors;
++
++
++void av1_init_dsmotion_compensation(search_site_config *cfg, int stride);
++void av1_init3smotion_compensation(search_site_config *cfg, int stride);
++
++void av1_set_mv_search_range(MvLimits *mv_limits, const MV *mv);
++
++#if 1 //---CHKN
++
++
++struct AV1_COMP;
++struct SPEED_FEATURES;
++
++
++int av1_full_pixel_search(struct PictureControlSet_s *pcs, IntraBcContext /*MACROBLOCK*/ *x,
++                          block_size bsize, MV *mvp_full, int step_param,
++                          int method, int run_mesh_search, int error_per_bit,
++                          int *cost_list, const MV *ref_mv, int var_max, int rd,
++                          int x_pos, int y_pos, int intra);
++
++
++#ifdef __cplusplus
++}  // extern "C"
++#endif
++
++#endif//----CHKN
++#endif  // AOM_AV1_ENCODER_MCOMP_H_
+diff --git a/Source/Lib/Codec/hash.c b/Source/Lib/Codec/hash.c
+new file mode 100644
+index 0000000..4f54868
+--- /dev/null
++++ b/Source/Lib/Codec/hash.c
+@@ -0,0 +1,125 @@
++/*
++ * Copyright (c) 2016, Alliance for Open Media. All rights reserved
++ *
++ * This source code is subject to the terms of the BSD 2 Clause License and
++ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
++ * was not distributed with this source code in the LICENSE file, you can
++ * obtain it at www.aomedia.org/license/software. If the Alliance for Open
++ * Media Patent License 1.0 was not distributed with this source code in the
++ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
++ */
++
++#include "hash.h"
++
++static void crc_calculator_process_data(CRC_CALCULATOR *p_crc_calculator,
++                                        uint8_t *pData, uint32_t dataLength) {
++  for (uint32_t i = 0; i < dataLength; i++) {
++    const uint8_t index =
++        (p_crc_calculator->remainder >> (p_crc_calculator->bits - 8)) ^
++        pData[i];
++    p_crc_calculator->remainder <<= 8;
++    p_crc_calculator->remainder ^= p_crc_calculator->table[index];
++  }
++}
++
++static void crc_calculator_reset(CRC_CALCULATOR *p_crc_calculator) {
++  p_crc_calculator->remainder = 0;
++}
++
++static uint32_t crc_calculator_get_crc(CRC_CALCULATOR *p_crc_calculator) {
++  return p_crc_calculator->remainder & p_crc_calculator->final_result_mask;
++}
++
++static void crc_calculator_init_table(CRC_CALCULATOR *p_crc_calculator) {
++  const uint32_t high_bit = 1 << (p_crc_calculator->bits - 1);
++  const uint32_t byte_high_bit = 1 << (8 - 1);
++
++  for (uint32_t value = 0; value < 256; value++) {
++    uint32_t remainder = 0;
++    for (uint8_t mask = byte_high_bit; mask != 0; mask >>= 1) {
++      if (value & mask) {
++        remainder ^= high_bit;
++      }
++
++      if (remainder & high_bit) {
++        remainder <<= 1;
++        remainder ^= p_crc_calculator->trunc_poly;
++      } else {
++        remainder <<= 1;
++      }
++    }
++    p_crc_calculator->table[value] = remainder;
++  }
++}
++
++void av1_crc_calculator_init(CRC_CALCULATOR *p_crc_calculator, uint32_t bits,
++                             uint32_t truncPoly) {
++  p_crc_calculator->remainder = 0;
++  p_crc_calculator->bits = bits;
++  p_crc_calculator->trunc_poly = truncPoly;
++  p_crc_calculator->final_result_mask = (1 << bits) - 1;
++  crc_calculator_init_table(p_crc_calculator);
++}
++
++uint32_t av1_get_crc_value(void *crc_calculator, uint8_t *p, int length) {
++  CRC_CALCULATOR *p_crc_calculator = (CRC_CALCULATOR *)crc_calculator;
++  crc_calculator_reset(p_crc_calculator);
++  crc_calculator_process_data(p_crc_calculator, p, length);
++  return crc_calculator_get_crc(p_crc_calculator);
++}
++
++/* CRC-32C (iSCSI) polynomial in reversed bit order. */
++#define POLY 0x82f63b78
++
++/* Construct table for software CRC-32C calculation. */
++void av1_crc32c_calculator_init(CRC32C *p_crc32c) {
++  uint32_t crc;
++
++  for (int n = 0; n < 256; n++) {
++    crc = n;
++    crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
++    crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
++    crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
++    crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
++    crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
++    crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
++    crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
++    crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
++    p_crc32c->table[0][n] = crc;
++  }
++  for (int n = 0; n < 256; n++) {
++    crc = p_crc32c->table[0][n];
++    for (int k = 1; k < 8; k++) {
++      crc = p_crc32c->table[0][crc & 0xff] ^ (crc >> 8);
++      p_crc32c->table[k][n] = crc;
++    }
++  }
++}
++
++/* Table-driven software version as a fall-back.  This is about 15 times slower
++ than using the hardware instructions.  This assumes little-endian integers,
++ as is the case on Intel processors that the assembler code here is for. */
++uint32_t av1_get_crc32c_value_c(CRC32C *p, uint8_t *buf, size_t len) {
++  const uint8_t *next = (const uint8_t *)(buf);
++  uint64_t crc;
++
++  crc = 0 ^ 0xffffffff;
++  while (len && ((uintptr_t)next & 7) != 0) {
++    crc = p->table[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);
++    len--;
++  }
++  while (len >= 8) {
++    crc ^= *(uint64_t *)next;
++    crc = p->table[7][crc & 0xff] ^ p->table[6][(crc >> 8) & 0xff] ^
++          p->table[5][(crc >> 16) & 0xff] ^ p->table[4][(crc >> 24) & 0xff] ^
++          p->table[3][(crc >> 32) & 0xff] ^ p->table[2][(crc >> 40) & 0xff] ^
++          p->table[1][(crc >> 48) & 0xff] ^ p->table[0][crc >> 56];
++    next += 8;
++    len -= 8;
++  }
++  while (len) {
++    crc = p->table[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);
++    len--;
++  }
++  return (uint32_t)crc ^ 0xffffffff;
++}
+diff --git a/Source/Lib/Codec/hash.h b/Source/Lib/Codec/hash.h
+new file mode 100644
+index 0000000..1f2aef6
+--- /dev/null
++++ b/Source/Lib/Codec/hash.h
+@@ -0,0 +1,53 @@
++/*
++ * Copyright (c) 2016, Alliance for Open Media. All rights reserved
++ *
++ * This source code is subject to the terms of the BSD 2 Clause License and
++ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
++ * was not distributed with this source code in the LICENSE file, you can
++ * obtain it at www.aomedia.org/license/software. If the Alliance for Open
++ * Media Patent License 1.0 was not distributed with this source code in the
++ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
++ */
++
++#ifndef AOM_AV1_ENCODER_HASH_H_
++#define AOM_AV1_ENCODER_HASH_H_
++
++//#include "config/aom_config.h"
++
++//#include "aom/aom_integer.h"
++#include "EbDefinitions.h"
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++typedef struct _crc_calculator {
++  uint32_t remainder;
++  uint32_t trunc_poly;
++  uint32_t bits;
++  uint32_t table[256];
++  uint32_t final_result_mask;
++} CRC_CALCULATOR;
++
++// Initialize the crc calculator. It must be executed at least once before
++// calling av1_get_crc_value().
++void av1_crc_calculator_init(CRC_CALCULATOR *p_crc_calculator, uint32_t bits,
++                             uint32_t truncPoly);
++uint32_t av1_get_crc_value(void *crc_calculator, uint8_t *p, int length);
++
++// CRC32C: POLY = 0x82f63b78;
++typedef struct _CRC32C {
++  /* Table for a quadword-at-a-time software crc. */
++  uint32_t table[8][256];
++} CRC32C;
++
++// init table for software version crc32c
++void av1_crc32c_calculator_init(CRC32C *p_crc32c);
++
++#define AOM_BUFFER_SIZE_FOR_BLOCK_HASH (4096)
++
++#ifdef __cplusplus
++}  // extern "C"
++#endif
++
++#endif  // AOM_AV1_ENCODER_HASH_H_
+diff --git a/Source/Lib/Codec/hash_motion.c b/Source/Lib/Codec/hash_motion.c
+new file mode 100644
+index 0000000..b488ca9
+--- /dev/null
++++ b/Source/Lib/Codec/hash_motion.c
+@@ -0,0 +1,491 @@
++/*
++ * Copyright (c) 2018, Alliance for Open Media. All rights reserved
++ *
++ * This source code is subject to the terms of the BSD 2 Clause License and
++ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
++ * was not distributed with this source code in the LICENSE file, you can
++ * obtain it at www.aomedia.org/license/software. If the Alliance for Open
++ * Media Patent License 1.0 was not distributed with this source code in the
++ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
++ */
++
++#include <assert.h>
++#include "EbCodingUnit.h"
++#if ICOPY
++
++#include "hash.h"
++#include "hash_motion.h"
++#include "EbPictureControlSet.h"
++
++
++void aom_free(void *memblk);
++static const int crc_bits = 16;
++static const int block_size_bits = 3;
++
++static void hash_table_clear_all(hash_table *p_hash_table) {
++  if (p_hash_table->p_lookup_table == NULL) {
++    return;
++  }
++  int max_addr = 1 << (crc_bits + block_size_bits);
++  for (int i = 0; i < max_addr; i++) {
++    if (p_hash_table->p_lookup_table[i] != NULL) {
++      aom_vector_destroy(p_hash_table->p_lookup_table[i]);
++      aom_free(p_hash_table->p_lookup_table[i]);
++      p_hash_table->p_lookup_table[i] = NULL;
++    }
++  }
++}
++
++// TODO(youzhou@microsoft.com): is higher than 8 bits screen content supported?
++// If yes, fix this function
++static void get_pixels_in_1D_char_array_by_block_2x2(uint8_t *y_src, int stride,
++                                                     uint8_t *p_pixels_in1D) {
++  uint8_t *p_pel = y_src;
++  int index = 0;
++  for (int i = 0; i < 2; i++) {
++    for (int j = 0; j < 2; j++) {
++      p_pixels_in1D[index++] = p_pel[j];
++    }
++    p_pel += stride;
++  }
++}
++
++static void get_pixels_in_1D_short_array_by_block_2x2(uint16_t *y_src,
++                                                      int stride,
++                                                      uint16_t *p_pixels_in1D) {
++  uint16_t *p_pel = y_src;
++  int index = 0;
++  for (int i = 0; i < 2; i++) {
++    for (int j = 0; j < 2; j++) {
++      p_pixels_in1D[index++] = p_pel[j];
++    }
++    p_pel += stride;
++  }
++}
++
++static int is_block_2x2_row_same_value(uint8_t *p) {
++  if (p[0] != p[1] || p[2] != p[3]) {
++    return 0;
++  }
++  return 1;
++}
++
++static int is_block16_2x2_row_same_value(uint16_t *p) {
++  if (p[0] != p[1] || p[2] != p[3]) {
++    return 0;
++  }
++  return 1;
++}
++
++static int is_block_2x2_col_same_value(uint8_t *p) {
++  if ((p[0] != p[2]) || (p[1] != p[3])) {
++    return 0;
++  }
++  return 1;
++}
++
++static int is_block16_2x2_col_same_value(uint16_t *p) {
++  if ((p[0] != p[2]) || (p[1] != p[3])) {
++    return 0;
++  }
++  return 1;
++}
++
++// the hash value (hash_value1 consists two parts, the first 3 bits relate to
++// the block size and the remaining 16 bits are the crc values. This fuction
++// is used to get the first 3 bits.
++static int hash_block_size_to_index(int block_size) {
++  switch (block_size) {
++    case 4: return 0;
++    case 8: return 1;
++    case 16: return 2;
++    case 32: return 3;
++    case 64: return 4;
++    case 128: return 5;
++    default: return -1;
++  }
++}
++
++//void av1_hash_table_init(hash_table *p_hash_table, MACROBLOCK *x) {
++//  if (x->g_crc_initialized == 0) {
++//    av1_crc_calculator_init(&x->crc_calculator1, 24, 0x5D6DCB);
++//    av1_crc_calculator_init(&x->crc_calculator2, 24, 0x864CFB);
++//    x->g_crc_initialized = 1;
++//  }
++//  p_hash_table->p_lookup_table = NULL;
++//}
++
++void av1_hash_table_destroy(hash_table *p_hash_table) {
++  hash_table_clear_all(p_hash_table);
++  aom_free(p_hash_table->p_lookup_table);
++  p_hash_table->p_lookup_table = NULL;
++}
++
++EbErrorType  av1_hash_table_create(hash_table *p_hash_table) {
++
++    EbErrorType err_code = EB_ErrorNone;;
++
++  if (p_hash_table->p_lookup_table != NULL) {
++    hash_table_clear_all(p_hash_table);
++    return err_code;
++  }
++  const int max_addr = 1 << (crc_bits + block_size_bits);
++  //p_hash_table->p_lookup_table = (Vector **)malloc(sizeof(p_hash_table->p_lookup_table[0]) * max_addr);
++     EB_MALLOC(Vector **, p_hash_table->p_lookup_table,sizeof(p_hash_table->p_lookup_table[0]) * max_addr, EB_N_PTR);
++  memset(p_hash_table->p_lookup_table, 0,
++         sizeof(p_hash_table->p_lookup_table[0]) * max_addr);
++
++  return err_code;
++}
++
++static void hash_table_add_to_table(hash_table *p_hash_table,
++                                    uint32_t hash_value,
++                                    block_hash *curr_block_hash) {
++  if (p_hash_table->p_lookup_table[hash_value] == NULL) {
++    p_hash_table->p_lookup_table[hash_value] =
++        malloc(sizeof(p_hash_table->p_lookup_table[0][0]));
++    aom_vector_setup(p_hash_table->p_lookup_table[hash_value], 10,
++                     sizeof(curr_block_hash[0]));
++    aom_vector_push_back(p_hash_table->p_lookup_table[hash_value],
++                         curr_block_hash);
++  } else {
++    aom_vector_push_back(p_hash_table->p_lookup_table[hash_value],
++                         curr_block_hash);
++  }
++}
++
++int32_t av1_hash_table_count(const hash_table *p_hash_table,
++                             uint32_t hash_value) {
++  if (p_hash_table->p_lookup_table[hash_value] == NULL) {
++    return 0;
++  } else {
++    return (int32_t)(p_hash_table->p_lookup_table[hash_value]->size);
++  }
++}
++
++Iterator av1_hash_get_first_iterator(hash_table *p_hash_table,
++                                     uint32_t hash_value) {
++  assert(av1_hash_table_count(p_hash_table, hash_value) > 0);
++  return aom_vector_begin(p_hash_table->p_lookup_table[hash_value]);
++}
++
++int32_t av1_has_exact_match(hash_table *p_hash_table, uint32_t hash_value1,
++                            uint32_t hash_value2) {
++  if (p_hash_table->p_lookup_table[hash_value1] == NULL) {
++    return 0;
++  }
++  Iterator iterator =
++      aom_vector_begin(p_hash_table->p_lookup_table[hash_value1]);
++  Iterator last = aom_vector_end(p_hash_table->p_lookup_table[hash_value1]);
++  for (; !iterator_equals(&iterator, &last); iterator_increment(&iterator)) {
++    if ((*(block_hash *)iterator_get(&iterator)).hash_value2 == hash_value2) {
++      return 1;
++    }
++  }
++  return 0;
++}
++
++void av1_generate_block_2x2_hash_value(const Yv12BufferConfig *picture,
++                                       uint32_t *pic_block_hash[2],
++                                       int8_t *pic_block_same_info[3],
++                                       PictureControlSet_t * pcs) {
++  const int width = 2;
++  const int height = 2;
++  const int x_end = picture->y_crop_width - width + 1;
++  const int y_end = picture->y_crop_height - height + 1;
++
++  const int length = width * 2;
++  if (picture->flags & YV12_FLAG_HIGHBITDEPTH) {
++    uint16_t p[4];
++    int pos = 0;
++    for (int y_pos = 0; y_pos < y_end; y_pos++) {
++      for (int x_pos = 0; x_pos < x_end; x_pos++) {
++        get_pixels_in_1D_short_array_by_block_2x2(
++            CONVERT_TO_SHORTPTR(picture->y_buffer) + y_pos * picture->y_stride +
++                x_pos,
++            picture->y_stride, p);
++        pic_block_same_info[0][pos] = is_block16_2x2_row_same_value(p);
++        pic_block_same_info[1][pos] = is_block16_2x2_col_same_value(p);
++
++        pic_block_hash[0][pos] = av1_get_crc_value(
++            &pcs->crc_calculator1, (uint8_t *)p, length * sizeof(p[0]));
++        pic_block_hash[1][pos] = av1_get_crc_value(
++            &pcs->crc_calculator2, (uint8_t *)p, length * sizeof(p[0]));
++        pos++;
++      }
++      pos += width - 1;
++    }
++  } else {
++    uint8_t p[4];
++    int pos = 0;
++    for (int y_pos = 0; y_pos < y_end; y_pos++) {
++      for (int x_pos = 0; x_pos < x_end; x_pos++) {
++        get_pixels_in_1D_char_array_by_block_2x2(
++            picture->y_buffer + y_pos * picture->y_stride + x_pos,
++            picture->y_stride, p);
++        pic_block_same_info[0][pos] = is_block_2x2_row_same_value(p);
++        pic_block_same_info[1][pos] = is_block_2x2_col_same_value(p);
++
++        pic_block_hash[0][pos] =
++            av1_get_crc_value(&pcs->crc_calculator1, p, length * sizeof(p[0]));
++        pic_block_hash[1][pos] =
++            av1_get_crc_value(&pcs->crc_calculator2, p, length * sizeof(p[0]));
++        pos++;
++      }
++      pos += width - 1;
++    }
++  }
++}
++
++void av1_generate_block_hash_value(const Yv12BufferConfig *picture,
++                                   int block_size,
++                                   uint32_t *src_pic_block_hash[2],
++                                   uint32_t *dst_pic_block_hash[2],
++                                   int8_t *src_pic_block_same_info[3],
++                                   int8_t *dst_pic_block_same_info[3],
++                                   PictureControlSet_t * pcs  ) {
++  const int pic_width = picture->y_crop_width;
++  const int x_end = picture->y_crop_width - block_size + 1;
++  const int y_end = picture->y_crop_height - block_size + 1;
++
++  const int src_size = block_size >> 1;
++  const int quad_size = block_size >> 2;
++
++  uint32_t p[4];
++  const int length = sizeof(p);
++
++  int pos = 0;
++  for (int y_pos = 0; y_pos < y_end; y_pos++) {
++    for (int x_pos = 0; x_pos < x_end; x_pos++) {
++      p[0] = src_pic_block_hash[0][pos];
++      p[1] = src_pic_block_hash[0][pos + src_size];
++      p[2] = src_pic_block_hash[0][pos + src_size * pic_width];
++      p[3] = src_pic_block_hash[0][pos + src_size * pic_width + src_size];
++      dst_pic_block_hash[0][pos] =
++          av1_get_crc_value(&pcs->crc_calculator1, (uint8_t *)p, length);
++
++      p[0] = src_pic_block_hash[1][pos];
++      p[1] = src_pic_block_hash[1][pos + src_size];
++      p[2] = src_pic_block_hash[1][pos + src_size * pic_width];
++      p[3] = src_pic_block_hash[1][pos + src_size * pic_width + src_size];
++      dst_pic_block_hash[1][pos] =
++          av1_get_crc_value(&pcs->crc_calculator2, (uint8_t *)p, length);
++
++      dst_pic_block_same_info[0][pos] =
++          src_pic_block_same_info[0][pos] &&
++          src_pic_block_same_info[0][pos + quad_size] &&
++          src_pic_block_same_info[0][pos + src_size] &&
++          src_pic_block_same_info[0][pos + src_size * pic_width] &&
++          src_pic_block_same_info[0][pos + src_size * pic_width + quad_size] &&
++          src_pic_block_same_info[0][pos + src_size * pic_width + src_size];
++
++      dst_pic_block_same_info[1][pos] =
++          src_pic_block_same_info[1][pos] &&
++          src_pic_block_same_info[1][pos + src_size] &&
++          src_pic_block_same_info[1][pos + quad_size * pic_width] &&
++          src_pic_block_same_info[1][pos + quad_size * pic_width + src_size] &&
++          src_pic_block_same_info[1][pos + src_size * pic_width] &&
++          src_pic_block_same_info[1][pos + src_size * pic_width + src_size];
++      pos++;
++    }
++    pos += block_size - 1;
++  }
++
++  if (block_size >= 4) {
++    const int size_minus_1 = block_size - 1;
++    pos = 0;
++    for (int y_pos = 0; y_pos < y_end; y_pos++) {
++      for (int x_pos = 0; x_pos < x_end; x_pos++) {
++        dst_pic_block_same_info[2][pos] =
++            (!dst_pic_block_same_info[0][pos] &&
++             !dst_pic_block_same_info[1][pos]) ||
++            (((x_pos & size_minus_1) == 0) && ((y_pos & size_minus_1) == 0));
++        pos++;
++      }
++      pos += block_size - 1;
++    }
++  }
++}
++
++void av1_add_to_hash_map_by_row_with_precal_data(hash_table *p_hash_table,
++                                                 uint32_t *pic_hash[2],
++                                                 int8_t *pic_is_same,
++                                                 int pic_width, int pic_height,
++                                                 int block_size) {
++  const int x_end = pic_width - block_size + 1;
++  const int y_end = pic_height - block_size + 1;
++
++  const int8_t *src_is_added = pic_is_same;
++  const uint32_t *src_hash[2] = { pic_hash[0], pic_hash[1] };
++
++  int add_value = hash_block_size_to_index(block_size);
++  assert(add_value >= 0);
++  add_value <<= crc_bits;
++  const int crc_mask = (1 << crc_bits) - 1;
++
++  for (int x_pos = 0; x_pos < x_end; x_pos++) {
++    for (int y_pos = 0; y_pos < y_end; y_pos++) {
++      const int pos = y_pos * pic_width + x_pos;
++      // valid data
++      if (src_is_added[pos]) {
++        block_hash curr_block_hash;
++        curr_block_hash.x = x_pos;
++        curr_block_hash.y = y_pos;
++
++        const uint32_t hash_value1 = (src_hash[0][pos] & crc_mask) + add_value;
++        curr_block_hash.hash_value2 = src_hash[1][pos];
++
++        hash_table_add_to_table(p_hash_table, hash_value1, &curr_block_hash);
++      }
++    }
++  }
++}
++
++int av1_hash_is_horizontal_perfect(const Yv12BufferConfig *picture,
++                                   int block_size, int x_start, int y_start) {
++  const int stride = picture->y_stride;
++  const uint8_t *p = picture->y_buffer + y_start * stride + x_start;
++
++  if (picture->flags & YV12_FLAG_HIGHBITDEPTH) {
++    const uint16_t *p16 = CONVERT_TO_SHORTPTR(p);
++    for (int i = 0; i < block_size; i++) {
++      for (int j = 1; j < block_size; j++) {
++        if (p16[j] != p16[0]) {
++          return 0;
++        }
++      }
++      p16 += stride;
++    }
++  } else {
++    for (int i = 0; i < block_size; i++) {
++      for (int j = 1; j < block_size; j++) {
++        if (p[j] != p[0]) {
++          return 0;
++        }
++      }
++      p += stride;
++    }
++  }
++
++  return 1;
++}
++
++int av1_hash_is_vertical_perfect(const Yv12BufferConfig *picture,
++                                 int block_size, int x_start, int y_start) {
++  const int stride = picture->y_stride;
++  const uint8_t *p = picture->y_buffer + y_start * stride + x_start;
++
++  if (picture->flags & YV12_FLAG_HIGHBITDEPTH) {
++    const uint16_t *p16 = CONVERT_TO_SHORTPTR(p);
++    for (int i = 0; i < block_size; i++) {
++      for (int j = 1; j < block_size; j++) {
++        if (p16[j * stride + i] != p16[i]) {
++          return 0;
++        }
++      }
++    }
++  } else {
++    for (int i = 0; i < block_size; i++) {
++      for (int j = 1; j < block_size; j++) {
++        if (p[j * stride + i] != p[i]) {
++          return 0;
++        }
++      }
++    }
++  }
++  return 1;
++}
++
++void av1_get_block_hash_value(uint8_t *y_src, int stride, int block_size,
++                              uint32_t *hash_value1, uint32_t *hash_value2,
++                              int use_highbitdepth, struct PictureControlSet_s * pcs, IntraBcContext  *x) {
++  uint32_t to_hash[4];
++  const int add_value = hash_block_size_to_index(block_size) << crc_bits;
++  assert(add_value >= 0);
++  const int crc_mask = (1 << crc_bits) - 1;
++
++  // 2x2 subblock hash values in current CU
++  int sub_block_in_width = (block_size >> 1);
++  if (use_highbitdepth) {
++    uint16_t pixel_to_hash[4];
++    uint16_t *y16_src = CONVERT_TO_SHORTPTR(y_src);
++    for (int y_pos = 0; y_pos < block_size; y_pos += 2) {
++      for (int x_pos = 0; x_pos < block_size; x_pos += 2) {
++        int pos = (y_pos >> 1) * sub_block_in_width + (x_pos >> 1);
++        get_pixels_in_1D_short_array_by_block_2x2(
++            y16_src + y_pos * stride + x_pos, stride, pixel_to_hash);
++        assert(pos < AOM_BUFFER_SIZE_FOR_BLOCK_HASH);
++        x->hash_value_buffer[0][0][pos] =
++            av1_get_crc_value(&pcs->crc_calculator1, (uint8_t *)pixel_to_hash,
++                              sizeof(pixel_to_hash));
++        x->hash_value_buffer[1][0][pos] =
++            av1_get_crc_value(&pcs->crc_calculator2, (uint8_t *)pixel_to_hash,
++                              sizeof(pixel_to_hash));
++      }
++    }
++  } else {
++    uint8_t pixel_to_hash[4];
++    for (int y_pos = 0; y_pos < block_size; y_pos += 2) {
++      for (int x_pos = 0; x_pos < block_size; x_pos += 2) {
++        int pos = (y_pos >> 1) * sub_block_in_width + (x_pos >> 1);
++        get_pixels_in_1D_char_array_by_block_2x2(y_src + y_pos * stride + x_pos,
++                                                 stride, pixel_to_hash);
++        assert(pos < AOM_BUFFER_SIZE_FOR_BLOCK_HASH);
++        x->hash_value_buffer[0][0][pos] = av1_get_crc_value(
++            &pcs->crc_calculator1, pixel_to_hash, sizeof(pixel_to_hash));
++        x->hash_value_buffer[1][0][pos] = av1_get_crc_value(
++            &pcs->crc_calculator2, pixel_to_hash, sizeof(pixel_to_hash));
++      }
++    }
++  }
++
++  int src_sub_block_in_width = sub_block_in_width;
++  sub_block_in_width >>= 1;
++
++  int src_idx = 1;
++  int dst_idx = 0;
++
++  // 4x4 subblock hash values to current block hash values
++  for (int sub_width = 4; sub_width <= block_size; sub_width *= 2) {
++    src_idx = 1 - src_idx;
++    dst_idx = 1 - dst_idx;
++
++    int dst_pos = 0;
++    for (int y_pos = 0; y_pos < sub_block_in_width; y_pos++) {
++      for (int x_pos = 0; x_pos < sub_block_in_width; x_pos++) {
++        int srcPos = (y_pos << 1) * src_sub_block_in_width + (x_pos << 1);
++
++        assert(srcPos + 1 < AOM_BUFFER_SIZE_FOR_BLOCK_HASH);
++        assert(srcPos + src_sub_block_in_width + 1 <
++               AOM_BUFFER_SIZE_FOR_BLOCK_HASH);
++        assert(dst_pos < AOM_BUFFER_SIZE_FOR_BLOCK_HASH);
++        to_hash[0] = x->hash_value_buffer[0][src_idx][srcPos];
++        to_hash[1] = x->hash_value_buffer[0][src_idx][srcPos + 1];
++        to_hash[2] =
++            x->hash_value_buffer[0][src_idx][srcPos + src_sub_block_in_width];
++        to_hash[3] = x->hash_value_buffer[0][src_idx]
++                                         [srcPos + src_sub_block_in_width + 1];
++
++        x->hash_value_buffer[0][dst_idx][dst_pos] = av1_get_crc_value(
++            &pcs->crc_calculator1, (uint8_t *)to_hash, sizeof(to_hash));
++
++        to_hash[0] = x->hash_value_buffer[1][src_idx][srcPos];
++        to_hash[1] = x->hash_value_buffer[1][src_idx][srcPos + 1];
++        to_hash[2] =
++            x->hash_value_buffer[1][src_idx][srcPos + src_sub_block_in_width];
++        to_hash[3] = x->hash_value_buffer[1][src_idx]
++                                         [srcPos + src_sub_block_in_width + 1];
++        x->hash_value_buffer[1][dst_idx][dst_pos] = av1_get_crc_value(
++            &pcs->crc_calculator2, (uint8_t *)to_hash, sizeof(to_hash));
++        dst_pos++;
++      }
++    }
++
++    src_sub_block_in_width = sub_block_in_width;
++    sub_block_in_width >>= 1;
++  }
++
++  *hash_value1 = (x->hash_value_buffer[0][dst_idx][0] & crc_mask) + add_value;
++  *hash_value2 = x->hash_value_buffer[1][dst_idx][0];
++}
++#endif
+\ No newline at end of file
+diff --git a/Source/Lib/Codec/hash_motion.h b/Source/Lib/Codec/hash_motion.h
+new file mode 100644
+index 0000000..b8d5dee
+--- /dev/null
++++ b/Source/Lib/Codec/hash_motion.h
+@@ -0,0 +1,84 @@
++/*
++ * Copyright (c) 2016, Alliance for Open Media. All rights reserved
++ *
++ * This source code is subject to the terms of the BSD 2 Clause License and
++ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
++ * was not distributed with this source code in the LICENSE file, you can
++ * obtain it at www.aomedia.org/license/software. If the Alliance for Open
++ * Media Patent License 1.0 was not distributed with this source code in the
++ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
++ */
++
++#ifndef AOM_AV1_ENCODER_HASH_MOTION_H_
++#define AOM_AV1_ENCODER_HASH_MOTION_H_
++
++//#include "config/aom_config.h"
++
++//#include "aom/aom_integer.h"
++//#include "aom_scale/yv12config.h"
++#include "EbDefinitions.h"
++#include "EbCodingUnit.h"
++#include "vector.h"
++#include "EbPictureBufferDesc.h"
++
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++// store a block's hash info.
++// x and y are the position from the top left of the picture
++// hash_value2 is used to store the second hash value
++typedef struct _block_hash {
++  int16_t x;
++  int16_t y;
++  uint32_t hash_value2;
++} block_hash;
++
++typedef struct _hash_table {
++  Vector **p_lookup_table;
++} hash_table;
++
++void av1_hash_table_init(hash_table *p_hash_table, struct Macroblock *x);
++void av1_hash_table_destroy(hash_table *p_hash_table);
++EbErrorType  av1_hash_table_create(hash_table *p_hash_table);
++int32_t av1_hash_table_count(const hash_table *p_hash_table,
++                             uint32_t hash_value);
++Iterator av1_hash_get_first_iterator(hash_table *p_hash_table,
++                                     uint32_t hash_value);
++int32_t av1_has_exact_match(hash_table *p_hash_table, uint32_t hash_value1,
++                            uint32_t hash_value2);
++void av1_generate_block_2x2_hash_value(const Yv12BufferConfig *picture,
++                                       uint32_t *pic_block_hash[2],
++                                       int8_t *pic_block_same_info[3],
++                                      struct PictureControlSet_s * pcs);
++void av1_generate_block_hash_value(const Yv12BufferConfig *picture,
++                                   int block_size,
++                                   uint32_t *src_pic_block_hash[2],
++                                   uint32_t *dst_pic_block_hash[2],
++                                   int8_t *src_pic_block_same_info[3],
++                                   int8_t *dst_pic_block_same_info[3],
++                                   struct PictureControlSet_s * pcs);
++void av1_add_to_hash_map_by_row_with_precal_data(hash_table *p_hash_table,
++                                                 uint32_t *pic_hash[2],
++                                                 int8_t *pic_is_same,
++                                                 int pic_width, int pic_height,
++                                                 int block_size);
++
++// check whether the block starts from (x_start, y_start) with the size of
++// block_size x block_size has the same color in all rows
++int av1_hash_is_horizontal_perfect(const Yv12BufferConfig *picture,
++                                   int block_size, int x_start, int y_start);
++// check whether the block starts from (x_start, y_start) with the size of
++// block_size x block_size has the same color in all columns
++int av1_hash_is_vertical_perfect(const Yv12BufferConfig *picture,
++                                 int block_size, int x_start, int y_start);
++void av1_get_block_hash_value(uint8_t *y_src, int stride, int block_size,
++                              uint32_t *hash_value1, uint32_t *hash_value2,
++                              int use_highbitdepth, struct PictureControlSet_s * pcs, struct IntraBcContext /*MACROBLOCK*/ *x);
++
++#ifdef __cplusplus
++}  // extern "C"
++#endif
++
++#endif  // AOM_AV1_ENCODER_HASH_MOTION_H_
+diff --git a/Source/Lib/Codec/vector.c b/Source/Lib/Codec/vector.c
+new file mode 100644
+index 0000000..7ecfab0
+--- /dev/null
++++ b/Source/Lib/Codec/vector.c
+@@ -0,0 +1,543 @@
++/*
++The MIT License(MIT)
++Copyright(c) 2016 Peter Goldsborough
++
++Permission is hereby granted, free of charge, to any person obtaining a copy of
++this software and associated documentation files(the "Software"), to deal in
++the Software without restriction, including without limitation the rights to
++use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
++the Software, and to permit persons to whom the Software is furnished to do so,
++subject to the following conditions :
++
++The above copyright notice and this permission notice shall be included in all
++copies or substantial portions of the Software.
++
++THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
++IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
++FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR
++COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
++IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
++CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
++*/
++
++#define __STDC_WANT_LIB_EXT1__ 1
++
++#include <assert.h>
++#include <stdlib.h>
++#include <string.h>
++
++#include "vector.h"
++#define MAX(a, b) ((a) > (b) ? (a) : (b))
++int aom_vector_setup(Vector *vector, size_t capacity, size_t element_size) {
++  assert(vector != NULL);
++
++  if (vector == NULL) return VECTOR_ERROR;
++
++  vector->size = 0;
++  vector->capacity = MAX(VECTOR_MINIMUM_CAPACITY, capacity);
++  vector->element_size = element_size;
++  vector->data = malloc(vector->capacity * element_size);
++
++  return vector->data == NULL ? VECTOR_ERROR : VECTOR_SUCCESS;
++}
++
++int aom_vector_copy(Vector *destination, Vector *source) {
++  assert(destination != NULL);
++  assert(source != NULL);
++  assert(aom_vector_is_initialized(source));
++  assert(!aom_vector_is_initialized(destination));
++
++  if (destination == NULL) return VECTOR_ERROR;
++  if (source == NULL) return VECTOR_ERROR;
++  if (aom_vector_is_initialized(destination)) return VECTOR_ERROR;
++  if (!aom_vector_is_initialized(source)) return VECTOR_ERROR;
++
++  /* Copy ALL the data */
++  destination->size = source->size;
++  destination->capacity = source->size * 2;
++  destination->element_size = source->element_size;
++
++  /* Note that we are not necessarily allocating the same capacity */
++  destination->data = malloc(destination->capacity * source->element_size);
++  if (destination->data == NULL) return VECTOR_ERROR;
++
++  memcpy(destination->data, source->data, aom_vector_byte_size(source));
++
++  return VECTOR_SUCCESS;
++}
++
++int aom_vector_copy_assign(Vector *destination, Vector *source) {
++  assert(destination != NULL);
++  assert(source != NULL);
++  assert(aom_vector_is_initialized(source));
++  assert(aom_vector_is_initialized(destination));
++
++  if (destination == NULL) return VECTOR_ERROR;
++  if (source == NULL) return VECTOR_ERROR;
++  if (!aom_vector_is_initialized(destination)) return VECTOR_ERROR;
++  if (!aom_vector_is_initialized(source)) return VECTOR_ERROR;
++
++  aom_vector_destroy(destination);
++
++  return aom_vector_copy(destination, source);
++}
++
++int aom_vector_move(Vector *destination, Vector *source) {
++  assert(destination != NULL);
++  assert(source != NULL);
++
++  if (destination == NULL) return VECTOR_ERROR;
++  if (source == NULL) return VECTOR_ERROR;
++
++  *destination = *source;
++  source->data = NULL;
++
++  return VECTOR_SUCCESS;
++}
++
++int aom_vector_move_assign(Vector *destination, Vector *source) {
++  aom_vector_swap(destination, source);
++  return aom_vector_destroy(source);
++}
++
++int aom_vector_swap(Vector *destination, Vector *source) {
++  void *temp;
++
++  assert(destination != NULL);
++  assert(source != NULL);
++  assert(aom_vector_is_initialized(source));
++  assert(aom_vector_is_initialized(destination));
++
++  if (destination == NULL) return VECTOR_ERROR;
++  if (source == NULL) return VECTOR_ERROR;
++  if (!aom_vector_is_initialized(destination)) return VECTOR_ERROR;
++  if (!aom_vector_is_initialized(source)) return VECTOR_ERROR;
++
++  _vector_swap(&destination->size, &source->size);
++  _vector_swap(&destination->capacity, &source->capacity);
++  _vector_swap(&destination->element_size, &source->element_size);
++
++  temp = destination->data;
++  destination->data = source->data;
++  source->data = temp;
++
++  return VECTOR_SUCCESS;
++}
++
++int aom_vector_destroy(Vector *vector) {
++  assert(vector != NULL);
++
++  if (vector == NULL) return VECTOR_ERROR;
++
++  free(vector->data);
++  vector->data = NULL;
++
++  return VECTOR_SUCCESS;
++}
++
++/* Insertion */
++int aom_vector_push_back(Vector *vector, void *element) {
++  assert(vector != NULL);
++  assert(element != NULL);
++
++  if (_vector_should_grow(vector)) {
++    if (_vector_adjust_capacity(vector) == VECTOR_ERROR) {
++      return VECTOR_ERROR;
++    }
++  }
++
++  _vector_assign(vector, vector->size, element);
++
++  ++vector->size;
++
++  return VECTOR_SUCCESS;
++}
++
++int aom_vector_push_front(Vector *vector, void *element) {
++  return aom_vector_insert(vector, 0, element);
++}
++
++int aom_vector_insert(Vector *vector, size_t index, void *element) {
++  void *offset;
++
++  assert(vector != NULL);
++  assert(element != NULL);
++  assert(index <= vector->size);
++
++  if (vector == NULL) return VECTOR_ERROR;
++  if (element == NULL) return VECTOR_ERROR;
++  if (vector->element_size == 0) return VECTOR_ERROR;
++  if (index > vector->size) return VECTOR_ERROR;
++
++  if (_vector_should_grow(vector)) {
++    if (_vector_adjust_capacity(vector) == VECTOR_ERROR) {
++      return VECTOR_ERROR;
++    }
++  }
++
++  /* Move other elements to the right */
++  if (_vector_move_right(vector, index) == VECTOR_ERROR) {
++    return VECTOR_ERROR;
++  }
++
++  /* Insert the element */
++  offset = _vector_offset(vector, index);
++  memcpy(offset, element, vector->element_size);
++  ++vector->size;
++
++  return VECTOR_SUCCESS;
++}
++
++int aom_vector_assign(Vector *vector, size_t index, void *element) {
++  assert(vector != NULL);
++  assert(element != NULL);
++  assert(index < vector->size);
++
++  if (vector == NULL) return VECTOR_ERROR;
++  if (element == NULL) return VECTOR_ERROR;
++  if (vector->element_size == 0) return VECTOR_ERROR;
++  if (index >= vector->size) return VECTOR_ERROR;
++
++  _vector_assign(vector, index, element);
++
++  return VECTOR_SUCCESS;
++}
++
++/* Deletion */
++int aom_vector_pop_back(Vector *vector) {
++  assert(vector != NULL);
++  assert(vector->size > 0);
++
++  if (vector == NULL) return VECTOR_ERROR;
++  if (vector->element_size == 0) return VECTOR_ERROR;
++
++  --vector->size;
++
++#ifndef VECTOR_NO_SHRINK
++  if (_vector_should_shrink(vector)) {
++    _vector_adjust_capacity(vector);
++  }
++#endif
++
++  return VECTOR_SUCCESS;
++}
++
++int aom_vector_pop_front(Vector *vector) { return aom_vector_erase(vector, 0); }
++
++int aom_vector_erase(Vector *vector, size_t index) {
++  assert(vector != NULL);
++  assert(index < vector->size);
++
++  if (vector == NULL) return VECTOR_ERROR;
++  if (vector->element_size == 0) return VECTOR_ERROR;
++  if (index >= vector->size) return VECTOR_ERROR;
++
++  /* Just overwrite */
++  _vector_move_left(vector, index);
++
++#ifndef VECTOR_NO_SHRINK
++  if (--vector->size == vector->capacity / 4) {
++    _vector_adjust_capacity(vector);
++  }
++#endif
++
++  return VECTOR_SUCCESS;
++}
++
++int aom_vector_clear(Vector *vector) { return aom_vector_resize(vector, 0); }
++
++/* Lookup */
++void *aom_vector_get(Vector *vector, size_t index) {
++  assert(vector != NULL);
++  assert(index < vector->size);
++
++  if (vector == NULL) return NULL;
++  if (vector->element_size == 0) return NULL;
++  if (index >= vector->size) return NULL;
++
++  return _vector_offset(vector, index);
++}
++
++const void *aom_vector_const_get(const Vector *vector, size_t index) {
++  assert(vector != NULL);
++  assert(index < vector->size);
++
++  if (vector == NULL) return NULL;
++  if (vector->element_size == 0) return NULL;
++  if (index >= vector->size) return NULL;
++
++  return _vector_const_offset(vector, index);
++}
++
++void *aom_vector_front(Vector *vector) { return aom_vector_get(vector, 0); }
++
++void *aom_vector_back(Vector *vector) {
++  return aom_vector_get(vector, vector->size - 1);
++}
++
++/* Information */
++
++bool aom_vector_is_initialized(const Vector *vector) {
++  return vector->data != NULL;
++}
++
++size_t aom_vector_byte_size(const Vector *vector) {
++  return vector->size * vector->element_size;
++}
++
++size_t aom_vector_free_space(const Vector *vector) {
++  return vector->capacity - vector->size;
++}
++
++bool aom_vector_is_empty(const Vector *vector) { return vector->size == 0; }
++
++/* Memory management */
++int aom_vector_resize(Vector *vector, size_t new_size) {
++  if (new_size <= vector->capacity * VECTOR_SHRINK_THRESHOLD) {
++    vector->size = new_size;
++    if (_vector_reallocate(vector, new_size * VECTOR_GROWTH_FACTOR) == -1) {
++      return VECTOR_ERROR;
++    }
++  } else if (new_size > vector->capacity) {
++    if (_vector_reallocate(vector, new_size * VECTOR_GROWTH_FACTOR) == -1) {
++      return VECTOR_ERROR;
++    }
++  }
++
++  vector->size = new_size;
++
++  return VECTOR_SUCCESS;
++}
++
++int aom_vector_reserve(Vector *vector, size_t minimum_capacity) {
++  if (minimum_capacity > vector->capacity) {
++    if (_vector_reallocate(vector, minimum_capacity) == VECTOR_ERROR) {
++      return VECTOR_ERROR;
++    }
++  }
++
++  return VECTOR_SUCCESS;
++}
++
++int aom_vector_shrink_to_fit(Vector *vector) {
++  return _vector_reallocate(vector, vector->size);
++}
++
++/* Iterators */
++Iterator aom_vector_begin(Vector *vector) { return aom_vector_iterator(vector, 0); }
++
++Iterator aom_vector_end(Vector *vector) {
++  return aom_vector_iterator(vector, vector->size);
++}
++
++Iterator aom_vector_iterator(Vector *vector, size_t index) {
++  Iterator iterator = { NULL, 0 };
++
++  assert(vector != NULL);
++  assert(index <= vector->size);
++
++  if (vector == NULL) return iterator;
++  if (index > vector->size) return iterator;
++  if (vector->element_size == 0) return iterator;
++
++  iterator.pointer = _vector_offset(vector, index);
++  iterator.element_size = vector->element_size;
++
++  return iterator;
++}
++
++void *iterator_get(Iterator *iterator) { return iterator->pointer; }
++
++int iterator_erase(Vector *vector, Iterator *iterator) {
++  size_t index = iterator_index(vector, iterator);
++
++  if (aom_vector_erase(vector, index) == VECTOR_ERROR) {
++    return VECTOR_ERROR;
++  }
++
++  *iterator = aom_vector_iterator(vector, index);
++
++  return VECTOR_SUCCESS;
++}
++
++void iterator_increment(Iterator *iterator) {
++  assert(iterator != NULL);
++  // iterator->pointer += iterator->element_size;
++  iterator->pointer =
++      (unsigned char *)iterator->pointer + iterator->element_size;
++}
++
++void iterator_decrement(Iterator *iterator) {
++  assert(iterator != NULL);
++  // iterator->pointer -= iterator->element_size;
++  iterator->pointer =
++      (unsigned char *)iterator->pointer - iterator->element_size;
++}
++
++void *iterator_next(Iterator *iterator) {
++  void *current = iterator->pointer;
++  iterator_increment(iterator);
++
++  return current;
++}
++
++void *iterator_previous(Iterator *iterator) {
++  void *current = iterator->pointer;
++  iterator_decrement(iterator);
++
++  return current;
++}
++
++bool iterator_equals(Iterator *first, Iterator *second) {
++  assert(first->element_size == second->element_size);
++  return first->pointer == second->pointer;
++}
++
++bool iterator_is_before(Iterator *first, Iterator *second) {
++  assert(first->element_size == second->element_size);
++  return first->pointer < second->pointer;
++}
++
++bool iterator_is_after(Iterator *first, Iterator *second) {
++  assert(first->element_size == second->element_size);
++  return first->pointer > second->pointer;
++}
++
++size_t iterator_index(Vector *vector, Iterator *iterator) {
++  assert(vector != NULL);
++  assert(iterator != NULL);
++  // return (iterator->pointer - vector->data) / vector->element_size;
++  return ((unsigned char *)iterator->pointer - (unsigned char *)vector->data) /
++         vector->element_size;
++}
++
++/***** PRIVATE *****/
++
++bool _vector_should_grow(Vector *vector) {
++  assert(vector->size <= vector->capacity);
++  return vector->size == vector->capacity;
++}
++
++bool _vector_should_shrink(Vector *vector) {
++  assert(vector->size <= vector->capacity);
++  return vector->size == vector->capacity * VECTOR_SHRINK_THRESHOLD;
++}
++
++size_t _vector_free_bytes(const Vector *vector) {
++  return aom_vector_free_space(vector) * vector->element_size;
++}
++
++void *_vector_offset(Vector *vector, size_t index) {
++  // return vector->data + (index * vector->element_size);
++  return (unsigned char *)vector->data + (index * vector->element_size);
++}
++
++const void *_vector_const_offset(const Vector *vector, size_t index) {
++  // return vector->data + (index * vector->element_size);
++  return (unsigned char *)vector->data + (index * vector->element_size);
++}
++
++void _vector_assign(Vector *vector, size_t index, void *element) {
++  /* Insert the element */
++  void *offset = _vector_offset(vector, index);
++  memcpy(offset, element, vector->element_size);
++}
++
++int _vector_move_right(Vector *vector, size_t index) {
++  assert(vector->size < vector->capacity);
++
++  /* The location where to start to move from. */
++  void *offset = _vector_offset(vector, index);
++
++  /* How many to move to the right. */
++  size_t elements_in_bytes = (vector->size - index) * vector->element_size;
++
++#ifdef __STDC_LIB_EXT1__
++  size_t right_capacity_in_bytes =
++      (vector->capacity - (index + 1)) * vector->element_size;
++
++  /* clang-format off */
++    int return_code =  memmove_s(
++        offset + vector->element_size,
++        right_capacity_in_bytes,
++        offset,
++        elements_in_bytes);
++
++  /* clang-format on */
++
++  return return_code == 0 ? VECTOR_SUCCESS : VECTOR_ERROR;
++
++#else
++  // memmove(offset + vector->element_size, offset, elements_in_bytes);
++  memmove((unsigned char *)offset + vector->element_size, offset,
++          elements_in_bytes);
++  return VECTOR_SUCCESS;
++#endif
++}
++
++void _vector_move_left(Vector *vector, size_t index) {
++  size_t right_elements_in_bytes;
++  void *offset;
++
++  /* The offset into the memory */
++  offset = _vector_offset(vector, index);
++
++  /* How many to move to the left */
++  right_elements_in_bytes = (vector->size - index - 1) * vector->element_size;
++
++  // memmove(offset, offset + vector->element_size, right_elements_in_bytes);
++  memmove(offset, (unsigned char *)offset + vector->element_size,
++          right_elements_in_bytes);
++}
++
++int _vector_adjust_capacity(Vector *vector) {
++  return _vector_reallocate(vector,
++                            MAX(1, vector->size * VECTOR_GROWTH_FACTOR));
++}
++
++int _vector_reallocate(Vector *vector, size_t new_capacity) {
++  size_t new_capacity_in_bytes;
++  void *old;
++  assert(vector != NULL);
++
++  if (new_capacity < VECTOR_MINIMUM_CAPACITY) {
++    if (vector->capacity > VECTOR_MINIMUM_CAPACITY) {
++      new_capacity = VECTOR_MINIMUM_CAPACITY;
++    } else {
++      /* NO-OP */
++      return VECTOR_SUCCESS;
++    }
++  }
++
++  new_capacity_in_bytes = new_capacity * vector->element_size;
++  old = vector->data;
++
++  if ((vector->data = malloc(new_capacity_in_bytes)) == NULL) {
++    return VECTOR_ERROR;
++  }
++
++#ifdef __STDC_LIB_EXT1__
++  /* clang-format off */
++    if (memcpy_s(vector->data,
++                             new_capacity_in_bytes,
++                             old,
++                             aom_vector_byte_size(vector)) != 0) {
++        return VECTOR_ERROR;
++    }
++/* clang-format on */
++#else
++  memcpy(vector->data, old, aom_vector_byte_size(vector));
++#endif
++
++  vector->capacity = new_capacity;
++
++  free(old);
++
++  return VECTOR_SUCCESS;
++}
++
++void _vector_swap(size_t *first, size_t *second) {
++  size_t temp = *first;
++  *first = *second;
++  *second = temp;
++}
+diff --git a/Source/Lib/Codec/vector.h b/Source/Lib/Codec/vector.h
+new file mode 100644
+index 0000000..9ef1c60
+--- /dev/null
++++ b/Source/Lib/Codec/vector.h
+@@ -0,0 +1,159 @@
++/*
++The MIT License(MIT)
++Copyright(c) 2016 Peter Goldsborough
++
++Permission is hereby granted, free of charge, to any person obtaining a copy of
++this software and associated documentation files(the "Software"), to deal in
++the Software without restriction, including without limitation the rights to
++use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
++the Software, and to permit persons to whom the Software is furnished to do so,
++subject to the following conditions :
++
++The above copyright notice and this permission notice shall be included in all
++copies or substantial portions of the Software.
++
++THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
++IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
++FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR
++COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
++IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
++CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
++*/
++
++#ifndef VECTOR_H
++#define VECTOR_H
++
++#include <stdbool.h>
++#include <stddef.h>
++
++/***** DEFINITIONS *****/
++
++#define VECTOR_MINIMUM_CAPACITY 2
++#define VECTOR_GROWTH_FACTOR 2
++#define VECTOR_SHRINK_THRESHOLD (1 / 4)
++
++#define VECTOR_ERROR -1
++#define VECTOR_SUCCESS 0
++
++#define VECTOR_UNINITIALIZED NULL
++#define VECTOR_INITIALIZER \
++  { 0, 0, 0, VECTOR_UNINITIALIZED }
++
++/***** STRUCTURES *****/
++
++typedef struct Vector {
++  size_t size;
++  size_t capacity;
++  size_t element_size;
++
++  void *data;
++} Vector;
++
++typedef struct Iterator {
++  void *pointer;
++  size_t element_size;
++} Iterator;
++
++/***** METHODS *****/
++
++/* Constructor */
++int aom_vector_setup(Vector *vector, size_t capacity, size_t element_size);
++
++/* Copy Constructor */
++int aom_vector_copy(Vector *destination, Vector *source);
++
++/* Copy Assignment */
++int aom_vector_copy_assign(Vector *destination, Vector *source);
++
++/* Move Constructor */
++int aom_vector_move(Vector *destination, Vector *source);
++
++/* Move Assignment */
++int aom_vector_move_assign(Vector *destination, Vector *source);
++
++int aom_vector_swap(Vector *destination, Vector *source);
++
++/* Destructor */
++int aom_vector_destroy(Vector *vector);
++
++/* Insertion */
++int aom_vector_push_back(Vector *vector, void *element);
++int aom_vector_push_front(Vector *vector, void *element);
++int aom_vector_insert(Vector *vector, size_t index, void *element);
++int aom_vector_assign(Vector *vector, size_t index, void *element);
++
++/* Deletion */
++int aom_vector_pop_back(Vector *vector);
++int aom_vector_pop_front(Vector *vector);
++int aom_vector_erase(Vector *vector, size_t index);
++int aom_vector_clear(Vector *vector);
++
++/* Lookup */
++void *aom_vector_get(Vector *vector, size_t index);
++const void *aom_vector_const_get(const Vector *vector, size_t index);
++void *aom_vector_front(Vector *vector);
++void *aom_vector_back(Vector *vector);
++#define VECTOR_GET_AS(type, aom_vector_pointer, index) \
++  *((type *)aom_vector_get((aom_vector_pointer), (index)))
++
++/* Information */
++bool aom_vector_is_initialized(const Vector *vector);
++size_t aom_vector_byte_size(const Vector *vector);
++size_t aom_vector_free_space(const Vector *vector);
++bool aom_vector_is_empty(const Vector *vector);
++
++/* Memory management */
++int aom_vector_resize(Vector *vector, size_t new_size);
++int aom_vector_reserve(Vector *vector, size_t minimum_capacity);
++int aom_vector_shrink_to_fit(Vector *vector);
++
++/* Iterators */
++Iterator aom_vector_begin(Vector *vector);
++Iterator aom_vector_end(Vector *vector);
++Iterator aom_vector_iterator(Vector *vector, size_t index);
++
++void *iterator_get(Iterator *iterator);
++#define ITERATOR_GET_AS(type, iterator) *((type *)iterator_get((iterator)))
++
++int iterator_erase(Vector *vector, Iterator *iterator);
++
++void iterator_increment(Iterator *iterator);
++void iterator_decrement(Iterator *iterator);
++
++void *iterator_next(Iterator *iterator);
++void *iterator_previous(Iterator *iterator);
++
++bool iterator_equals(Iterator *first, Iterator *second);
++bool iterator_is_before(Iterator *first, Iterator *second);
++bool iterator_is_after(Iterator *first, Iterator *second);
++
++size_t iterator_index(Vector *vector, Iterator *iterator);
++
++#define VECTOR_FOR_EACH(aom_vector_pointer, iterator_name)           \
++  for (Iterator(iterator_name) = aom_vector_begin((aom_vector_pointer)), \
++      end = aom_vector_end((aom_vector_pointer));                        \
++       !iterator_equals(&(iterator_name), &end);                 \
++       iterator_increment(&(iterator_name)))
++
++/***** PRIVATE *****/
++
++//#define MAX(a, b) ((a) > (b) ? (a) : (b))
++
++bool _vector_should_grow(Vector *vector);
++bool _vector_should_shrink(Vector *vector);
++
++size_t _vector_free_bytes(const Vector *vector);
++void *_vector_offset(Vector *vector, size_t index);
++const void *_vector_const_offset(const Vector *vector, size_t index);
++
++void _vector_assign(Vector *vector, size_t index, void *element);
++
++int _vector_move_right(Vector *vector, size_t index);
++void _vector_move_left(Vector *vector, size_t index);
++
++int _vector_adjust_capacity(Vector *vector);
++int _vector_reallocate(Vector *vector, size_t new_capacity);
++
++void _vector_swap(size_t *first, size_t *second);
++
++#endif /* VECTOR_H */
+-- 
+2.19.1.windows.1
+
diff --git a/Source/Lib/Codec/EbAdaptiveMotionVectorPrediction.c b/Source/Lib/Codec/EbAdaptiveMotionVectorPrediction.c
index d78c6e9..9b522bf 100644
--- a/Source/Lib/Codec/EbAdaptiveMotionVectorPrediction.c
+++ b/Source/Lib/Codec/EbAdaptiveMotionVectorPrediction.c
@@ -165,7 +165,11 @@ static INLINE PredictionMode compound_ref1_mode(PredictionMode mode) {
 
 
 /*static INLINE*/ int32_t is_inter_block(const MbModeInfo *mbmi) {
+#if ICOPY
+    return (mbmi->use_intrabc || (mbmi->ref_frame[0] > INTRA_FRAME));
+#else
     return /*is_intrabc_block(mbmi) ||*/ mbmi->ref_frame[0] > INTRA_FRAME;
+#endif
 }
 
 static int32_t have_newmv_in_inter_mode(PredictionMode mode) {
@@ -233,7 +237,11 @@ static MvReferenceFrame ref_frame_map[TOTAL_COMP_REFS][2] = {
     { ALTREF2_FRAME, ALTREF_FRAME }
 };
 
+#if ICOPY
+void clamp_mv(
+#else
 static void clamp_mv(
+#endif
     MV *mv,
     int32_t min_col,
     int32_t max_col,
@@ -1400,6 +1408,9 @@ void update_av1_mi_map(
 
 
                 }
+#if ICOPY
+                miPtr[miX + miY * mi_stride].mbmi.use_intrabc = cu_ptr->av1xd->use_intrabc;
+#endif
 
                 miPtr[miX + miY * mi_stride].mbmi.ref_frame[0] = rf[0];
                 miPtr[miX + miY * mi_stride].mbmi.ref_frame[1] = rf[1];
@@ -1472,7 +1483,9 @@ void update_mi_map(
 
                     miPtr[miX + miY * mi_stride].mbmi.sb_type = blk_geom->bsize;
                 }
-
+#if ICOPY
+                miPtr[miX + miY * mi_stride].mbmi.use_intrabc = cu_ptr->av1xd->use_intrabc;
+#endif
                 miPtr[miX + miY * mi_stride].mbmi.ref_frame[0] = rf[0];
                 miPtr[miX + miY * mi_stride].mbmi.ref_frame[1] = rf[1];
                 if (cu_ptr->prediction_unit_array->inter_pred_direction_index == UNI_PRED_LIST_0) {
@@ -2059,3 +2072,153 @@ void av1_count_overlappable_neighbors(
     cu_ptr->prediction_unit_array[0].overlappable_neighbors[1] =
         count_overlappable_nb_left(cm, xd, mi_row, MAX_SIGNED_VALUE);
 }
+
+#if ICOPY
+#define INTRABC_DELAY_PIXELS 256  //  Delay of 256 pixels
+#define INTRABC_DELAY_SB64  (INTRABC_DELAY_PIXELS / 64)
+
+void av1_find_ref_dv(IntMv *ref_dv, const TileInfo *const tile,
+    int mib_size, int mi_row, int mi_col) {
+    (void)mi_col;
+    if (mi_row - mib_size < tile->mi_row_start) {
+        ref_dv->as_mv.row = 0;
+        ref_dv->as_mv.col = -MI_SIZE * mib_size - INTRABC_DELAY_PIXELS;
+    }
+    else {
+        ref_dv->as_mv.row = -MI_SIZE * mib_size;
+        ref_dv->as_mv.col = 0;
+    }
+    ref_dv->as_mv.row *= 8;
+    ref_dv->as_mv.col *= 8;
+}
+
+int32_t is_chroma_reference(int32_t mi_row, int32_t mi_col, block_size bsize,
+    int32_t subsampling_x, int32_t subsampling_y);
+
+int av1_is_dv_valid(const MV dv,
+    const MacroBlockD *xd, int mi_row, int mi_col,
+    block_size bsize, int mib_size_log2) {
+    const int bw = block_size_wide[bsize];
+    const int bh = block_size_high[bsize];
+    const int SCALE_PX_TO_MV = 8;
+    // Disallow subpixel for now
+    // SUBPEL_MASK is not the correct scale
+    if (((dv.row & (SCALE_PX_TO_MV - 1)) || (dv.col & (SCALE_PX_TO_MV - 1))))
+        return 0;
+
+    const TileInfo *const tile = &xd->tile;
+    // Is the source top-left inside the current tile?
+    const int src_top_edge = mi_row * MI_SIZE * SCALE_PX_TO_MV + dv.row;
+    const int tile_top_edge = tile->mi_row_start * MI_SIZE * SCALE_PX_TO_MV;
+    if (src_top_edge < tile_top_edge) return 0;
+    const int src_left_edge = mi_col * MI_SIZE * SCALE_PX_TO_MV + dv.col;
+    const int tile_left_edge = tile->mi_col_start * MI_SIZE * SCALE_PX_TO_MV;
+    if (src_left_edge < tile_left_edge) return 0;
+    // Is the bottom right inside the current tile?
+    const int src_bottom_edge = (mi_row * MI_SIZE + bh) * SCALE_PX_TO_MV + dv.row;
+    const int tile_bottom_edge = tile->mi_row_end * MI_SIZE * SCALE_PX_TO_MV;
+    if (src_bottom_edge > tile_bottom_edge) return 0;
+    const int src_right_edge = (mi_col * MI_SIZE + bw) * SCALE_PX_TO_MV + dv.col;
+    const int tile_right_edge = tile->mi_col_end * MI_SIZE * SCALE_PX_TO_MV;
+    if (src_right_edge > tile_right_edge) return 0;
+
+    // Special case for sub 8x8 chroma cases, to prevent referring to chroma
+    // pixels outside current tile.
+    for (int plane = 1; plane < 3/* av1_num_planes(cm)*/; ++plane) {
+        //const struct macroblockd_plane *const pd = &xd->plane[plane];
+
+        if (is_chroma_reference(mi_row, mi_col, bsize, 1, 1/* pd->subsampling_x,
+            pd->subsampling_y*/)) {
+            if (bw < 8 /*&& pd->subsampling_x*/)
+                if (src_left_edge < tile_left_edge + 4 * SCALE_PX_TO_MV) return 0;
+            if (bh < 8/* && pd->subsampling_y*/)
+                if (src_top_edge < tile_top_edge + 4 * SCALE_PX_TO_MV) return 0;
+        }
+    }
+
+    // Is the bottom right within an already coded SB? Also consider additional
+    // constraints to facilitate HW decoder.
+    const int max_mib_size = 1 << mib_size_log2;
+    const int active_sb_row = mi_row >> mib_size_log2;
+    const int active_sb64_col = (mi_col * MI_SIZE) >> 6;
+    const int sb_size = max_mib_size * MI_SIZE;
+    const int src_sb_row = ((src_bottom_edge >> 3) - 1) / sb_size;
+    const int src_sb64_col = ((src_right_edge >> 3) - 1) >> 6;
+    const int total_sb64_per_row =
+        ((tile->mi_col_end - tile->mi_col_start - 1) >> 4) + 1;
+    const int active_sb64 = active_sb_row * total_sb64_per_row + active_sb64_col;
+    const int src_sb64 = src_sb_row * total_sb64_per_row + src_sb64_col;
+    if (src_sb64 >= active_sb64 - INTRABC_DELAY_SB64) return 0;
+
+    // Wavefront constraint: use only top left area of frame for reference.
+    const int gradient = 1 + INTRABC_DELAY_SB64 + (sb_size > 64);
+    const int wf_offset = gradient * (active_sb_row - src_sb_row);
+    if (src_sb_row > active_sb_row ||
+        src_sb64_col >= active_sb64_col - INTRABC_DELAY_SB64 + wf_offset)
+        return 0;
+
+    return 1;
+}
+
+IntMv av1_get_ref_mv_from_stack(int ref_idx,
+    const MvReferenceFrame *ref_frame,
+    int ref_mv_idx,
+    CandidateMv ref_mv_stack[][MAX_REF_MV_STACK_SIZE],
+    MacroBlockD * xd
+/*const MB_MODE_INFO_EXT *mbmi_ext*/) {
+
+    const int8_t ref_frame_type = av1_ref_frame_type(ref_frame);
+    const CandidateMv *curr_ref_mv_stack =
+        /*mbmi_ext->*/ref_mv_stack[ref_frame_type];
+    IntMv ref_mv;
+    ref_mv.as_int = INVALID_MV;
+
+    if (ref_frame[1] > INTRA_FRAME) {
+        if (ref_idx == 0) {
+            ref_mv = curr_ref_mv_stack[ref_mv_idx].this_mv;
+        }
+        else {
+            assert(ref_idx == 1);
+            ref_mv = curr_ref_mv_stack[ref_mv_idx].comp_mv;
+        }
+    }
+    else {
+        assert(ref_idx == 0);
+        if (ref_mv_idx < /*mbmi_ext->*/xd->ref_mv_count[ref_frame_type]) {
+            ref_mv = curr_ref_mv_stack[ref_mv_idx].this_mv;
+        }
+        else {
+            //CHKN got this from decoder read_intrabc_info global_mvs[ref_frame].as_int = INVALID_MV;
+            ref_mv.as_int = INVALID_MV;// mbmi_ext->global_mvs[ref_frame_type];
+        }
+    }
+    return ref_mv;
+}
+
+static INLINE void lower_mv_precision(MV *mv, int allow_hp, int is_integer) {
+    if (is_integer) {
+        integer_mv_precision(mv);
+    }
+    else {
+        if (!allow_hp) {
+            if (mv->row & 1) mv->row += (mv->row > 0 ? -1 : 1);
+            if (mv->col & 1) mv->col += (mv->col > 0 ? -1 : 1);
+        }
+    }
+}
+void av1_find_best_ref_mvs_from_stack(int allow_hp,
+    //const MB_MODE_INFO_EXT *mbmi_ext,
+    CandidateMv ref_mv_stack[][MAX_REF_MV_STACK_SIZE],
+    MacroBlockD * xd,
+    MvReferenceFrame ref_frame,
+    IntMv *nearest_mv, IntMv *near_mv,
+    int is_integer)
+{
+    const int ref_idx = 0;
+    MvReferenceFrame ref_frames[2] = { ref_frame, NONE_FRAME };
+    *nearest_mv = av1_get_ref_mv_from_stack(ref_idx, ref_frames, 0, ref_mv_stack/*mbmi_ext*/, xd);
+    lower_mv_precision(&nearest_mv->as_mv, allow_hp, is_integer);
+    *near_mv = av1_get_ref_mv_from_stack(ref_idx, ref_frames, 1, ref_mv_stack/*mbmi_ext*/, xd);
+    lower_mv_precision(&near_mv->as_mv, allow_hp, is_integer);
+}
+#endif
\ No newline at end of file
diff --git a/Source/Lib/Codec/EbAdaptiveMotionVectorPrediction.h b/Source/Lib/Codec/EbAdaptiveMotionVectorPrediction.h
index efc10fe..9233de7 100644
--- a/Source/Lib/Codec/EbAdaptiveMotionVectorPrediction.h
+++ b/Source/Lib/Codec/EbAdaptiveMotionVectorPrediction.h
@@ -151,6 +151,20 @@ extern "C" {
         int32_t                           mi_row,
         int32_t                           mi_col);
 
+#if ICOPY
+    void av1_find_best_ref_mvs_from_stack(int allow_hp,
+        CandidateMv ref_mv_stack[][MAX_REF_MV_STACK_SIZE],
+        MacroBlockD * xd,
+        MvReferenceFrame ref_frame,
+        IntMv *nearest_mv, IntMv *near_mv,
+        int is_integer);
+    void av1_find_ref_dv(IntMv *ref_dv, const TileInfo *const tile,
+        int mib_size, int mi_row, int mi_col);
+    int av1_is_dv_valid(const MV dv,
+        const MacroBlockD *xd, int mi_row, int mi_col,
+        block_size bsize, int mib_size_log2);
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/Source/Lib/Codec/EbCdefProcess.c b/Source/Lib/Codec/EbCdefProcess.c
index e7e1558..2306caa 100644
--- a/Source/Lib/Codec/EbCdefProcess.c
+++ b/Source/Lib/Codec/EbCdefProcess.c
@@ -593,7 +593,7 @@ void* cdef_kernel(void *input_ptr)
         }
         else {
 
-#if CDEF_REF_ONLY
+#if CDEF_REF_ONLY || ICOPY
             picture_control_set_ptr->parent_pcs_ptr->cdef_bits = 0;
             picture_control_set_ptr->parent_pcs_ptr->cdef_strengths[0] = 0;
             picture_control_set_ptr->parent_pcs_ptr->nb_cdef_strengths = 1;
diff --git a/Source/Lib/Codec/EbCodingLoop.c b/Source/Lib/Codec/EbCodingLoop.c
index ef62803..15529f1 100644
--- a/Source/Lib/Codec/EbCodingLoop.c
+++ b/Source/Lib/Codec/EbCodingLoop.c
@@ -3246,8 +3246,11 @@ EB_EXTERN void AV1EncodePass(
 #endif
 
                 if (cu_ptr->prediction_mode_flag == INTRA_MODE) {
-
+#if ICOPY
+                    context_ptr->is_inter = cu_ptr->av1xd->use_intrabc;
+#else
                     context_ptr->is_inter = 0;
+#endif
                     context_ptr->tot_intra_coded_area += blk_geom->bwidth* blk_geom->bheight;
                     if (picture_control_set_ptr->slice_type != I_SLICE) {
                         context_ptr->intra_coded_area_sb[tbAddr] += blk_geom->bwidth* blk_geom->bheight;
@@ -3279,10 +3282,88 @@ EB_EXTERN void AV1EncodePass(
 
                             uint32_t cu_originy_uv = (context_ptr->cu_origin_y >> 3 << 3) >> 1;
                             uint32_t cu_originx_uv = (context_ptr->cu_origin_x >> 3 << 3) >> 1;
-                            if (is16bit) {
-                                uint16_t    topNeighArray[64 * 2 + 1];
-                                uint16_t    leftNeighArray[64 * 2 + 1];
-                                PredictionMode mode;
+#if ICOPY
+                            if (cu_ptr->av1xd->use_intrabc)
+                            {
+                                MvReferenceFrame ref_frame = INTRA_FRAME;
+                                generate_av1_mvp_table(
+#if TILES
+                                    &sb_ptr->tile_info,
+#endif
+                                    context_ptr->md_context,
+                                    cu_ptr,
+                                    context_ptr->blk_geom,
+                                    context_ptr->cu_origin_x,
+                                    context_ptr->cu_origin_y,
+                                    &ref_frame,
+                                    1,
+                                    picture_control_set_ptr);
+
+                                IntMv nearestmv, nearmv;
+                                av1_find_best_ref_mvs_from_stack(0, context_ptr->md_context->md_local_cu_unit[blk_geom->blkidx_mds].ed_ref_mv_stack, cu_ptr->av1xd, ref_frame, &nearestmv, &nearmv,
+                                    0);
+
+                                if (nearestmv.as_int == INVALID_MV) {
+                                    nearestmv.as_int = 0;
+                                }
+                                if (nearmv.as_int == INVALID_MV) {
+                                    nearmv.as_int = 0;
+                                }
+
+                                IntMv dv_ref = nearestmv.as_int == 0 ? nearmv : nearestmv;
+                                if (dv_ref.as_int == 0)
+                                    av1_find_ref_dv(&dv_ref, &cu_ptr->av1xd->tile, sequence_control_set_ptr->mib_size, context_ptr->cu_origin_y >> MI_SIZE_LOG2, context_ptr->cu_origin_x >> MI_SIZE_LOG2);
+                                // Ref DV should not have sub-pel.
+                                assert((dv_ref.as_mv.col & 7) == 0);
+                                assert((dv_ref.as_mv.row & 7) == 0);
+                                context_ptr->md_context->md_local_cu_unit[blk_geom->blkidx_mds].ed_ref_mv_stack[INTRA_FRAME][0].this_mv = dv_ref;
+                                cu_ptr->predmv[0] = dv_ref;
+
+                                //keep final usefull mvp for entropy
+                                memcpy(cu_ptr->av1xd->final_ref_mv_stack,
+                                    context_ptr->md_context->md_local_cu_unit[context_ptr->blk_geom->blkidx_mds].ed_ref_mv_stack[cu_ptr->prediction_unit_array[0].ref_frame_type],
+                                    sizeof(CandidateMv)*MAX_REF_MV_STACK_SIZE);
+
+                                pu_ptr = cu_ptr->prediction_unit_array;
+                                // Set MvUnit
+                                context_ptr->mv_unit.predDirection = (uint8_t)pu_ptr->inter_pred_direction_index;
+                                context_ptr->mv_unit.mv[REF_LIST_0].mvUnion = pu_ptr->mv[REF_LIST_0].mvUnion;
+                                context_ptr->mv_unit.mv[REF_LIST_1].mvUnion = pu_ptr->mv[REF_LIST_1].mvUnion;
+
+                                EbPictureBufferDesc_t * ref_pic_list0 = ((EbReferenceObject_t*)picture_control_set_ptr->parent_pcs_ptr->reference_picture_wrapper_ptr->object_ptr)->referencePicture;
+
+                                av1_inter_prediction(
+                                    picture_control_set_ptr,
+                                    cu_ptr->interp_filters,
+                                    cu_ptr,
+                                    cu_ptr->prediction_unit_array->ref_frame_type,
+                                    &context_ptr->mv_unit,
+#if ICOPY
+                                    1,// use_intrabc,
+#endif
+                                    context_ptr->cu_origin_x,
+                                    context_ptr->cu_origin_y,
+                                    blk_geom->bwidth,
+                                    blk_geom->bheight,
+                                    ref_pic_list0,
+                                    0,
+                                    recon_buffer,
+                                    context_ptr->cu_origin_x,
+                                    context_ptr->cu_origin_y,
+#if CHROMA_BLIND
+                                    EB_TRUE,
+#endif
+                                    asm_type);
+
+
+                            }
+                            else
+                            {
+#endif
+                                if (is16bit) {
+                                    uint16_t    topNeighArray[64 * 2 + 1];
+                                    uint16_t    leftNeighArray[64 * 2 + 1];
+                                    PredictionMode mode;
 
                                 int32_t plane_end = blk_geom->has_uv ? 2 : 0;
 
@@ -3434,7 +3515,10 @@ EB_EXTERN void AV1EncodePass(
                                         0,  // MD ONLY - NOT USED BY ENCDEC
                                         0);
                                 }
+                                }
+#if ICOPY
                             }
+#endif
 
 #else
                             uint8_t    topNeighArray[64 * 2 + 1];
@@ -3766,6 +3850,9 @@ EB_EXTERN void AV1EncodePass(
                                     cu_ptr,
                                     cu_ptr->prediction_unit_array->ref_frame_type,
                                     &context_ptr->mv_unit,
+#if ICOPY
+                                    0,//use_intrabc,
+#endif
                                     context_ptr->cu_origin_x,
                                     context_ptr->cu_origin_y,
                                     blk_geom->bwidth,
diff --git a/Source/Lib/Codec/EbCodingUnit.h b/Source/Lib/Codec/EbCodingUnit.h
index 826b53c..380a721 100644
--- a/Source/Lib/Codec/EbCodingUnit.h
+++ b/Source/Lib/Codec/EbCodingUnit.h
@@ -14,6 +14,9 @@
 #include "EbPredictionUnit.h"
 #include "EbTransformUnit.h"
 #include "EbCabacContextModel.h"
+#if ICOPY
+#include "hash.h"
+#endif
 
 #ifdef __cplusplus
 extern "C" {
@@ -181,7 +184,11 @@ extern "C" {
         // Only for INTRA blocks
         UV_PredictionMode uv_mode;
         //PALETTE_MODE_INFO palette_mode_info;
+#if ICOPY
+        uint8_t use_intrabc;
+#else
         //uint8_t use_intrabc;
+#endif
         // Only for INTER blocks
         //InterpFilters interp_filters;
         MvReferenceFrame ref_frame[2];
@@ -239,6 +246,44 @@ extern "C" {
         int32_t tile_col;
 #endif
     } TileInfo;
+
+#if ICOPY
+    typedef struct macroblockd_plane {
+
+        int subsampling_x;
+        int subsampling_y;
+        struct buf_2d dst;
+        struct buf_2d pre[2];
+        // block size in pixels
+        uint8_t width, height;
+
+    } MACROBLOCKD_PLANE;
+
+    typedef struct macroblock_plane {
+#if 0
+        DECLARE_ALIGNED(16, int16_t, src_diff[MAX_SB_SQUARE]);
+        tran_low_t *qcoeff;
+        tran_low_t *coeff;
+        uint16_t *eobs;
+        uint8_t *txb_entropy_ctx;
+#endif
+        struct buf_2d src;
+#if 0
+        // Quantizer setings
+        // These are used/accessed only in the quantization process
+        // RDO does not / must not depend on any of these values
+        // All values below share the coefficient scale/shift used in TX
+        const int16_t *quant_fp_QTX;
+        const int16_t *round_fp_QTX;
+        const int16_t *quant_QTX;
+        const int16_t *quant_shift_QTX;
+        const int16_t *zbin_QTX;
+        const int16_t *round_QTX;
+        const int16_t *dequant_QTX;
+#endif
+    } MACROBLOCK_PLANE;
+#endif
+
     typedef struct MacroBlockD {
         // block dimension in the unit of mode_info.
         uint8_t n8_w, n8_h;
@@ -258,13 +303,50 @@ extern "C" {
         int32_t mb_to_top_edge;
         int32_t mb_to_bottom_edge;
         uint8_t neighbors_ref_counts[TOTAL_REFS_PER_FRAME];
+
+#if ICOPY 
+        uint8_t  use_intrabc;
+        MbModeInfo *above_mbmi;
+        MbModeInfo *left_mbmi;
+        MbModeInfo *chroma_above_mbmi;
+        MbModeInfo *chroma_left_mbmi;
+#endif
     } MacroBlockD;
+
     typedef struct Macroblock {
         int32_t rdmult;
         int32_t switchable_restore_cost[RESTORE_SWITCHABLE_TYPES];
         int32_t wiener_restore_cost[2];
         int32_t sgrproj_restore_cost[2];
     } Macroblock;
+
+#if ICOPY
+    typedef struct IntraBcContext {
+        int32_t rdmult;
+        struct macroblockd_plane xdplane[MAX_MB_PLANE];
+        struct macroblock_plane plane[MAX_MB_PLANE];
+        MvLimits mv_limits;
+        // The equivalend SAD error of one (whole) bit at the current quantizer
+       // for large blocks.
+        int sadperbit16;
+        // The equivalent error at the current rdmult of one whole bit (not one
+        // bitcost unit).
+        int errorperbit;
+        // Store the best motion vector during motion search
+        IntMv best_mv;
+        // Store the second best motion vector during full-pixel motion search
+        IntMv second_best_mv;
+        MacroBlockD * xd;
+        int* nmv_vec_cost;
+        int **mv_cost_stack;
+        // buffer for hash value calculation of a block
+        // used only in av1_get_block_hash_value()
+        // [first hash/second hash]
+        // [two buffers used ping-pong]
+        uint32_t *hash_value_buffer[2][2];
+    } IntraBcContext;
+#endif
+
     typedef struct CodingUnit_s
     {
         TransformUnit_t             transform_unit_array[TRANSFORM_UNIT_MAX_COUNT]; // 2-bytes * 21 = 42-bytes
diff --git a/Source/Lib/Codec/EbDefinitions.h b/Source/Lib/Codec/EbDefinitions.h
index 9e441ac..2d56a2b 100644
--- a/Source/Lib/Codec/EbDefinitions.h
+++ b/Source/Lib/Codec/EbDefinitions.h
@@ -184,6 +184,37 @@ extern "C" {
 #define CHROMA_BLIND_IF_SEARCH                          1
 #define OIS_BASED_INTRA                                 1
 
+#define ICOPY       0 //Intra Block Copy
+#define AOM_INTERP_EXTEND 4
+struct buf_2d {
+    uint8_t *buf;
+    uint8_t *buf0;
+    int width;
+    int height;
+    int stride;
+};
+typedef struct {
+    int col_min;
+    int col_max;
+    int row_min;
+    int row_max;
+} MvLimits;
+
+/*!\brief force enum to be unsigned 1 byte*/
+#define UENUM1BYTE(enumvar) \
+  ;                         \
+  typedef uint8_t enumvar
+
+enum {
+    DIAMOND = 0,
+    NSTEP = 1,
+    HEX = 2,
+    BIGDIA = 3,
+    SQUARE = 4,
+    FAST_HEX = 5,
+    FAST_DIAMOND = 6
+} UENUM1BYTE(SEARCH_METHODS);
+
 /********************************************************/
 /****************** Pre-defined Values ******************/
 /********************************************************/
diff --git a/Source/Lib/Codec/EbEncDecProcess.c b/Source/Lib/Codec/EbEncDecProcess.c
index c5834d1..389cd07 100644
--- a/Source/Lib/Codec/EbEncDecProcess.c
+++ b/Source/Lib/Codec/EbEncDecProcess.c
@@ -393,6 +393,9 @@ static void ResetEncDec(
 
         // Initial Rate Estimatimation of the Motion vectors
         av1_estimate_mv_rate(
+#if ICOPY
+            picture_control_set_ptr,
+#endif
             md_rate_estimation_array,
             &picture_control_set_ptr->coeff_est_entropy_coder_ptr->fc->nmvc);
 
diff --git a/Source/Lib/Codec/EbEncHandle.c b/Source/Lib/Codec/EbEncHandle.c
index 0ffb802..4f7dad4 100644
--- a/Source/Lib/Codec/EbEncHandle.c
+++ b/Source/Lib/Codec/EbEncHandle.c
@@ -410,6 +410,10 @@ void asmSetConvolveAsmTable(void);
 void asmSetConvolveHbdAsmTable(void);
 void init_intra_dc_predictors_c_internal(void);
 void init_intra_predictors_internal(void);
+#if ICOPY
+void av1_init_me_luts(void);
+#endif
+
 void SwitchToRealTime(){
 #if defined(__linux__) || defined(__APPLE__)
 
@@ -885,6 +889,10 @@ EbErrorType RestResultsCtor(
     return EB_ErrorNone;
 }
 #endif
+#if ICOPY
+void init_fn_ptr(void);
+#endif
+
 /**********************************
 * Initialize Encoder Library
 **********************************/
@@ -932,6 +940,10 @@ EB_API EbErrorType eb_init_encoder(EbComponentType *svt_enc_component)
 
     build_blk_geom(scs_init.sb_size == 128);
 
+#if ICOPY
+    av1_init_me_luts();
+    init_fn_ptr();
+#endif
 
     /************************************
     * Sequence Control Set
diff --git a/Source/Lib/Codec/EbEntropyCoding.c b/Source/Lib/Codec/EbEntropyCoding.c
index 5353b46..d941c25 100644
--- a/Source/Lib/Codec/EbEntropyCoding.c
+++ b/Source/Lib/Codec/EbEntropyCoding.c
@@ -478,7 +478,11 @@ void Av1WriteTxType(
     TxType                     txType,
     TxSize                      txSize) {
 
+#if ICOPY
+    const int32_t isInter = cu_ptr->av1xd->use_intrabc || (cu_ptr->prediction_mode_flag == INTER_MODE);
+#else
     const int32_t isInter = (cu_ptr->prediction_mode_flag == INTER_MODE);
+#endif
 
     const TxSize squareTxSize = txsize_sqr_map[txSize];
 
@@ -4035,8 +4039,12 @@ static void WriteUncompressedHeaderObu(SequenceControlSet_t *scsPtr/*AV1_COMP *c
         write_frame_size(pcsPtr, frame_size_override_flag, wb);
         //assert(av1_superres_unscaled(cm) ||
         //    !(cm->allow_intrabc && NO_FILTER_FOR_IBC));
+#if ICOPY
+        if (pcsPtr->allow_screen_content_tools)
+#else
         if (pcsPtr->allow_screen_content_tools &&
             0 /*(av1_superres_unscaled(cm) || !NO_FILTER_FOR_IBC)*/)
+#endif
             aom_wb_write_bit(wb, pcsPtr->allow_intrabc);
         // all eight fbs are refreshed, pick one that will live long enough
         pcsPtr->fb_of_context_type[REGULAR_FRAME] = 0;
@@ -4044,8 +4052,12 @@ static void WriteUncompressedHeaderObu(SequenceControlSet_t *scsPtr/*AV1_COMP *c
     else {
         if (pcsPtr->av1FrameType == INTRA_ONLY_FRAME) {
             write_frame_size(pcsPtr, frame_size_override_flag, wb);
+#if ICOPY
+            if (pcsPtr->allow_screen_content_tools)
+#else
             if (pcsPtr->allow_screen_content_tools &&
                 0 /*(av1_superres_unscaled(cm) || !NO_FILTER_FOR_IBC)*/)
+#endif
                 aom_wb_write_bit(wb, pcsPtr->allow_intrabc);
         }
         else if (pcsPtr->av1FrameType == INTER_FRAME || frame_is_sframe(pcsPtr)) {
@@ -5009,6 +5021,109 @@ EbErrorType ec_update_neighbors(
     return return_error;
 
 }
+#if ICOPY
+int32_t is_chroma_reference(int32_t mi_row, int32_t mi_col, block_size bsize,
+    int32_t subsampling_x, int32_t subsampling_y);
+
+static INLINE int av1_allow_palette(int allow_screen_content_tools,
+    block_size sb_type) {
+    return allow_screen_content_tools && block_size_wide[sb_type] <= 64 &&
+        block_size_high[sb_type] <= 64 && sb_type >= BLOCK_8X8;
+}
+
+static INLINE int av1_get_palette_bsize_ctx(block_size bsize) {
+    return num_pels_log2_lookup[bsize] - num_pels_log2_lookup[BLOCK_8X8];
+}
+static void write_palette_mode_info(
+    FRAME_CONTEXT           *ec_ctx,
+    CodingUnit_t            *cu_ptr,
+    block_size bsize,
+    int mi_row,
+    int mi_col, aom_writer *w)
+{
+    const uint32_t intra_luma_mode = cu_ptr->pred_mode;
+    uint32_t intra_chroma_mode = cu_ptr->prediction_unit_array->intra_chroma_mode;
+
+    const int num_planes = 3;// av1_num_planes(cm);
+    //const BLOCK_SIZE bsize = mbmi->sb_type;
+    //assert(av1_allow_palette(cm->allow_screen_content_tools, bsize));
+   // const PALETTE_MODE_INFO *const pmi = &mbmi->palette_mode_info;
+    const int bsize_ctx = av1_get_palette_bsize_ctx(bsize);
+
+    if (intra_luma_mode == DC_PRED) {
+        const int n = 0;// pmi->palette_size[0];
+        const int palette_y_mode_ctx = 0;// av1_get_palette_mode_ctx(xd);
+        aom_write_symbol(
+            w, n > 0,
+            ec_ctx->palette_y_mode_cdf[bsize_ctx][palette_y_mode_ctx], 2);
+        if (n > 0) {
+            //aom_write_symbol(w, n - PALETTE_MIN_SIZE,
+            //    xd->tile_ctx->palette_y_size_cdf[bsize_ctx],
+            //    PALETTE_SIZES);
+            //write_palette_colors_y(xd, pmi, cm->seq_params.bit_depth, w);
+        }
+    }
+
+    const int uv_dc_pred =
+        num_planes > 1 && intra_chroma_mode == UV_DC_PRED &&
+        is_chroma_reference(mi_row, mi_col, bsize, 1, 1);
+    if (uv_dc_pred) {
+        const int n = 0;// pmi->palette_size[1];
+        const int palette_uv_mode_ctx = 0;// (pmi->palette_size[0] > 0);
+        aom_write_symbol(w, n > 0,
+            ec_ctx->palette_uv_mode_cdf[palette_uv_mode_ctx], 2);
+        if (n > 0) {
+            /*           aom_write_symbol(w, n - PALETTE_MIN_SIZE,
+                           xd->tile_ctx->palette_uv_size_cdf[bsize_ctx],
+                           PALETTE_SIZES);
+                       write_palette_colors_uv(xd, pmi, cm->seq_params.bit_depth, w);*/
+        }
+    }
+}
+void av1_encode_dv(aom_writer *w, const MV *mv, const MV *ref,
+    nmv_context *mvctx) {
+    // DV and ref DV should not have sub-pel.
+    assert((mv->col & 7) == 0);
+    assert((mv->row & 7) == 0);
+    assert((ref->col & 7) == 0);
+    assert((ref->row & 7) == 0);
+    const MV diff = { mv->row - ref->row, mv->col - ref->col };
+    const MV_JOINT_TYPE j = av1_get_mv_joint((int32_t*)&diff);
+
+    aom_write_symbol(w, j, mvctx->joints_cdf, MV_JOINTS);
+    if (mv_joint_vertical(j))
+        encode_mv_component(w, diff.row, &mvctx->comps[0], MV_SUBPEL_NONE);
+
+    if (mv_joint_horizontal(j))
+        encode_mv_component(w, diff.col, &mvctx->comps[1], MV_SUBPEL_NONE);
+}
+
+int av1_allow_intrabc(const Av1Common *const cm) {
+
+    return (cm->p_pcs_ptr->slice_type == I_SLICE && cm->p_pcs_ptr->allow_screen_content_tools && cm->p_pcs_ptr->allow_intrabc);
+}
+
+static void write_intrabc_info(
+    FRAME_CONTEXT           *ec_ctx,
+    CodingUnit_t            *cu_ptr,
+    aom_writer *w) {
+
+
+    int use_intrabc = cu_ptr->av1xd->use_intrabc;
+    aom_write_symbol(w, use_intrabc, ec_ctx->intrabc_cdf, 2);
+    if (use_intrabc) {
+        //assert(mbmi->mode == DC_PRED);
+        //assert(mbmi->uv_mode == UV_DC_PRED);
+        //assert(mbmi->motion_mode == SIMPLE_TRANSLATION);
+        IntMv dv_ref = cu_ptr->predmv[0];// mbmi_ext->ref_mv_stack[INTRA_FRAME][0].this_mv;
+        MV mv;
+        mv.row = cu_ptr->prediction_unit_array[0].mv[INTRA_FRAME].y;
+        mv.col = cu_ptr->prediction_unit_array[0].mv[INTRA_FRAME].x;
+
+        av1_encode_dv(w, &mv, &dv_ref.as_mv, &ec_ctx->ndvc);
+    }
+}
+#endif
 
 EbErrorType write_modes_b(
     PictureControlSet_t     *picture_control_set_ptr,
@@ -5100,6 +5215,12 @@ EbErrorType write_modes_b(
             const uint32_t intra_luma_mode = cu_ptr->pred_mode;
             uint32_t intra_chroma_mode = cu_ptr->prediction_unit_array->intra_chroma_mode;
 
+#if ICOPY
+            if (av1_allow_intrabc(picture_control_set_ptr->parent_pcs_ptr->av1_cm))
+                write_intrabc_info(frameContext, cu_ptr, ecWriter);
+
+            if (cu_ptr->av1xd->use_intrabc == 0)
+#endif
             EncodeIntraLumaModeAv1(
                 frameContext,
                 ecWriter,
@@ -5119,15 +5240,28 @@ EbErrorType write_modes_b(
                 blk_geom->bheight,
                 NEIGHBOR_ARRAY_UNIT_TOP_AND_LEFT_ONLY_MASK);
 
+#if ICOPY
+            if (cu_ptr->av1xd->use_intrabc == 0)
+#endif
+                if (blk_geom->has_uv)
+                    EncodeIntraChromaModeAv1(
+                        frameContext,
+                        ecWriter,
+                        cu_ptr,
+                        intra_luma_mode,
+                        intra_chroma_mode,
+                        blk_geom->bwidth <= 32 && blk_geom->bheight <= 32);
 
-            if (blk_geom->has_uv)
-                EncodeIntraChromaModeAv1(
+#if ICOPY
+            if (cu_ptr->av1xd->use_intrabc == 0 && av1_allow_palette(picture_control_set_ptr->parent_pcs_ptr->allow_screen_content_tools, blk_geom->bsize))
+                write_palette_mode_info(
                     frameContext,
-                    ecWriter,
                     cu_ptr,
-                    intra_luma_mode,
-                    intra_chroma_mode,
-                    blk_geom->bwidth <= 32 && blk_geom->bheight <= 32);
+                    blk_geom->bsize,
+                    blkOriginY >> MI_SIZE_LOG2,
+                    blkOriginX >> MI_SIZE_LOG2,
+                    ecWriter);
+#endif
 
             if (!skipCoeff) {
                 Av1EncodeCoeff1D(
diff --git a/Source/Lib/Codec/EbFullLoop.c b/Source/Lib/Codec/EbFullLoop.c
index 66b3daf..4f50239 100644
--- a/Source/Lib/Codec/EbFullLoop.c
+++ b/Source/Lib/Codec/EbFullLoop.c
@@ -1149,7 +1149,11 @@ void ProductFullLoopTxSearch(
     uint64_t                       y_tu_coeff_bits;
     uint64_t                       tuFullDistortion[3][DIST_CALC_TOTAL];
     int32_t                        plane = 0;
+#if ICOPY
+    const int32_t                  is_inter = (candidateBuffer->candidate_ptr->type == INTER_MODE || candidateBuffer->candidate_ptr->use_intrabc) ? EB_TRUE : EB_FALSE;
+#else
     const int32_t                  is_inter = candidateBuffer->candidate_ptr->type == INTER_MODE ? EB_TRUE : EB_FALSE;//is_inter_block(mbmi);
+#endif
     uint64_t                       bestFullCost = UINT64_MAX;
     uint64_t                       y_full_cost = MAX_CU_COST;
     uint32_t                       yCountNonZeroCoeffsTemp;
diff --git a/Source/Lib/Codec/EbInterPrediction.c b/Source/Lib/Codec/EbInterPrediction.c
index fb2df56..9410d83 100644
--- a/Source/Lib/Codec/EbInterPrediction.c
+++ b/Source/Lib/Codec/EbInterPrediction.c
@@ -963,12 +963,50 @@ int32_t is_inter_block(const MbModeInfo *mbmi);
 block_size scale_chroma_bsize(block_size bsize, int32_t subsampling_x,
     int32_t subsampling_y);
 
+#if ICOPY
+// A special 2-tap bilinear filter for IntraBC chroma. IntraBC uses full pixel
+// MV for luma. If sub-sampling exists, chroma may possibly use half-pel MV.
+DECLARE_ALIGNED(256, static const int16_t, av1_intrabc_bilinear_filter[2]) = {
+  64,
+  64,
+};
+
+static const InterpFilterParams av1_intrabc_filter_params = {
+  av1_intrabc_bilinear_filter, 2, 0, BILINEAR
+};
+static void convolve_2d_for_intrabc(const uint8_t *src, int src_stride,
+    uint8_t *dst, int dst_stride, int w, int h,
+    int subpel_x_q4, int subpel_y_q4,
+    ConvolveParams *conv_params)
+{
+    const InterpFilterParams *filter_params_x =
+        subpel_x_q4 ? &av1_intrabc_filter_params : NULL;
+    const InterpFilterParams *filter_params_y =
+        subpel_y_q4 ? &av1_intrabc_filter_params : NULL;
+    if (subpel_x_q4 != 0 && subpel_y_q4 != 0) {
+        av1_convolve_2d_sr_c(src, src_stride, dst, dst_stride, w, h,
+            (InterpFilterParams *)filter_params_x, (InterpFilterParams *)filter_params_y, 0, 0, conv_params);
+    }
+    else if (subpel_x_q4 != 0) {
+        av1_convolve_x_sr_c(src, src_stride, dst, dst_stride, w, h, (InterpFilterParams *)filter_params_x,
+            (InterpFilterParams *)filter_params_y, 0, 0, conv_params);
+    }
+    else {
+        av1_convolve_y_sr_c(src, src_stride, dst, dst_stride, w, h, (InterpFilterParams *)filter_params_x,
+            (InterpFilterParams *)filter_params_y, 0, 0, conv_params);
+    }
+}
+#endif
+
 EbErrorType av1_inter_prediction(
     PictureControlSet_t                    *picture_control_set_ptr,
     uint32_t                                interp_filters,
     CodingUnit_t                           *cu_ptr,
     uint8_t                                 ref_frame_type,
     MvUnit_t                               *mv_unit,
+#if ICOPY
+    uint8_t                                  use_intrabc,
+#endif
     uint16_t                                pu_origin_x,
     uint16_t                                pu_origin_y,
     uint8_t                                 bwidth,
@@ -1041,6 +1079,9 @@ EbErrorType av1_inter_prediction(
             av1_set_ref_frame(rf, ref_frame_type);
             for (miY = 0; miY < (blk_geom->bheight >> MI_SIZE_LOG2); miY++) {
                 for (miX = 0; miX < (blk_geom->bwidth >> MI_SIZE_LOG2); miX++) {
+#if ICOPY
+                    miPtr[miX + miY * xd->mi_stride].mbmi.use_intrabc = use_intrabc;
+#endif
                     miPtr[miX + miY * xd->mi_stride].mbmi.ref_frame[0] = rf[0];
                     if (mv_unit->predDirection == UNI_PRED_LIST_0) {
                         miPtr[miX + miY * xd->mi_stride].mbmi.mv[0].as_mv.col = mv_unit->mv[REF_LIST_0].x;
@@ -1073,7 +1114,11 @@ EbErrorType av1_inter_prediction(
         sub8x8_inter = (block_size_wide[bsize] < 8 && ss_x) ||
             (block_size_high[bsize] < 8 && ss_y);
 
+#if ICOPY
+        if (use_intrabc) sub8x8_inter = 0;
+#else
         //if (is_intrabc) sub8x8_inter = 0;
+#endif
 
         // For sub8x8 chroma blocks, we may be covering more than one luma block's
         // worth of pixels. Thus (mi_x, mi_y) may not be the correct coordinates for
@@ -1272,6 +1317,12 @@ EbErrorType av1_inter_prediction(
             av1_get_convolve_filter_params(interp_filters, &filter_params_x,
                 &filter_params_y, blk_geom->bwidth_uv, blk_geom->bheight_uv);
 
+#if ICOPY 
+            if (use_intrabc && (subpel_x != 0 || subpel_y != 0))
+                convolve_2d_for_intrabc((const uint8_t *)src_ptr, src_stride, dst_ptr, dst_stride, blk_geom->bwidth_uv, blk_geom->bheight_uv, subpel_x,
+                    subpel_y, &conv_params);
+            else
+#endif
             convolve[subpel_x != 0][subpel_y != 0][is_compound](
                 src_ptr,
                 src_stride,
@@ -1297,6 +1348,13 @@ EbErrorType av1_inter_prediction(
             subpel_y = mv_q4.row & SUBPEL_MASK;
             src_ptr = src_ptr + (mv_q4.row >> SUBPEL_BITS) * src_stride + (mv_q4.col >> SUBPEL_BITS);
             conv_params = get_conv_params_no_round(0, 0, 0, tmp_dstCr, 64, is_compound, EB_8BIT);
+
+#if ICOPY 
+            if (use_intrabc && (subpel_x != 0 || subpel_y != 0))
+                convolve_2d_for_intrabc((const uint8_t *)src_ptr, src_stride, dst_ptr, dst_stride, blk_geom->bwidth_uv, blk_geom->bheight_uv, subpel_x,
+                    subpel_y, &conv_params);
+            else
+#endif
             convolve[subpel_x != 0][subpel_y != 0][is_compound](
                 src_ptr,
                 src_stride,
@@ -3576,6 +3634,9 @@ static const int32_t filter_sets[DUAL_FILTER_SET_SIZE][2] = {
         md_context_ptr->cu_ptr,
         candidate_buffer_ptr->candidate_ptr->ref_frame_type,
         &mv_unit,
+#if ICOPY
+        0,
+#endif
         md_context_ptr->cu_origin_x,
         md_context_ptr->cu_origin_y,
         md_context_ptr->blk_geom->bwidth,
@@ -3657,6 +3718,9 @@ static const int32_t filter_sets[DUAL_FILTER_SET_SIZE][2] = {
                         md_context_ptr->cu_ptr,
                         candidate_buffer_ptr->candidate_ptr->ref_frame_type,
                         &mv_unit,
+#if ICOPY
+                        0,
+#endif
                         md_context_ptr->cu_origin_x,
                         md_context_ptr->cu_origin_y,
                         md_context_ptr->blk_geom->bwidth,
@@ -3735,6 +3799,9 @@ static const int32_t filter_sets[DUAL_FILTER_SET_SIZE][2] = {
                         md_context_ptr->cu_ptr,
                         candidate_buffer_ptr->candidate_ptr->ref_frame_type,
                         &mv_unit,
+#if ICOPY
+                        0,
+#endif
                         md_context_ptr->cu_origin_x,
                         md_context_ptr->cu_origin_y,
                         md_context_ptr->blk_geom->bwidth,
@@ -3816,6 +3883,9 @@ static const int32_t filter_sets[DUAL_FILTER_SET_SIZE][2] = {
                         md_context_ptr->cu_ptr,
                         candidate_buffer_ptr->candidate_ptr->ref_frame_type,
                         &mv_unit,
+#if ICOPY
+                        0,
+#endif
                         md_context_ptr->cu_origin_x,
                         md_context_ptr->cu_origin_y,
                         md_context_ptr->blk_geom->bwidth,
@@ -4287,6 +4357,42 @@ EbErrorType inter_pu_prediction_av1(
     int32_t rs = 0;
     int64_t rd = INT64_MAX;
 
+#if ICOPY
+    if (candidate_buffer_ptr->candidate_ptr->use_intrabc)
+    {
+        if (is16bit) {
+            printf("ibc_need_10bit\n");
+            ref_pic_list0 = NULL;
+        }
+        else {
+            ref_pic_list0 = ((EbReferenceObject_t*)picture_control_set_ptr->parent_pcs_ptr->reference_picture_wrapper_ptr->object_ptr)->referencePicture;
+        }
+
+        av1_inter_prediction(
+            picture_control_set_ptr,
+            candidate_buffer_ptr->candidate_ptr->interp_filters,
+            md_context_ptr->cu_ptr,
+            candidate_buffer_ptr->candidate_ptr->ref_frame_type,
+            &mv_unit,
+            1,//use_intrabc
+            md_context_ptr->cu_origin_x,
+            md_context_ptr->cu_origin_y,
+            md_context_ptr->blk_geom->bwidth,
+            md_context_ptr->blk_geom->bheight,
+            ref_pic_list0,
+            0,//ref_pic_list1,
+            candidate_buffer_ptr->prediction_ptr,
+            md_context_ptr->blk_geom->origin_x,
+            md_context_ptr->blk_geom->origin_y,
+#if CHROMA_BLIND
+            md_context_ptr->chroma_level == CHROMA_MODE_0,
+#endif
+            asm_type);
+
+        return return_error;
+
+    }
+#endif
     if (is16bit) {
         ref_pic_list0 = ((EbReferenceObject_t*)picture_control_set_ptr->ref_pic_ptr_array[REF_LIST_0]->object_ptr)->referencePicture16bit;
         if (picture_control_set_ptr->slice_type == B_SLICE)
@@ -4414,6 +4520,9 @@ EbErrorType inter_pu_prediction_av1(
             md_context_ptr->cu_ptr,
             candidate_buffer_ptr->candidate_ptr->ref_frame_type,
             &mv_unit,
+#if ICOPY
+            candidate_buffer_ptr->candidate_ptr->use_intrabc,
+#endif
             md_context_ptr->cu_origin_x,
             md_context_ptr->cu_origin_y,
             md_context_ptr->blk_geom->bwidth,
diff --git a/Source/Lib/Codec/EbInterPrediction.h b/Source/Lib/Codec/EbInterPrediction.h
index 8f83714..14809fc 100644
--- a/Source/Lib/Codec/EbInterPrediction.h
+++ b/Source/Lib/Codec/EbInterPrediction.h
@@ -49,6 +49,9 @@ extern "C" {
         CodingUnit_t                           *cu_ptr,
         uint8_t                                 ref_frame_type,
         MvUnit_t                               *mv_unit,
+#if ICOPY
+        uint8_t                                  use_intrabc,
+#endif
         uint16_t                                pu_origin_x,
         uint16_t                                pu_origin_y,
         uint8_t                                 bwidth,
diff --git a/Source/Lib/Codec/EbIntraPrediction.c b/Source/Lib/Codec/EbIntraPrediction.c
index 59eae67..ae67c9b 100644
--- a/Source/Lib/Codec/EbIntraPrediction.c
+++ b/Source/Lib/Codec/EbIntraPrediction.c
@@ -29,6 +29,10 @@
 void *aom_memset16(void *dest, int32_t val, size_t length);
 #endif
 
+#if ICOPY
+int32_t is_inter_block(const MbModeInfo *mbmi);
+#endif
+
 // Some basic checks on weights for smooth predictor.
 #define sm_weights_sanity_checks(weights_w, weights_h, weights_scale, \
                                  pred_scale)                          \
@@ -162,7 +166,48 @@ EbErrorType IntraReference16bitSamplesCtor(
 }
 
 
+#if ICOPY
+static int is_smooth(const MbModeInfo *mbmi, int plane) {
+    if (plane == 0) {
+        const PredictionMode mode = mbmi->mode;
+        return (mode == SMOOTH_PRED || mode == SMOOTH_V_PRED ||
+            mode == SMOOTH_H_PRED);
+    }
+    else {
+        // uv_mode is not set for inter blocks, so need to explicitly
+        // detect that case.
+        if (is_inter_block(mbmi)) return 0;
+
+        const UV_PredictionMode uv_mode = mbmi->uv_mode;
+        return (uv_mode == UV_SMOOTH_PRED || uv_mode == UV_SMOOTH_V_PRED ||
+            uv_mode == UV_SMOOTH_H_PRED);
+    }
+}
+
+static int get_filt_type(const MacroBlockD *xd, int plane) {
+    int ab_sm, le_sm;
+
+    if (plane == 0) {
+        const MbModeInfo *ab = xd->above_mbmi;
+        const MbModeInfo *le = xd->left_mbmi;
+        ab_sm = ab ? is_smooth(ab, plane) : 0;
+        le_sm = le ? is_smooth(le, plane) : 0;
+    }
+    else {
+        const MbModeInfo *ab = xd->chroma_above_mbmi;
+        const MbModeInfo *le = xd->chroma_left_mbmi;
+        ab_sm = ab ? is_smooth(ab, plane) : 0;
+        le_sm = le ? is_smooth(le, plane) : 0;
+    }
+
+    return (ab_sm || le_sm) ? 1 : 0;
+}
+#else
 static int32_t is_smooth(PredictionMode modeIn, int32_t plane) {
+#if ICOPY
+    printf("add_intra_bc_support\n");
+#endif
+
     if (plane == 0) {
         const PredictionMode mode = modeIn;//mbmi->mode;
         return (mode == SMOOTH_PRED || mode == SMOOTH_V_PRED ||
@@ -197,6 +242,7 @@ static int32_t get_filt_type(PredictionMode left, PredictionMode top, int32_t pl
 
     return (ab_sm || le_sm) ? 1 : 0;
 }
+#endif
 
 
 static int32_t use_intra_edge_upsample(int32_t bs0, int32_t bs1, int32_t delta, int32_t type) {
@@ -8332,10 +8378,13 @@ static void build_intra_predictors_md(
 
             EbBool    neighborAvailableTop = (n_top_px == 0) ? EB_FALSE : // picture boundary check
                 EB_TRUE;
-
+#if ICOPY
+            const int32_t filt_type = get_filt_type(xd, plane);
+#else
             const int32_t filt_type = get_filt_type(neighborAvailableLeft ? (PredictionMode)intraLeftMode : D135_PRED,
                 neighborAvailableTop ? (PredictionMode)intraTopMode : D135_PRED,
                 0);
+#endif
 
             if (p_angle != 90 && p_angle != 180) {
                 const int32_t ab_le = need_above_left ? 1 : 0;
@@ -8936,9 +8985,13 @@ static void build_intra_predictors(
             EbBool    neighborAvailableTop = (n_top_px == 0) ? EB_FALSE : // picture boundary check
                 EB_TRUE;
 
+#if ICOPY
+            const int32_t filt_type = get_filt_type(xd, plane);
+#else
             const int32_t filt_type = get_filt_type(neighborAvailableLeft ? (PredictionMode)intraLeftMode : D135_PRED,
                 neighborAvailableTop ? (PredictionMode)intraTopMode : D135_PRED,
                 0);
+#endif
 
             if (p_angle != 90 && p_angle != 180) {
                 const int32_t ab_le = need_above_left ? 1 : 0;
@@ -9173,9 +9226,13 @@ static void build_intra_predictors_high(
                 EB_TRUE;
 
             //const int32_t filt_type = get_filt_type(xd, plane);
+#if ICOPY
+            const int32_t filt_type = get_filt_type(xd, plane);
+#else
             const int32_t filt_type = get_filt_type(neighborAvailableLeft ? (PredictionMode)intraLeftMode : D135_PRED,
                 neighborAvailableTop ? (PredictionMode)intraTopMode : D135_PRED,
                 0);
+#endif
             if (p_angle != 90 && p_angle != 180) {
                 const int32_t ab_le = need_above_left ? 1 : 0;
                 if (need_above && need_left && (txwpx + txhpx >= 24)) {
@@ -9577,6 +9634,54 @@ extern void av1_predict_intra_block(
         chroma_up_available = (mirow - 1) > 0;//tile->mi_row_start;
 #endif
 
+#if ICOPY
+   
+    int mi_stride = cm->mi_stride;
+    const int32_t offset = mirow * mi_stride + micol;
+    xd->mi = cm->pcs_ptr->mi_grid_base + offset;
+    ModeInfo *miPtr = *xd->mi;
+
+    if (xd->up_available) {
+       // xd->above_mbmi = xd->mi[-xd->mi_stride].mbmi;
+        xd->above_mbmi = &miPtr[-mi_stride].mbmi;
+    }
+    else {
+        xd->above_mbmi = NULL;
+    }
+
+    if (xd->left_available) {
+        //xd->left_mbmi = xd->mi[-1].mbmi;
+        xd->left_mbmi = &miPtr[-1].mbmi;
+    }
+    else {
+        xd->left_mbmi = NULL;
+    }
+
+
+    const int chroma_ref = ((mirow & 0x01) || !(bh & 0x01) || !ss_y) &&
+        ((micol & 0x01) || !(bw & 0x01) || !ss_x);
+    if (chroma_ref) {
+        // To help calculate the "above" and "left" chroma blocks, note that the
+        // current block may cover multiple luma blocks (eg, if partitioned into
+        // 4x4 luma blocks).
+        // First, find the top-left-most luma block covered by this chroma block   
+
+        ModeInfo *miPtr = xd->mi[-(mirow & ss_y) * mi_stride - (micol & ss_x)];
+
+        // Then, we consider the luma region covered by the left or above 4x4 chroma
+        // prediction. We want to point to the chroma reference block in that
+        // region, which is the bottom-right-most mi unit.
+        // This leads to the following offsets:
+        MbModeInfo *chroma_above_mi =
+            chroma_up_available ? &miPtr[-mi_stride + ss_x].mbmi : NULL;
+        xd->chroma_above_mbmi = chroma_above_mi;
+
+        MbModeInfo *chroma_left_mi =
+            chroma_left_available ? &miPtr[ss_y * mi_stride - 1].mbmi : NULL;
+        xd->chroma_left_mbmi = chroma_left_mi;
+    }
+
+#endif
 
     //CHKN  const MbModeInfo *const mbmi = xd->mi[0];
     const int32_t txwpx = tx_size_wide[tx_size];
diff --git a/Source/Lib/Codec/EbMdRateEstimation.c b/Source/Lib/Codec/EbMdRateEstimation.c
index 4e52d10..1926aa1 100644
--- a/Source/Lib/Codec/EbMdRateEstimation.c
+++ b/Source/Lib/Codec/EbMdRateEstimation.c
@@ -352,6 +352,9 @@ void av1_build_nmv_cost_table(int32_t *mvjoint, int32_t *mvcost[2],
 * based on the frame CDF
 ***************************************************************************/
 void av1_estimate_mv_rate(
+#if ICOPY
+    PictureControlSet_t     *picture_control_set_ptr,
+#endif
     MdRateEstimationContext_t  *md_rate_estimation_array,
     nmv_context                *nmv_ctx)
 {
@@ -374,7 +377,14 @@ void av1_estimate_mv_rate(
     md_rate_estimation_array->nmvcoststack[0] = &md_rate_estimation_array->nmv_costs[0][MV_MAX];
     md_rate_estimation_array->nmvcoststack[1] = &md_rate_estimation_array->nmv_costs[1][MV_MAX];
 
+#if ICOPY 
+    if (picture_control_set_ptr->parent_pcs_ptr->allow_intrabc) {
+        int32_t *dvcost[2] = { &md_rate_estimation_array->dv_cost[0][MV_MAX], &md_rate_estimation_array->dv_cost[1][MV_MAX] };
+        av1_build_nmv_cost_table(md_rate_estimation_array->dv_joint_cost, dvcost, &picture_control_set_ptr->coeff_est_entropy_coder_ptr->fc->ndvc,
+            MV_SUBPEL_NONE);
+    }
 
+#else
     // NM: To be added when adding the screen_content_tools
 
     /*if (frame_is_intra_only(cm) && cm->allow_screen_content_tools &&
@@ -383,6 +393,7 @@ void av1_estimate_mv_rate(
         av1_build_nmv_cost_table(cpi->dv_joint_cost, dvcost, &cm->fc->ndvc,
             MV_SUBPEL_NONE);
     }*/
+#endif
 }
 /**************************************************************************
 * av1_estimate_coefficients_rate()
diff --git a/Source/Lib/Codec/EbMdRateEstimation.h b/Source/Lib/Codec/EbMdRateEstimation.h
index bc58b0a..f6e1567 100644
--- a/Source/Lib/Codec/EbMdRateEstimation.h
+++ b/Source/Lib/Codec/EbMdRateEstimation.h
@@ -8,12 +8,19 @@
 
 #include "EbDefinitions.h"
 #include "EbCabacContextModel.h"
+#if ICOPY
+#include "EbPictureControlSet.h"
+#endif
 #ifdef __cplusplus
 extern "C" {
 #endif
     /**************************************
      * MD Rate Estimation Defines
      **************************************/
+#if ICOPY
+#define MV_COST_WEIGHT_SUB 120
+#endif
+
 #define TOTAL_NUMBER_OF_MD_RATE_ESTIMATION_CASE_BUFFERS (TOTAL_NUMBER_OF_QP_VALUES * TOTAL_NUMBER_OF_SLICE_TYPES)
 #define NUMBER_OF_SPLIT_FLAG_CASES                            6       // number of cases for bit estimation for split flag
 #define NUMBER_OF_MVD_CASES                                  12       // number of cases for bit estimation for motion vector difference
@@ -63,6 +70,10 @@ extern "C" {
         int32_t nmv_costs[2][MV_VALS];
         int32_t nmv_costs_hp[2][MV_VALS];
         int32_t *nmvcoststack[2];
+#if ICOPY
+        int dv_cost[2][MV_VALS];
+        int dv_joint_cost[MV_JOINTS];
+#endif
 
         // Compouned Mode
         int32_t interCompoundModeFacBits[INTER_MODE_CONTEXTS][CDF_SIZE(INTER_COMPOUND_MODES)];
@@ -315,6 +326,9 @@ extern "C" {
     * based on the frame CDF
     ***************************************************************************/
     extern void av1_estimate_mv_rate(
+#if ICOPY
+        struct PictureControlSet_s     *picture_control_set_ptr,
+#endif
         MdRateEstimationContext_t  *md_rate_estimation_array,
         nmv_context                *nmv_ctx);
 
diff --git a/Source/Lib/Codec/EbModeDecision.c b/Source/Lib/Codec/EbModeDecision.c
index 4fb1161..b8362f4 100644
--- a/Source/Lib/Codec/EbModeDecision.c
+++ b/Source/Lib/Codec/EbModeDecision.c
@@ -29,6 +29,11 @@
 #include "EbModeDecisionProcess.h"
 #include "EbMotionEstimation.h"
 
+#if ICOPY
+#include "av1me.h"
+#include "hash.h"
+#endif
+
 /********************************************
 * Constants
 ********************************************/
@@ -677,6 +682,9 @@ void Unipred3x3CandidatesInjection(
 #endif
 #else
             candidateArray[canTotalCnt].distortion_ready = 0;
+#endif
+#if ICOPY
+            candidateArray[canTotalCnt].use_intrabc = 0;
 #endif
             candidateArray[canTotalCnt].merge_flag = EB_FALSE;
 #if !INTRA_INTER_FAST_LOOP
@@ -759,6 +767,9 @@ void Unipred3x3CandidatesInjection(
 #endif
 #else
                 candidateArray[canTotalCnt].distortion_ready = 0;
+#endif
+#if ICOPY
+                candidateArray[canTotalCnt].use_intrabc = 0;
 #endif
                 candidateArray[canTotalCnt].merge_flag = EB_FALSE;
 #if !INTRA_INTER_FAST_LOOP
@@ -871,6 +882,9 @@ void Bipred3x3CandidatesInjection(
 #endif
 #else
             candidateArray[canTotalCnt].distortion_ready = 0;
+#endif
+#if ICOPY
+            candidateArray[canTotalCnt].use_intrabc = 0;
 #endif
             candidateArray[canTotalCnt].merge_flag = EB_FALSE;
 #if !INTRA_INTER_FAST_LOOP
@@ -961,6 +975,9 @@ void Bipred3x3CandidatesInjection(
 #endif
 #else
             candidateArray[canTotalCnt].distortion_ready = 0;
+#endif
+#if ICOPY
+            candidateArray[canTotalCnt].use_intrabc = 0;
 #endif
             candidateArray[canTotalCnt].merge_flag = EB_FALSE;
 #if !INTRA_INTER_FAST_LOOP
@@ -1115,6 +1132,9 @@ void InjectAv1MvpCandidates(
 #endif
 #else
     candidateArray[canIdx].distortion_ready = 0;
+#endif
+#if ICOPY
+    candidateArray[canIdx].use_intrabc = 0;
 #endif
     candidateArray[canIdx].merge_flag = EB_FALSE;
 #if !INTRA_INTER_FAST_LOOP
@@ -1180,6 +1200,9 @@ void InjectAv1MvpCandidates(
 #endif
 #else
         candidateArray[canIdx].distortion_ready = 0;
+#endif
+#if ICOPY
+        candidateArray[canIdx].use_intrabc = 0;
 #endif
         candidateArray[canIdx].merge_flag = EB_FALSE;
 #if !INTRA_INTER_FAST_LOOP
@@ -1234,6 +1257,9 @@ void InjectAv1MvpCandidates(
 #endif
 #else
         candidateArray[canIdx].distortion_ready = 0;
+#endif
+#if ICOPY
+        candidateArray[canIdx].use_intrabc = 0;
 #endif
         candidateArray[canIdx].merge_flag = EB_FALSE;
 #if !INTRA_INTER_FAST_LOOP
@@ -1298,6 +1324,9 @@ void InjectAv1MvpCandidates(
 #endif
 #else
             candidateArray[canIdx].distortion_ready = 0;
+#endif
+#if ICOPY
+            candidateArray[canIdx].use_intrabc = 0;
 #endif
             candidateArray[canIdx].merge_flag = EB_FALSE;
 #if !INTRA_INTER_FAST_LOOP
@@ -1356,6 +1385,9 @@ void InjectAv1MvpCandidates(
 #endif
 #else
                 candidateArray[canIdx].distortion_ready = 0;
+#endif
+#if ICOPY
+                candidateArray[canIdx].use_intrabc = 0;
 #endif
                 candidateArray[canIdx].merge_flag = EB_TRUE;
 #if !INTRA_INTER_FAST_LOOP
@@ -1431,6 +1463,9 @@ void InjectAv1MvpCandidates(
 #endif
 #else
                 candidateArray[canIdx].distortion_ready = 0;
+#endif
+#if ICOPY
+                candidateArray[canIdx].use_intrabc = 0;
 #endif
                 candidateArray[canIdx].merge_flag = EB_FALSE;
 #if !INTRA_INTER_FAST_LOOP
@@ -1511,6 +1546,9 @@ void inject_warped_motion_candidates(
 #endif
 #else
         candidateArray[canIdx].distortion_ready = 0;
+#endif
+#if ICOPY
+        candidateArray[canIdx].use_intrabc = 0;
 #endif
         candidateArray[canIdx].merge_flag = EB_FALSE;
 #if !INTRA_INTER_FAST_LOOP
@@ -1591,6 +1629,9 @@ void inject_warped_motion_candidates(
 #endif
 #else
             candidateArray[canIdx].distortion_ready = 0;
+#endif
+#if ICOPY
+            candidateArray[canIdx].use_intrabc = 0;
 #endif
             candidateArray[canIdx].merge_flag = EB_FALSE;
 #if !INTRA_INTER_FAST_LOOP
@@ -1663,6 +1704,9 @@ void inject_warped_motion_candidates(
 #endif
 #else
         candidateArray[canIdx].distortion_ready = 0;
+#endif
+#if ICOPY
+        candidateArray[canIdx].use_intrabc = 0;
 #endif
         candidateArray[canIdx].merge_flag = EB_FALSE;
 #if !INTRA_INTER_FAST_LOOP
@@ -1901,6 +1945,9 @@ void  inject_inter_candidates(
 #endif
 #else
         candidateArray[canTotalCnt].distortion_ready = 0;
+#endif
+#if ICOPY
+        candidateArray[canTotalCnt].use_intrabc = 0;
 #endif
         candidateArray[canTotalCnt].merge_flag = EB_FALSE;
 #if !INTRA_INTER_FAST_LOOP
@@ -1978,6 +2025,9 @@ void  inject_inter_candidates(
 #endif
 #else
             candidateArray[canTotalCnt].distortion_ready = 0;
+#endif
+#if ICOPY
+            candidateArray[canTotalCnt].use_intrabc = 0;
 #endif
             candidateArray[canTotalCnt].merge_flag = EB_FALSE;
 #if !INTRA_INTER_FAST_LOOP
@@ -2058,6 +2108,9 @@ void  inject_inter_candidates(
 #endif
 #else
                 candidateArray[canTotalCnt].distortion_ready = 0;
+#endif
+#if ICOPY
+                candidateArray[canTotalCnt].use_intrabc = 0;
 #endif
                 candidateArray[canTotalCnt].merge_flag = EB_FALSE;
 #if !INTRA_INTER_FAST_LOOP
@@ -2146,6 +2199,9 @@ void  inject_inter_candidates(
 #endif
 #else
             candidateArray[canTotalCnt].distortion_ready = 0;
+#endif
+#if ICOPY
+            candidateArray[canTotalCnt].use_intrabc = 0;
 #endif
             candidateArray[canTotalCnt].merge_flag = EB_FALSE;
 #if !INTRA_INTER_FAST_LOOP
@@ -2228,6 +2284,9 @@ void  inject_inter_candidates(
 #endif
 #else
         candidateArray[canTotalCnt].distortion_ready = 0;
+#endif
+#if ICOPY
+        candidateArray[canTotalCnt].use_intrabc = 0;
 #endif
         candidateArray[canTotalCnt].merge_flag = EB_FALSE;
 #if !INTRA_INTER_FAST_LOOP
@@ -2292,6 +2351,9 @@ void  inject_inter_candidates(
 #endif
 #else
         candidateArray[canTotalCnt].distortion_ready = 0;
+#endif
+#if ICOPY
+        candidateArray[canTotalCnt].use_intrabc = 0;
 #endif
         candidateArray[canTotalCnt].merge_flag = EB_FALSE;
 #if !INTRA_INTER_FAST_LOOP
@@ -2665,6 +2727,328 @@ void  inject_intra_candidates_ois(
     return;
 }
 
+#endif
+
+#if ICOPY
+double av1_convert_qindex_to_q(int32_t qindex, aom_bit_depth_t bit_depth);
+
+static INLINE void setup_pred_plane(struct buf_2d *dst, block_size bsize,
+    uint8_t *src, int width, int height,
+    int stride, int mi_row, int mi_col,
+    int subsampling_x, int subsampling_y) {
+    // Offset the buffer pointer
+    if (subsampling_y && (mi_row & 0x01) && (mi_size_high[bsize] == 1))
+        mi_row -= 1;
+    if (subsampling_x && (mi_col & 0x01) && (mi_size_wide[bsize] == 1))
+        mi_col -= 1;
+
+    const int x = (MI_SIZE * mi_col) >> subsampling_x;
+    const int y = (MI_SIZE * mi_row) >> subsampling_y;
+    dst->buf = src + (y * stride + x);// scaled_buffer_offset(x, y, stride, scale);
+    dst->buf0 = src;
+    dst->width = width;
+    dst->height = height;
+    dst->stride = stride;
+}
+void av1_setup_pred_block(block_size sb_type,
+    struct buf_2d dst[MAX_MB_PLANE],
+    const Yv12BufferConfig *src, int mi_row, int mi_col) {
+    int i;
+
+    dst[0].buf = src->y_buffer;
+    dst[0].stride = src->y_stride;
+    dst[1].buf = src->u_buffer;
+    dst[2].buf = src->v_buffer;
+    dst[1].stride = dst[2].stride = src->uv_stride;
+
+    i = 0;
+    setup_pred_plane(dst + i, sb_type, dst[i].buf,
+        i ? src->uv_crop_width : src->y_crop_width,
+        i ? src->uv_crop_height : src->y_crop_height,
+        dst[i].stride, mi_row, mi_col,
+        0, 0);
+
+}
+// Values are now correlated to quantizer.
+static int sad_per_bit16lut_8[QINDEX_RANGE];
+static int sad_per_bit4lut_8[QINDEX_RANGE];
+
+static void init_me_luts_bd(int *bit16lut, int *bit4lut, int range,
+    aom_bit_depth_t bit_depth) {
+    int i;
+    // Initialize the sad lut tables using a formulaic calculation for now.
+    // This is to make it easier to resolve the impact of experimental changes
+    // to the quantizer tables.
+    for (i = 0; i < range; i++) {
+        const double q = av1_convert_qindex_to_q(i, bit_depth);
+        bit16lut[i] = (int)(0.0418 * q + 2.4107);
+        bit4lut[i] = (int)(0.063 * q + 2.742);
+    }
+}
+
+void av1_init_me_luts(void) {
+    init_me_luts_bd(sad_per_bit16lut_8, sad_per_bit4lut_8, QINDEX_RANGE,
+        AOM_BITS_8);
+}
+
+static INLINE int mv_check_bounds(const MvLimits *mv_limits, const MV *mv) {
+    return (mv->row >> 3) < mv_limits->row_min ||
+        (mv->row >> 3) > mv_limits->row_max ||
+        (mv->col >> 3) < mv_limits->col_min ||
+        (mv->col >> 3) > mv_limits->col_max;
+}
+void assert_release(int statement)
+{
+    if (statement == 0)
+        printf("ASSERT_ERRRR\n");
+}
+
+void  intra_bc_search(
+    PictureControlSet_t            *pcs,
+    ModeDecisionContext_t          *context_ptr,
+    const SequenceControlSet_t     *scs,
+    LargestCodingUnit_t            *sb_ptr,
+    CodingUnit_t                   *cu_ptr,
+    MV                             *dv_cand,
+    uint8_t                        *num_dv_cand)
+{
+
+    IntraBcContext  x_st;
+    IntraBcContext  *x = &x_st;
+    //fill x with what needed.
+    x->xd = cu_ptr->av1xd;
+    x->nmv_vec_cost = context_ptr->md_rate_estimation_ptr->nmv_vec_cost;
+    x->mv_cost_stack = context_ptr->md_rate_estimation_ptr->nmvcoststack;
+    block_size bsize = context_ptr->blk_geom->bsize;
+    const Av1Common *const cm = pcs->parent_pcs_ptr->av1_cm;
+    MvReferenceFrame ref_frame = INTRA_FRAME;
+    generate_av1_mvp_table(
+#if TILES
+        &sb_ptr->tile_info,
+#endif
+        context_ptr,
+        context_ptr->cu_ptr,
+        context_ptr->blk_geom,
+        context_ptr->cu_origin_x,
+        context_ptr->cu_origin_y,
+        &ref_frame,
+        1,
+        pcs);
+
+    const int num_planes = 3;
+    MacroBlockD * xd = cu_ptr->av1xd;
+    const TileInfo *tile = &xd->tile;
+    const int mi_row = -xd->mb_to_top_edge / (8 * MI_SIZE);
+    const int mi_col = -xd->mb_to_left_edge / (8 * MI_SIZE);
+    const int w = block_size_wide[bsize];
+    const int h = block_size_high[bsize];
+    const int sb_row = mi_row >> scs->mib_size_log2;
+    const int sb_col = mi_col >> scs->mib_size_log2;
+
+    // Set up limit values for MV components.
+    // Mv beyond the range do not produce new/different prediction block.
+    const int mi_width = mi_size_wide[bsize];
+    const int mi_height = mi_size_high[bsize];
+    x->mv_limits.row_min =
+        -(((mi_row + mi_height) * MI_SIZE) + AOM_INTERP_EXTEND);
+    x->mv_limits.col_min = -(((mi_col + mi_width) * MI_SIZE) + AOM_INTERP_EXTEND);
+    x->mv_limits.row_max = (cm->mi_rows - mi_row) * MI_SIZE + AOM_INTERP_EXTEND;
+    x->mv_limits.col_max = (cm->mi_cols - mi_col) * MI_SIZE + AOM_INTERP_EXTEND;
+    //set search paramters
+    x->sadperbit16 = sad_per_bit16lut_8[pcs->parent_pcs_ptr->base_qindex];
+    x->errorperbit = context_ptr->full_lambda >> RD_EPB_SHIFT;
+    x->errorperbit += (x->errorperbit == 0);
+    //temp buffer for hash me
+    for (int xi = 0; xi < 2; xi++)
+        for (int yj = 0; yj < 2; yj++)
+            x->hash_value_buffer[xi][yj] = (uint32_t*)malloc(AOM_BUFFER_SIZE_FOR_BLOCK_HASH * sizeof(uint32_t));
+
+    IntMv nearestmv, nearmv;
+    av1_find_best_ref_mvs_from_stack(0, context_ptr->md_local_cu_unit[context_ptr->blk_geom->blkidx_mds].ed_ref_mv_stack /*mbmi_ext*/, xd, ref_frame, &nearestmv, &nearmv,
+        0);
+    if (nearestmv.as_int == INVALID_MV) {
+        nearestmv.as_int = 0;
+    }
+    if (nearmv.as_int == INVALID_MV) {
+        nearmv.as_int = 0;
+    }
+    IntMv dv_ref = nearestmv.as_int == 0 ? nearmv : nearestmv;
+    if (dv_ref.as_int == 0)
+        av1_find_ref_dv(&dv_ref, tile, scs->mib_size, mi_row, mi_col);
+    // Ref DV should not have sub-pel.
+    assert((dv_ref.as_mv.col & 7) == 0);
+    assert((dv_ref.as_mv.row & 7) == 0);
+    context_ptr->md_local_cu_unit[context_ptr->blk_geom->blkidx_mds].ed_ref_mv_stack[INTRA_FRAME][0].this_mv = dv_ref;
+
+    /* pointer to current frame */
+    Yv12BufferConfig cur_buf;
+    LinkEbToAomBufferDesc(
+        pcs->parent_pcs_ptr->enhanced_picture_ptr,
+        &cur_buf);
+    struct buf_2d yv12_mb[MAX_MB_PLANE];
+    av1_setup_pred_block(bsize, yv12_mb, &cur_buf, mi_row, mi_col);
+    for (int i = 0; i < num_planes; ++i) {
+        x->xdplane[i].pre[0] = yv12_mb[i];  //ref in ME
+    }
+    //setup src for DV search same as ref
+    x->plane[0].src = x->xdplane[0].pre[0];
+
+
+    enum IntrabcMotionDirection {
+        IBC_MOTION_ABOVE,
+        IBC_MOTION_LEFT,
+        IBC_MOTION_DIRECTIONS
+    };
+
+    //up to two dv candidates will be generated 
+    for (enum IntrabcMotionDirection dir = IBC_MOTION_ABOVE;
+        dir < IBC_MOTION_DIRECTIONS; ++dir) {
+
+        const MvLimits tmp_mv_limits = x->mv_limits;
+
+        switch (dir) {
+        case IBC_MOTION_ABOVE:
+            x->mv_limits.col_min = (tile->mi_col_start - mi_col) * MI_SIZE;
+            x->mv_limits.col_max = (tile->mi_col_end - mi_col) * MI_SIZE - w;
+            x->mv_limits.row_min = (tile->mi_row_start - mi_row) * MI_SIZE;
+            x->mv_limits.row_max =
+                (sb_row * scs->mib_size - mi_row) * MI_SIZE - h;
+            break;
+        case IBC_MOTION_LEFT:
+            x->mv_limits.col_min = (tile->mi_col_start - mi_col) * MI_SIZE;
+            x->mv_limits.col_max =
+                (sb_col * scs->mib_size - mi_col) * MI_SIZE - w;
+            // TODO: Minimize the overlap between above and
+            // left areas.
+            x->mv_limits.row_min = (tile->mi_row_start - mi_row) * MI_SIZE;
+            int bottom_coded_mi_edge =
+                AOMMIN((sb_row + 1) * scs->mib_size, tile->mi_row_end);
+            x->mv_limits.row_max = (bottom_coded_mi_edge - mi_row) * MI_SIZE - h;
+            break;
+        default: assert(0);
+        }
+        assert_release(x->mv_limits.col_min >= tmp_mv_limits.col_min);
+        assert_release(x->mv_limits.col_max <= tmp_mv_limits.col_max);
+        assert_release(x->mv_limits.row_min >= tmp_mv_limits.row_min);
+        assert_release(x->mv_limits.row_max <= tmp_mv_limits.row_max);
+
+        av1_set_mv_search_range(&x->mv_limits, &dv_ref.as_mv);
+
+        if (x->mv_limits.col_max < x->mv_limits.col_min ||
+            x->mv_limits.row_max < x->mv_limits.row_min) {
+            x->mv_limits = tmp_mv_limits;
+            continue;
+        }
+
+        int step_param = 0;
+        MV mvp_full = dv_ref.as_mv;
+        mvp_full.col >>= 3;
+        mvp_full.row >>= 3;
+        const int sadpb = x->sadperbit16;
+        x->best_mv.as_int = 0;
+
+#define INT_VAR_MAX  2147483647    // maximum (signed) int value
+
+        const int bestsme = av1_full_pixel_search(
+            pcs, x, bsize, &mvp_full, step_param, 1, 0,
+            sadpb, NULL, &dv_ref.as_mv, INT_VAR_MAX, 1,
+            (MI_SIZE * mi_col), (MI_SIZE * mi_row), 1);
+
+        x->mv_limits = tmp_mv_limits;
+        if (bestsme == INT_VAR_MAX) continue;
+        mvp_full = x->best_mv.as_mv;
+
+        const MV dv = { .row = mvp_full.row * 8,.col = mvp_full.col * 8 };
+        if (mv_check_bounds(&x->mv_limits, &dv)) continue;
+        if (!av1_is_dv_valid(dv, xd, mi_row, mi_col, bsize,
+            scs->mib_size_log2))
+            continue;
+
+        // DV should not have sub-pel.
+        assert_release((dv.col & 7) == 0);
+        assert_release((dv.row & 7) == 0);
+
+        //store output
+        dv_cand[*num_dv_cand] = dv;
+        (*num_dv_cand)++;
+
+    }
+
+    for (int i = 0; i < 2; i++)
+        for (int j = 0; j < 2; j++)
+            free(x->hash_value_buffer[i][j]);
+
+}
+
+void  inject_intra_bc_candidates(
+    PictureControlSet_t            *picture_control_set_ptr,
+    ModeDecisionContext_t          *context_ptr,
+    const SequenceControlSet_t     *sequence_control_set_ptr,
+    LargestCodingUnit_t            *sb_ptr,
+    CodingUnit_t                   *cu_ptr,
+    uint32_t                       *cand_cnt)
+{
+    MV dv_cand[2];
+    uint8_t num_dv_cand = 0;
+
+    //perform dv-pred + search up to 2 dv(s)
+    intra_bc_search(
+        picture_control_set_ptr,
+        context_ptr,
+        sequence_control_set_ptr,
+        sb_ptr,
+        cu_ptr,
+        dv_cand,
+        &num_dv_cand);
+
+    ModeDecisionCandidate_t    *candidateArray = context_ptr->fast_candidate_array;
+    uint32_t dv_i;
+
+    for (dv_i = 0; dv_i < num_dv_cand; dv_i++)
+    {
+        candidateArray[*cand_cnt].type = INTRA_MODE;
+        candidateArray[*cand_cnt].intra_luma_mode = DC_PRED;
+#if TWO_FAST_LOOP 
+        candidateArray[*cand_cnt].enable_two_fast_loops = 0;
+#else
+        candidateArray[*cand_cnt].distortion_ready = 0;
+#endif
+        candidateArray[*cand_cnt].use_intrabc = 1;
+        candidateArray[*cand_cnt].is_directional_mode_flag = 0;
+        candidateArray[*cand_cnt].use_angle_delta = 0;
+        candidateArray[*cand_cnt].angle_delta[PLANE_TYPE_Y] = 0;
+        candidateArray[*cand_cnt].intra_chroma_mode = UV_DC_PRED;
+        candidateArray[*cand_cnt].cfl_alpha_signs = 0;
+        candidateArray[*cand_cnt].cfl_alpha_idx = 0;
+        candidateArray[*cand_cnt].is_directional_chroma_mode_flag = 0;
+        candidateArray[*cand_cnt].angle_delta[PLANE_TYPE_UV] = 0;
+        candidateArray[*cand_cnt].transform_type[PLANE_TYPE_Y] = DCT_DCT;
+        candidateArray[*cand_cnt].transform_type[PLANE_TYPE_UV] = DCT_DCT;
+        candidateArray[*cand_cnt].mpm_flag = EB_FALSE;
+        candidateArray[*cand_cnt].ref_frame_type = INTRA_FRAME;
+        candidateArray[*cand_cnt].pred_mode = DC_PRED;
+        candidateArray[*cand_cnt].motion_mode = SIMPLE_TRANSLATION;
+        //inter ralated
+        candidateArray[*cand_cnt].is_compound = 0;
+        candidateArray[*cand_cnt].merge_flag = EB_FALSE;
+        candidateArray[*cand_cnt].merge_index = 0;
+        candidateArray[*cand_cnt].prediction_direction[0] = UNI_PRED_LIST_0;
+        candidateArray[*cand_cnt].is_skip_mode_flag = 0;
+        candidateArray[*cand_cnt].is_new_mv = 0;
+        candidateArray[*cand_cnt].is_zero_mv = 0;
+        candidateArray[*cand_cnt].motionVector_x_L0 = dv_cand[dv_i].col;
+        candidateArray[*cand_cnt].motionVector_y_L0 = dv_cand[dv_i].row;
+        candidateArray[*cand_cnt].motion_vector_pred_x[REF_LIST_0] = context_ptr->md_local_cu_unit[context_ptr->blk_geom->blkidx_mds].ed_ref_mv_stack[INTRA_FRAME][0].this_mv.as_mv.col;
+        candidateArray[*cand_cnt].motion_vector_pred_y[REF_LIST_0] = context_ptr->md_local_cu_unit[context_ptr->blk_geom->blkidx_mds].ed_ref_mv_stack[INTRA_FRAME][0].this_mv.as_mv.row;
+        candidateArray[*cand_cnt].drl_index = 0;
+        candidateArray[*cand_cnt].ref_mv_index = 0;
+        candidateArray[*cand_cnt].pred_mv_weight = 0;
+        candidateArray[*cand_cnt].interp_filters = av1_broadcast_interp_filter(BILINEAR);
+        ++(*cand_cnt);
+
+    }
+
+}
 #endif
 // END of Function Declarations
 void  inject_intra_candidates(
@@ -2759,6 +3143,9 @@ void  inject_intra_candidates(
 #endif
 #else
                         candidateArray[canTotalCnt].distortion_ready = 0;
+#endif
+#if ICOPY
+                        candidateArray[canTotalCnt].use_intrabc = 0;
 #endif
                         candidateArray[canTotalCnt].is_directional_mode_flag = (uint8_t)av1_is_directional_mode((PredictionMode)openLoopIntraCandidate);
                         candidateArray[canTotalCnt].use_angle_delta = use_angle_delta ? candidateArray[canTotalCnt].is_directional_mode_flag : 0;
@@ -2819,6 +3206,9 @@ void  inject_intra_candidates(
 #endif
 #else
             candidateArray[canTotalCnt].distortion_ready = 0;
+#endif
+#if ICOPY
+            candidateArray[canTotalCnt].use_intrabc = 0;
 #endif
             candidateArray[canTotalCnt].is_directional_mode_flag = (uint8_t)av1_is_directional_mode((PredictionMode)openLoopIntraCandidate);
             candidateArray[canTotalCnt].use_angle_delta = candidateArray[canTotalCnt].is_directional_mode_flag;
@@ -2980,6 +3370,18 @@ EbErrorType ProductGenerateMdCandidatesCu(
     context_ptr->fast_candidate_intra_count = canTotalCnt;
 #endif
 
+#if ICOPY
+    if (picture_control_set_ptr->parent_pcs_ptr->allow_intrabc)
+        inject_intra_bc_candidates(
+            picture_control_set_ptr,
+            context_ptr,
+            sequence_control_set_ptr,
+            sb_ptr,
+            context_ptr->cu_ptr,
+            &canTotalCnt
+        );
+#endif
+
     if (slice_type != I_SLICE) {
         if (inject_inter_candidate)
             inject_inter_candidates(
@@ -3074,6 +3476,10 @@ uint8_t product_full_mode_decision(
 
     context_ptr->md_local_cu_unit[cu_ptr->mds_idx].count_non_zero_coeffs = candidate_ptr->count_non_zero_coeffs;
 
+#if ICOPY    
+    cu_ptr->av1xd->use_intrabc = candidate_ptr->use_intrabc;
+#endif
+
     // Set the PU level variables
     cu_ptr->interp_filters = candidate_ptr->interp_filters;
     {
@@ -3100,7 +3506,11 @@ uint8_t product_full_mode_decision(
         // Inter Prediction
         pu_ptr->inter_pred_direction_index = candidate_ptr->prediction_direction[0];
         pu_ptr->merge_flag = candidate_ptr->merge_flag;
+#if ICOPY
+        if (cu_ptr->prediction_mode_flag != INTER_MODE && cu_ptr->av1xd->use_intrabc == 0)
+#else
         if (cu_ptr->prediction_mode_flag != INTER_MODE)
+#endif
         {
             pu_ptr->inter_pred_direction_index = 0x03;
             pu_ptr->merge_flag = EB_FALSE;
diff --git a/Source/Lib/Codec/EbModeDecision.h b/Source/Lib/Codec/EbModeDecision.h
index f3eb63a..437ae6e 100644
--- a/Source/Lib/Codec/EbModeDecision.h
+++ b/Source/Lib/Codec/EbModeDecision.h
@@ -79,7 +79,7 @@ extern "C" {
 
         uint8_t                                skip_flag;
         EbBool                                 merge_flag;
-#if !INTRA_INTER_FAST_LOOP
+#if !INTRA_INTER_FAST_LOOP || ICOPY
         uint8_t                                merge_index; // Hsan: does not seem to be used why not removed ?
 #endif
         uint16_t                               count_non_zero_coeffs;
@@ -87,7 +87,7 @@ extern "C" {
         EbBool                                 prediction_is_ready_luma;
 #endif
         uint8_t                                type;
-#if !INTRA_INTER_FAST_LOOP
+#if !INTRA_INTER_FAST_LOOP || ICOPY
         EbBool                                 mpm_flag;
 #endif
         // MD Rate Estimation Ptr
@@ -113,7 +113,9 @@ extern "C" {
 
         PredictionMode                         pred_mode; // AV1 mode, no need to convert
         uint8_t                                drl_index;
-
+#if ICOPY
+        uint8_t                                use_intrabc;
+#endif
         // Intra Mode
         int32_t                                angle_delta[PLANE_TYPES];
         EbBool                                 is_directional_mode_flag;
@@ -132,7 +134,7 @@ extern "C" {
         uint32_t                               pred_mv_weight;
         uint8_t                                ref_frame_type;
         uint8_t                                ref_mv_index;
-#if !INTRA_INTER_FAST_LOOP
+#if !INTRA_INTER_FAST_LOOP || ICOPY
         EbBool                                 is_skip_mode_flag;
 #endif
         EbBool                                 is_new_mv;
diff --git a/Source/Lib/Codec/EbModeDecisionConfigurationProcess.c b/Source/Lib/Codec/EbModeDecisionConfigurationProcess.c
index abb4ff3..316151f 100644
--- a/Source/Lib/Codec/EbModeDecisionConfigurationProcess.c
+++ b/Source/Lib/Codec/EbModeDecisionConfigurationProcess.c
@@ -26,7 +26,37 @@
 #include "EbModeDecisionConfiguration.h"
 #include "EbReferenceObject.h"
 #include "EbModeDecisionProcess.h"
+#if ICOPY
+#include "av1me.h"
+
+
+#define MAX_MESH_SPEED 5  // Max speed setting for mesh motion method
+static MESH_PATTERN
+good_quality_mesh_patterns[MAX_MESH_SPEED + 1][MAX_MESH_STEP] = {
+    { { 64, 8 }, { 28, 4 }, { 15, 1 }, { 7, 1 } },
+    { { 64, 8 }, { 28, 4 }, { 15, 1 }, { 7, 1 } },
+    { { 64, 8 }, { 14, 2 }, { 7, 1 }, { 7, 1 } },
+    { { 64, 16 }, { 24, 8 }, { 12, 4 }, { 7, 1 } },
+    { { 64, 16 }, { 24, 8 }, { 12, 4 }, { 7, 1 } },
+    { { 64, 16 }, { 24, 8 }, { 12, 4 }, { 7, 1 } },
+};
+static unsigned char good_quality_max_mesh_pct[MAX_MESH_SPEED + 1] = {
+    50, 50, 25, 15, 5, 1
+};
+// TODO: These settings are pretty relaxed, tune them for
+// each speed setting
+static MESH_PATTERN intrabc_mesh_patterns[MAX_MESH_SPEED + 1][MAX_MESH_STEP] = {
+  { { 256, 1 }, { 256, 1 }, { 0, 0 }, { 0, 0 } },
+  { { 256, 1 }, { 256, 1 }, { 0, 0 }, { 0, 0 } },
+  { { 64, 1 }, { 64, 1 }, { 0, 0 }, { 0, 0 } },
+  { { 64, 1 }, { 64, 1 }, { 0, 0 }, { 0, 0 } },
+  { { 64, 4 }, { 16, 1 }, { 0, 0 }, { 0, 0 } },
+  { { 64, 4 }, { 16, 1 }, { 0, 0 }, { 0, 0 } },
+};
+static uint8_t intrabc_max_mesh_pct[MAX_MESH_SPEED + 1] = { 100, 100, 100,
+                                                            25,  25,  10 };
 
+#endif
 #if ADAPTIVE_DEPTH_PARTITIONING
 // Adaptive Depth Partitioning
 // Shooting states
@@ -3158,6 +3188,9 @@ void* ModeDecisionConfigurationKernel(void *input_ptr)
 
         // Initial Rate Estimatimation of the Motion vectors
         av1_estimate_mv_rate(
+#if ICOPY
+            picture_control_set_ptr,
+#endif
             md_rate_estimation_array,
             &picture_control_set_ptr->coeff_est_entropy_coder_ptr->fc->nmvc);
 
@@ -3274,6 +3307,124 @@ void* ModeDecisionConfigurationKernel(void *input_ptr)
             picture_control_set_ptr->parent_pcs_ptr->average_qp = (uint8_t)picture_control_set_ptr->parent_pcs_ptr->picture_qp;
         }
 
+#if ICOPY
+        if (picture_control_set_ptr->parent_pcs_ptr->allow_intrabc)
+        {
+            int i;
+            int speed = 1;
+            SPEED_FEATURES *sf = &picture_control_set_ptr->sf;
+            sf->allow_exhaustive_searches = 1;
+
+            const int mesh_speed = AOMMIN(speed, MAX_MESH_SPEED);
+            //if (cpi->twopass.fr_content_type == FC_GRAPHICS_ANIMATION)
+            //    sf->exhaustive_searches_thresh = (1 << 24);
+            //else
+            sf->exhaustive_searches_thresh = (1 << 25);
+
+            sf->max_exaustive_pct = good_quality_max_mesh_pct[mesh_speed];
+            if (mesh_speed > 0)
+                sf->exhaustive_searches_thresh = sf->exhaustive_searches_thresh << 1;
+
+            for (i = 0; i < MAX_MESH_STEP; ++i) {
+                sf->mesh_patterns[i].range =
+                    good_quality_mesh_patterns[mesh_speed][i].range;
+                sf->mesh_patterns[i].interval =
+                    good_quality_mesh_patterns[mesh_speed][i].interval;
+            }
+
+            if (picture_control_set_ptr->slice_type == I_SLICE)
+            {
+                for (i = 0; i < MAX_MESH_STEP; ++i) {
+                    sf->mesh_patterns[i].range = intrabc_mesh_patterns[mesh_speed][i].range;
+                    sf->mesh_patterns[i].interval =
+                        intrabc_mesh_patterns[mesh_speed][i].interval;
+                }
+                sf->max_exaustive_pct = intrabc_max_mesh_pct[mesh_speed];
+            }
+
+            {
+                // add to hash table
+                const int pic_width = picture_control_set_ptr->parent_pcs_ptr->sequence_control_set_ptr->luma_width;
+                const int pic_height = picture_control_set_ptr->parent_pcs_ptr->sequence_control_set_ptr->luma_height;
+                uint32_t *block_hash_values[2][2];
+                int8_t *is_block_same[2][3];
+                int k, j;
+
+                for (k = 0; k < 2; k++) {
+                    for (j = 0; j < 2; j++) {
+                        block_hash_values[k][j] = malloc(sizeof(uint32_t) * pic_width * pic_height);
+                    }
+
+                    for (j = 0; j < 3; j++) {
+                        is_block_same[k][j] = malloc(sizeof(int8_t) * pic_width * pic_height);
+                    }
+                }
+
+                //picture_control_set_ptr->hash_table.p_lookup_table = NULL;
+                //av1_hash_table_create(&picture_control_set_ptr->hash_table);
+
+                Yv12BufferConfig cpi_source;
+                LinkEbToAomBufferDesc(
+                    picture_control_set_ptr->parent_pcs_ptr->enhanced_picture_ptr,
+                    &cpi_source);
+
+                av1_crc_calculator_init(&picture_control_set_ptr->crc_calculator1, 24, 0x5D6DCB);
+                av1_crc_calculator_init(&picture_control_set_ptr->crc_calculator2, 24, 0x864CFB);
+
+                av1_generate_block_2x2_hash_value(&cpi_source, block_hash_values[0],
+                    is_block_same[0], picture_control_set_ptr);
+                av1_generate_block_hash_value(&cpi_source, 4, block_hash_values[0],
+                    block_hash_values[1], is_block_same[0],
+                    is_block_same[1], picture_control_set_ptr);
+                av1_add_to_hash_map_by_row_with_precal_data(
+                    &picture_control_set_ptr->hash_table, block_hash_values[1], is_block_same[1][2],
+                    pic_width, pic_height, 4);
+                av1_generate_block_hash_value(&cpi_source, 8, block_hash_values[1],
+                    block_hash_values[0], is_block_same[1],
+                    is_block_same[0], picture_control_set_ptr);
+                av1_add_to_hash_map_by_row_with_precal_data(
+                    &picture_control_set_ptr->hash_table, block_hash_values[0], is_block_same[0][2],
+                    pic_width, pic_height, 8);
+                av1_generate_block_hash_value(&cpi_source, 16, block_hash_values[0],
+                    block_hash_values[1], is_block_same[0],
+                    is_block_same[1], picture_control_set_ptr);
+                av1_add_to_hash_map_by_row_with_precal_data(
+                    &picture_control_set_ptr->hash_table, block_hash_values[1], is_block_same[1][2],
+                    pic_width, pic_height, 16);
+                av1_generate_block_hash_value(&cpi_source, 32, block_hash_values[1],
+                    block_hash_values[0], is_block_same[1],
+                    is_block_same[0], picture_control_set_ptr);
+                av1_add_to_hash_map_by_row_with_precal_data(
+                    &picture_control_set_ptr->hash_table, block_hash_values[0], is_block_same[0][2],
+                    pic_width, pic_height, 32);
+                av1_generate_block_hash_value(&cpi_source, 64, block_hash_values[0],
+                    block_hash_values[1], is_block_same[0],
+                    is_block_same[1], picture_control_set_ptr);
+                av1_add_to_hash_map_by_row_with_precal_data(
+                    &picture_control_set_ptr->hash_table, block_hash_values[1], is_block_same[1][2],
+                    pic_width, pic_height, 64);
+
+                av1_generate_block_hash_value(&cpi_source, 128, block_hash_values[1],
+                    block_hash_values[0], is_block_same[1],
+                    is_block_same[0], picture_control_set_ptr);
+                av1_add_to_hash_map_by_row_with_precal_data(
+                    &picture_control_set_ptr->hash_table, block_hash_values[0], is_block_same[0][2],
+                    pic_width, pic_height, 128);
+
+                for (k = 0; k < 2; k++) {
+                    for (j = 0; j < 2; j++) {
+                        free(block_hash_values[k][j]);
+                    }
+
+                    for (j = 0; j < 3; j++) {
+                        free(is_block_same[k][j]);
+                    }
+                }
+            }
+
+            av1_init3smotion_compensation(&picture_control_set_ptr->ss_cfg, picture_control_set_ptr->parent_pcs_ptr->enhanced_picture_ptr->stride_y);
+        }
+#endif
 
         // Derive MD parameters
         SetMdSettings( // HT Done
diff --git a/Source/Lib/Codec/EbModeDecisionProcess.h b/Source/Lib/Codec/EbModeDecisionProcess.h
index 23deaf3..b3185d7 100644
--- a/Source/Lib/Codec/EbModeDecisionProcess.h
+++ b/Source/Lib/Codec/EbModeDecisionProcess.h
@@ -24,7 +24,12 @@ extern "C" {
      * Defines
      **************************************/
 #if IMPROVED_BIPRED_INJECTION || IMPROVED_UNIPRED_INJECTION
+#if ICOPY
+#define IBC_CAND 2 //two intra bc candidates
+#define MODE_DECISION_CANDIDATE_MAX_COUNT               (124+IBC_CAND) /* 61 Intra & 18+2x8+2x8 Inter*/
+#else
 #define MODE_DECISION_CANDIDATE_MAX_COUNT               124// 61 Intra & 18+2x8+2x8 Inter
+#endif
 #else
 #define MODE_DECISION_CANDIDATE_MAX_COUNT               90//35//20 // 61 Intra & 18 Inter
 #endif
diff --git a/Source/Lib/Codec/EbPictureAnalysisProcess.c b/Source/Lib/Codec/EbPictureAnalysisProcess.c
index 836a788..180e73c 100644
--- a/Source/Lib/Codec/EbPictureAnalysisProcess.c
+++ b/Source/Lib/Codec/EbPictureAnalysisProcess.c
@@ -4872,7 +4872,50 @@ void DecimateInputPicture(
         }
     }
 }
+#if ICOPY
+int av1_count_colors(const uint8_t *src, int stride, int rows, int cols,
+    int *val_count) {
+    const int max_pix_val = 1 << 8;
+    memset(val_count, 0, max_pix_val * sizeof(val_count[0]));
+    for (int r = 0; r < rows; ++r) {
+        for (int c = 0; c < cols; ++c) {
+            const int this_val = src[r * stride + c];
+            assert(this_val < max_pix_val);
+            ++val_count[this_val];
+        }
+    }
+    int n = 0;
+    for (int i = 0; i < max_pix_val; ++i) {
+        if (val_count[i]) ++n;
+    }
+    return n;
+}
+// Estimate if the source frame is screen content, based on the portion of
+// blocks that have no more than 4 (experimentally selected) luma colors.
+static int is_screen_content(const uint8_t *src, int use_hbd,
+    int stride, int width, int height) {
+    assert(src != NULL);
+    int counts = 0;
+    const int blk_w = 16;
+    const int blk_h = 16;
+    const int limit = 4;
+    for (int r = 0; r + blk_h <= height; r += blk_h) {
+        for (int c = 0; c + blk_w <= width; c += blk_w) {
+            int count_buf[1 << 12];  // Maximum (1 << 12) color levels.
+            const int n_colors =
+                use_hbd ? 0 /*av1_count_colors_highbd(src + r * stride + c, stride, blk_w,
+                    blk_h, bd, count_buf)*/
+                : av1_count_colors(src + r * stride + c, stride, blk_w, blk_h,
+                    count_buf);
+            if (n_colors > 1 && n_colors <= limit) counts++;
+        }
+    }
+    // The threshold is 10%.
+    return counts * blk_h * blk_w * 10 > width * height;
+}
 
+
+#endif
 /************************************************
  * Picture Analysis Kernel
  * The Picture Analysis Process pads & decimates the input pictures.
@@ -4933,6 +4976,14 @@ void* picture_analysis_kernel(void *input_ptr)
         SetPictureParametersForStatisticsGathering(
             sequence_control_set_ptr);
 
+#if ICOPY
+        picture_control_set_ptr->sc_content_detected = is_screen_content(
+            input_picture_ptr->buffer_y + input_picture_ptr->origin_x + input_picture_ptr->origin_y*input_picture_ptr->stride_y,
+            0,
+            input_picture_ptr->stride_y,
+            sequence_control_set_ptr->luma_width, sequence_control_set_ptr->luma_height);
+#endif
+
         // Pad pictures to multiple min cu size
         PadPictureToMultipleOfMinCuSizeDimensions(
             sequence_control_set_ptr,
diff --git a/Source/Lib/Codec/EbPictureControlSet.c b/Source/Lib/Codec/EbPictureControlSet.c
index 017cb6e..30fbae2 100644
--- a/Source/Lib/Codec/EbPictureControlSet.c
+++ b/Source/Lib/Codec/EbPictureControlSet.c
@@ -28,6 +28,9 @@ void *aom_malloc(size_t size);
 #endif
 EbErrorType av1_alloc_restoration_buffers(Av1Common *cm);
 
+#if ICOPY
+EbErrorType av1_hash_table_create(hash_table *p_hash_table);
+#endif
 
 static void set_restoration_unit_size(int32_t width, int32_t height, int32_t sx, int32_t sy,
     RestorationInfo *rst) {
@@ -893,6 +896,10 @@ EbErrorType picture_control_set_ctor(
     }
 
     object_ptr->mi_stride = pictureLcuWidth * (BLOCK_SIZE_64 / 4);
+#if ICOPY
+    object_ptr->hash_table.p_lookup_table = NULL;
+    av1_hash_table_create(&object_ptr->hash_table);
+#endif
     return EB_ErrorNone;
 }
 
diff --git a/Source/Lib/Codec/EbPictureControlSet.h b/Source/Lib/Codec/EbPictureControlSet.h
index 643cf95..593395d 100644
--- a/Source/Lib/Codec/EbPictureControlSet.h
+++ b/Source/Lib/Codec/EbPictureControlSet.h
@@ -27,6 +27,10 @@
 #include "EbCdef.h"
 #endif
 
+#if ICOPY
+#include"av1me.h"
+#include "hash_motion.h"
+#endif
 
 #ifdef __cplusplus
 extern "C" {
@@ -13620,6 +13624,10 @@ extern "C" {
 #if FAST_SG
         int8_t  wn_filter_mode;
 #endif
+
+#if ICOPY
+        struct PictureControlSet_s               *pcs_ptr;
+#endif
     } Av1Common;
 
     /**************************************
@@ -13668,6 +13676,35 @@ extern "C" {
      **************************************/
     struct CodedTreeblock_s;
     struct LargestCodingUnit_s;
+#if ICOPY
+#define MAX_MESH_STEP 4
+
+    typedef struct MESH_PATTERN {
+        int range;
+        int interval;
+    } MESH_PATTERN;
+
+    typedef struct SPEED_FEATURES {
+
+        // TODO(jingning): combine the related motion search speed features
+        // This allows us to use motion search at other sizes as a starting
+        // point for this motion search and limits the search range around it.
+        int adaptive_motion_search;
+
+        // Flag for allowing some use of exhaustive searches;
+        int allow_exhaustive_searches;
+
+        // Threshold for allowing exhaistive motion search.
+        int exhaustive_searches_thresh;
+
+        // Maximum number of exhaustive searches for a frame.
+        int max_exaustive_pct;
+
+        // Pattern to be used for any exhaustive mesh searches.
+        MESH_PATTERN mesh_patterns[MAX_MESH_STEP];
+
+    } SPEED_FEATURES;
+#endif
 
     typedef struct PictureControlSet_s
     {
@@ -13850,6 +13887,13 @@ extern "C" {
         int32_t                               cdef_preset[4];
         WienerInfo                            wiener_info[MAX_MB_PLANE];
         SgrprojInfo                           sgrproj_info[MAX_MB_PLANE];
+#if ICOPY
+        SPEED_FEATURES sf;
+        search_site_config ss_cfg;//CHKN this might be a seq based
+        hash_table hash_table;
+        CRC_CALCULATOR crc_calculator1;
+        CRC_CALCULATOR crc_calculator2;
+#endif
 
     } PictureControlSet_t;
 
@@ -14289,7 +14333,9 @@ extern "C" {
 #if NSQ_OPTIMASATION
         uint8_t                               nsq_max_shapes_md; // max number of shapes to be tested in MD
 #endif
-
+#if ICOPY
+        uint8_t                              sc_content_detected;
+#endif
     } PictureParentControlSet_t;
 
 
diff --git a/Source/Lib/Codec/EbPictureDecisionProcess.c b/Source/Lib/Codec/EbPictureDecisionProcess.c
index 90e20b4..b3db2f3 100644
--- a/Source/Lib/Codec/EbPictureDecisionProcess.c
+++ b/Source/Lib/Codec/EbPictureDecisionProcess.c
@@ -766,7 +766,27 @@ EbErrorType signal_derivation_multi_processes_oq(
     // 2                                            LIGHT FRAME-BASED
     // 3                                            FULL FRAME-BASED
 
+#if ICOPY
+    //for now only I frames are allowed to use sc tools.
+    //TODO: we can force all frames in GOP with the same detection status of leading I frame.
+    if (picture_control_set_ptr->slice_type == I_SLICE) {
+        picture_control_set_ptr->allow_screen_content_tools = picture_control_set_ptr->sc_content_detected;
+        picture_control_set_ptr->allow_intrabc = picture_control_set_ptr->sc_content_detected;
+        
+        //turn OFF intra bc for some specific modes
+        if (picture_control_set_ptr->enc_mode >= ENC_M1)
+            picture_control_set_ptr->allow_intrabc = 0;
+      
+    }
+    else {
+        picture_control_set_ptr->allow_screen_content_tools = 0;
+        picture_control_set_ptr->allow_intrabc = 0;
+    }
+
+    if (!picture_control_set_ptr->sequence_control_set_ptr->static_config.disable_dlf_flag && picture_control_set_ptr->allow_intrabc == 0) {
+#else
     if (!picture_control_set_ptr->sequence_control_set_ptr->static_config.disable_dlf_flag) {
+#endif
         if (picture_control_set_ptr->enc_mode >= ENC_M4)
             picture_control_set_ptr->loop_filter_mode = 1;
         else
@@ -783,7 +803,11 @@ EbErrorType signal_derivation_multi_processes_oq(
     // 3                                            16 step refinement
     SequenceControlSet_t                    *sequence_control_set_ptr;
     sequence_control_set_ptr = (SequenceControlSet_t*)picture_control_set_ptr->sequence_control_set_wrapper_ptr->object_ptr;
+#if ICOPY 
+    if (sequence_control_set_ptr->enable_cdef && picture_control_set_ptr->allow_intrabc == 0) {
+#else
     if (sequence_control_set_ptr->enable_cdef) {
+#endif
         if (picture_control_set_ptr->enc_mode <= ENC_M3)
             picture_control_set_ptr->cdef_filter_mode = 3;
         else
diff --git a/Source/Lib/Codec/EbPictureManagerProcess.c b/Source/Lib/Codec/EbPictureManagerProcess.c
index 03e820f..23cb765 100644
--- a/Source/Lib/Codec/EbPictureManagerProcess.c
+++ b/Source/Lib/Codec/EbPictureManagerProcess.c
@@ -712,6 +712,10 @@ void* picture_manager_kernel(void *input_ptr)
                             }
                         }
 
+#if ICOPY
+                        ChildPictureControlSetPtr->parent_pcs_ptr->av1_cm->pcs_ptr = ChildPictureControlSetPtr;
+#endif
+
 #if TILES             
                         set_tile_info(ChildPictureControlSetPtr->parent_pcs_ptr);
 
diff --git a/Source/Lib/Codec/EbRateDistortionCost.c b/Source/Lib/Codec/EbRateDistortionCost.c
index 9cafdf7..4941f1f 100644
--- a/Source/Lib/Codec/EbRateDistortionCost.c
+++ b/Source/Lib/Codec/EbRateDistortionCost.c
@@ -29,7 +29,12 @@ block_size GetBlockSize(uint8_t cu_size) {
     return (cu_size == 64 ? BLOCK_64X64 : cu_size == 32 ? BLOCK_32X32 : cu_size == 16 ? BLOCK_16X16 : cu_size == 8 ? BLOCK_8X8 : BLOCK_4X4);
 }
 
+#if ICOPY
+int av1_allow_intrabc(const Av1Common *const cm);
+int32_t is_chroma_reference(int32_t mi_row, int32_t mi_col, block_size bsize,
+#else
 static INLINE int32_t is_chroma_reference(int32_t mi_row, int32_t mi_col, block_size bsize,
+#endif
     int32_t subsampling_x, int32_t subsampling_y) {
     const int32_t bw = mi_size_wide[bsize];
     const int32_t bh = mi_size_high[bsize];
@@ -595,6 +600,54 @@ EbErrorType av1_intra_fast_cost(
     UNUSED(miCol);
     UNUSED(left_neighbor_mode);
     UNUSED(top_neighbor_mode);
+
+#if ICOPY 
+   
+    if (av1_allow_intrabc(picture_control_set_ptr->parent_pcs_ptr->av1_cm) && candidate_ptr->use_intrabc) {
+
+        uint64_t lumaSad = (LUMA_WEIGHT * luma_distortion) << AV1_COST_PRECISION;
+        uint64_t chromaSad = chroma_distortion << AV1_COST_PRECISION;
+        uint64_t totalDistortion = lumaSad + chromaSad;
+
+        uint64_t rate = 0;
+
+        EbReflist refListIdx = 0;
+        int16_t predRefX = candidate_ptr->motion_vector_pred_x[refListIdx];
+        int16_t predRefY = candidate_ptr->motion_vector_pred_y[refListIdx];
+        int16_t mvRefX = candidate_ptr->motionVector_x_L0;
+        int16_t mvRefY = candidate_ptr->motionVector_y_L0;
+        MV mv;
+        mv.row = mvRefY;
+        mv.col = mvRefX;
+        MV ref_mv;
+        ref_mv.row = predRefY;
+        ref_mv.col = predRefX;
+
+        int *dvcost[2] = { (int *)&candidate_ptr->md_rate_estimation_ptr->dv_cost[0][MV_MAX],
+                           (int *)&candidate_ptr->md_rate_estimation_ptr->dv_cost[1][MV_MAX] };
+
+        int32_t mvRate = av1_mv_bit_cost(
+            &mv,
+            &ref_mv,
+            candidate_ptr->md_rate_estimation_ptr->dv_joint_cost,
+            dvcost, MV_COST_WEIGHT_SUB);
+
+        rate = mvRate + candidate_ptr->md_rate_estimation_ptr->intrabcFacBits[candidate_ptr->use_intrabc];
+
+        candidate_ptr->fast_luma_rate = rate;
+        candidate_ptr->fast_chroma_rate = 0;
+
+        lumaSad = (LUMA_WEIGHT * luma_distortion) << AV1_COST_PRECISION;
+        chromaSad = chroma_distortion << AV1_COST_PRECISION;
+        totalDistortion = lumaSad + chromaSad;
+
+       
+        return(RDCOST(lambda, rate, totalDistortion));
+
+    }
+    else {
+#endif
+
     EbBool isMonochromeFlag = EB_FALSE; // NM - isMonochromeFlag is harcoded to false.
 #if REST_FAST_RATE_EST
     EbBool isCflAllowed = (blk_geom->bwidth <= 32 && blk_geom->bheight <= 32) ? 1 : 0;
@@ -731,6 +784,10 @@ EbErrorType av1_intra_fast_cost(
     uint32_t isInterRate = picture_control_set_ptr->slice_type != I_SLICE ? candidate_buffer_ptr->candidate_ptr->md_rate_estimation_ptr->intraInterFacBits[cu_ptr->is_inter_ctx][0] : 0;
 #endif
     lumaRate = intraModeBitsNum + skipModeRate + intraLumaModeBitsNum + intraLumaAngModeBitsNum + isInterRate;
+#if ICOPY
+    if (av1_allow_intrabc(picture_control_set_ptr->parent_pcs_ptr->av1_cm))
+        lumaRate += candidate_ptr->md_rate_estimation_ptr->intrabcFacBits[candidate_ptr->use_intrabc];
+#endif
 
     chromaRate = intraChromaModeBitsNum + intraChromaAngModeBitsNum;
 
@@ -792,6 +849,9 @@ EbErrorType av1_intra_fast_cost(
 #if USE_SSE_FL
     }
 #endif
+#if ICOPY
+    }
+#endif
 }
 
 //extern INLINE int32_t have_newmv_in_inter_mode(PredictionMode mode);
diff --git a/Source/Lib/Codec/EbResourceCoordinationProcess.c b/Source/Lib/Codec/EbResourceCoordinationProcess.c
index 30e7d70..d322c29 100644
--- a/Source/Lib/Codec/EbResourceCoordinationProcess.c
+++ b/Source/Lib/Codec/EbResourceCoordinationProcess.c
@@ -300,8 +300,10 @@ void ResetPcsAv1(
     picture_control_set_ptr->disable_cdf_update = 0;
     picture_control_set_ptr->allow_high_precision_mv = 0;
     picture_control_set_ptr->cur_frame_force_integer_mv = 0;  // 0 the default in AOM, 1 only integer
+#if !ICOPY
     picture_control_set_ptr->allow_screen_content_tools = 0;
     picture_control_set_ptr->allow_intrabc = 0;
+#endif
     picture_control_set_ptr->allow_warped_motion = 0;
 
     /* profile settings */
diff --git a/Source/Lib/Codec/EbRestProcess.c b/Source/Lib/Codec/EbRestProcess.c
index c384f21..9007b7c 100644
--- a/Source/Lib/Codec/EbRestProcess.c
+++ b/Source/Lib/Codec/EbRestProcess.c
@@ -238,7 +238,11 @@ void* rest_kernel(void *input_ptr)
 
 #if  REST_M
 
+#if ICOPY
+        if (sequence_control_set_ptr->enable_restoration && picture_control_set_ptr->parent_pcs_ptr->allow_intrabc == 0)
+#else
         if (sequence_control_set_ptr->enable_restoration)
+#endif
         {
             get_own_recon(sequence_control_set_ptr, picture_control_set_ptr, context_ptr, is16bit);
 
@@ -279,9 +283,13 @@ void* rest_kernel(void *input_ptr)
 
 #if REST_REF_ONLY
             if (sequence_control_set_ptr->enable_restoration && picture_control_set_ptr->parent_pcs_ptr->is_used_as_reference_flag) {
+#else
+#if ICOPY
+            if (sequence_control_set_ptr->enable_restoration && picture_control_set_ptr->parent_pcs_ptr->allow_intrabc == 0) {
 #else
             if (sequence_control_set_ptr->enable_restoration) {
 #endif
+#endif
 
 #if  !REST_M
                 av1_loop_restoration_save_boundary_lines(
diff --git a/Source/Lib/Codec/EbSequenceControlSet.c b/Source/Lib/Codec/EbSequenceControlSet.c
index 8f93782..8d52461 100644
--- a/Source/Lib/Codec/EbSequenceControlSet.c
+++ b/Source/Lib/Codec/EbSequenceControlSet.c
@@ -170,7 +170,11 @@ EbErrorType eb_sequence_control_set_ctor(
 
     sequence_control_set_ptr->order_hint_bits_minus1 = sequence_control_set_ptr->enable_order_hint ? 6 : -1;
 
+#if ICOPY
+    sequence_control_set_ptr->force_screen_content_tools = 2;
+#else
     sequence_control_set_ptr->force_screen_content_tools = 0;
+#endif
     // 0 - force off
     // 1 - force on
     // 2 - adaptive
diff --git a/Source/Lib/Codec/av1me.c b/Source/Lib/Codec/av1me.c
new file mode 100644
index 0000000..607c9bd
--- /dev/null
+++ b/Source/Lib/Codec/av1me.c
@@ -0,0 +1,1106 @@
+/*
+ * Copyright (c) 2016, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 2 Clause License and
+ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
+ * was not distributed with this source code in the LICENSE file, you can
+ * obtain it at www.aomedia.org/license/software. If the Alliance for Open
+ * Media Patent License 1.0 was not distributed with this source code in the
+ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
+ */
+
+#include <limits.h>
+#include <math.h>
+#include <stdio.h>
+#include "EbDefinitions.h"
+#if ICOPY
+#include "EbCodingUnit.h"
+#include "av1me.h"
+#include "EbPictureControlSet.h"
+#include "EbSequenceControlSet.h"
+#include "EbComputeSAD.h"
+
+
+int av1_is_dv_valid(const MV dv,
+    const MacroBlockD *xd, int mi_row, int mi_col,
+    block_size bsize, int mib_size_log2);
+
+void clamp_mv(
+    MV *mv,
+    int32_t min_col,
+    int32_t max_col,
+    int32_t min_row,
+    int32_t max_row);
+
+typedef struct dist_wtd_comp_params {
+    int use_dist_wtd_comp_avg;
+    int fwd_offset;
+    int bck_offset;
+} DIST_WTD_COMP_PARAMS;
+typedef unsigned int(*aom_sad_fn_t)(const uint8_t *a, int a_stride,
+    const uint8_t *b, int b_stride);
+
+typedef unsigned int(*aom_sad_avg_fn_t)(const uint8_t *a, int a_stride,
+    const uint8_t *b, int b_stride,
+    const uint8_t *second_pred);
+
+typedef void(*aom_copy32xn_fn_t)(const uint8_t *a, int a_stride, uint8_t *b,
+    int b_stride, int n);
+
+typedef void(*aom_sad_multi_d_fn_t)(const uint8_t *a, int a_stride,
+    const uint8_t *const b_array[],
+    int b_stride, unsigned int *sad_array);
+
+typedef unsigned int(*aom_variance_fn_t)(const uint8_t *a, int a_stride,
+    const uint8_t *b, int b_stride,
+    unsigned int *sse);
+
+typedef unsigned int(*aom_subpixvariance_fn_t)(const uint8_t *a, int a_stride,
+    int xoffset, int yoffset,
+    const uint8_t *b, int b_stride,
+    unsigned int *sse);
+
+typedef unsigned int(*aom_subp_avg_variance_fn_t)(
+    const uint8_t *a, int a_stride, int xoffset, int yoffset, const uint8_t *b,
+    int b_stride, unsigned int *sse, const uint8_t *second_pred);
+
+typedef unsigned int(*aom_dist_wtd_sad_avg_fn_t)(
+    const uint8_t *a, int a_stride, const uint8_t *b, int b_stride,
+    const uint8_t *second_pred, const DIST_WTD_COMP_PARAMS *jcp_param);
+
+typedef unsigned int(*aom_dist_wtd_subp_avg_variance_fn_t)(
+    const uint8_t *a, int a_stride, int xoffset, int yoffset, const uint8_t *b,
+    int b_stride, unsigned int *sse, const uint8_t *second_pred,
+    const DIST_WTD_COMP_PARAMS *jcp_param);
+
+typedef unsigned int(*aom_masked_sad_fn_t)(const uint8_t *src, int src_stride,
+    const uint8_t *ref, int ref_stride,
+    const uint8_t *second_pred,
+    const uint8_t *msk, int msk_stride,
+    int invert_mask);
+typedef unsigned int(*aom_masked_subpixvariance_fn_t)(
+    const uint8_t *src, int src_stride, int xoffset, int yoffset,
+    const uint8_t *ref, int ref_stride, const uint8_t *second_pred,
+    const uint8_t *msk, int msk_stride, int invert_mask, unsigned int *sse);
+typedef unsigned int(*aom_obmc_sad_fn_t)(const uint8_t *pred, int pred_stride,
+    const int32_t *wsrc,
+    const int32_t *msk);
+typedef unsigned int(*aom_obmc_variance_fn_t)(const uint8_t *pred,
+    int pred_stride,
+    const int32_t *wsrc,
+    const int32_t *msk,
+    unsigned int *sse);
+typedef unsigned int(*aom_obmc_subpixvariance_fn_t)(
+    const uint8_t *pred, int pred_stride, int xoffset, int yoffset,
+    const int32_t *wsrc, const int32_t *msk, unsigned int *sse);
+
+typedef struct aom_variance_vtable {
+    aom_sad_fn_t sdf;                   
+    aom_variance_fn_t vf; 
+    aom_sad_multi_d_fn_t sdx4df;         
+} aom_variance_fn_ptr_t;
+
+int av1_refining_search_sad(IntraBcContext  *x, MV *ref_mv, int error_per_bit,
+    int search_range,
+    const aom_variance_fn_ptr_t *fn_ptr,
+    const MV *center_mv);
+/* Sum the difference between every corresponding element of the buffers. */
+static INLINE unsigned int sad(const uint8_t *a, int a_stride, const uint8_t *b,
+    int b_stride, int width, int height) {
+    int y, x;
+    unsigned int sad = 0;
+
+    for (y = 0; y < height; y++) {
+        for (x = 0; x < width; x++) {
+            sad += abs(a[x] - b[x]);
+        }
+
+        a += a_stride;
+        b += b_stride;
+    }
+    return sad;
+}
+#if 1
+#define sadMxh(m)                                                          \
+  unsigned int aom_sad##m##xh_c(const uint8_t *a, int a_stride,            \
+                                const uint8_t *b, int b_stride, int width, \
+                                int height) {                              \
+    return NxMSadKernelSubSampled_funcPtrArray[ASM_AVX2][width >> 3]((uint8_t *)a, a_stride, (uint8_t *)b, b_stride, width, height);  \
+  }
+#define sadMxNx4D(m, n)                                                    \
+  void aom_sad##m##x##n##x4d_c(const uint8_t *src, int src_stride,         \
+                               const uint8_t *const ref_array[],           \
+                               int ref_stride, uint32_t *sad_array) {      \
+    int i;                                                                 \
+    for (i = 0; i < 4; ++i) {                                              \
+      sad_array[i] =                                                       \
+          NxMSadKernelSubSampled_funcPtrArray[ASM_AVX2][m >> 3]((uint8_t *)src, src_stride, (uint8_t *)(ref_array[i]), ref_stride, m, n);   \
+    }                                                                      \
+  }
+#define sadMxN(m, n)                                                          \
+  unsigned int aom_sad##m##x##n##_c(const uint8_t *src, int src_stride,       \
+                                    const uint8_t *ref, int ref_stride) {     \
+return NxMSadKernelSubSampled_funcPtrArray[ASM_AVX2][m >> 3]((uint8_t *)src, src_stride, (uint8_t *)ref, ref_stride, m, n);  \
+  } 
+#else
+#define sadMxh(m)                                                          \
+  unsigned int aom_sad##m##xh_c(const uint8_t *a, int a_stride,            \
+                                const uint8_t *b, int b_stride, int width, \
+                                int height) {                              \
+    return sad(a, a_stride, b, b_stride, width, height);                   \
+  }
+
+#define sadMxN(m, n)                                                          \
+  unsigned int aom_sad##m##x##n##_c(const uint8_t *src, int src_stride,       \
+                                    const uint8_t *ref, int ref_stride) {     \
+   return sad(src, src_stride, ref, ref_stride, m, n);    \
+  }                                                                           \
+  
+
+// Calculate sad against 4 reference locations and store each in sad_array
+#define sadMxNx4D(m, n)                                                    \
+  void aom_sad##m##x##n##x4d_c(const uint8_t *src, int src_stride,         \
+                               const uint8_t *const ref_array[],           \
+                               int ref_stride, uint32_t *sad_array) {      \
+    int i;                                                                 \
+    for (i = 0; i < 4; ++i) {                                              \
+      sad_array[i] =                                                       \
+          aom_sad##m##x##n##_c(src, src_stride, ref_array[i], ref_stride); \
+    }                                                                      \
+  }
+#endif
+// 128x128
+sadMxN(128, 128);
+sadMxNx4D(128, 128);
+// 128x64
+sadMxN(128, 64);
+sadMxNx4D(128, 64);
+// 64x128
+sadMxN(64, 128);
+sadMxNx4D(64, 128);
+// 64x64
+sadMxN(64, 64);
+sadMxNx4D(64, 64);
+// 64x32
+sadMxN(64, 32);
+sadMxNx4D(64, 32);
+// 32x64
+sadMxN(32, 64);
+sadMxNx4D(32, 64);
+// 32x32
+sadMxN(32, 32);
+sadMxNx4D(32, 32);
+// 32x16
+sadMxN(32, 16);
+sadMxNx4D(32, 16);
+// 16x32
+sadMxN(16, 32);
+sadMxNx4D(16, 32);
+// 16x16
+sadMxN(16, 16);
+sadMxNx4D(16, 16);
+// 16x8
+sadMxN(16, 8);
+sadMxNx4D(16, 8);
+// 8x16
+sadMxN(8, 16);
+sadMxNx4D(8, 16);
+// 8x8
+sadMxN(8, 8);
+sadMxNx4D(8, 8);
+// 8x4
+sadMxN(8, 4);
+sadMxNx4D(8, 4);
+// 4x8
+sadMxN(4, 8);
+sadMxNx4D(4, 8);
+// 4x4
+sadMxN(4, 4);
+sadMxNx4D(4, 4);
+
+sadMxh(128);
+sadMxh(64);
+sadMxh(32);
+sadMxh(16);
+sadMxh(8);
+sadMxh(4);
+
+sadMxN(4, 16);
+sadMxNx4D(4, 16);
+sadMxN(16, 4);
+sadMxNx4D(16, 4);
+sadMxN(8, 32);
+sadMxNx4D(8, 32);
+sadMxN(32, 8);
+sadMxNx4D(32, 8);
+sadMxN(16, 64);
+sadMxNx4D(16, 64);
+sadMxN(64, 16);
+sadMxNx4D(64, 16);
+
+static void variance(const uint8_t *a, int a_stride, const uint8_t *b,
+    int b_stride, int w, int h, uint32_t *sse, int *sum) {
+    int i, j;
+
+    *sum = 0;
+    *sse = 0;
+
+    for (i = 0; i < h; ++i) {
+        for (j = 0; j < w; ++j) {
+            const int diff = a[j] - b[j];
+            *sum += diff;
+            *sse += diff * diff;
+        }
+
+        a += a_stride;
+        b += b_stride;
+    }
+}
+#define VAR(W, H)                                                    \
+  uint32_t aom_variance##W##x##H##_c(const uint8_t *a, int a_stride, \
+                                     const uint8_t *b, int b_stride, \
+                                     uint32_t *sse) {                \
+    int sum;                                                         \
+    variance(a, a_stride, b, b_stride, W, H, sse, &sum);             \
+    return *sse - (uint32_t)(((int64_t)sum * sum) / (W * H));        \
+  }
+
+VAR(128, 128)
+VAR(128, 64)
+VAR(64, 128)
+VAR(64, 64)
+VAR(64, 32)
+VAR(32, 64)
+VAR(32, 32)
+VAR(32, 16)
+VAR(16, 32)
+VAR(16, 16)
+VAR(16, 8)
+VAR(8, 16)
+VAR(8, 8)
+VAR(8, 4)
+VAR(4, 8)
+VAR(4, 4)
+VAR(4, 2)
+VAR(2, 4)
+VAR(2, 2)
+VAR(4, 16)
+VAR(16, 4)
+VAR(8, 32)
+VAR(32, 8)
+VAR(16, 64)
+VAR(64, 16)
+
+aom_variance_fn_ptr_t mefn_ptr[BlockSizeS_ALL];
+
+void init_fn_ptr(void)
+{
+#define BFP0(BT, SDF, VF, SDX4DF)                            \
+  mefn_ptr[BT].sdf = SDF;                                    \
+  mefn_ptr[BT].vf = VF;                                      \
+  mefn_ptr[BT].sdx4df = SDX4DF;
+
+      
+        BFP0(BLOCK_4X16, aom_sad4x16_c, aom_variance4x16_c, aom_sad4x16x4d_c)  
+       
+        BFP0(BLOCK_16X4, aom_sad16x4_c, aom_variance16x4_c, aom_sad16x4x4d_c)
+       
+        BFP0(BLOCK_8X32, aom_sad8x32_c, aom_variance8x32_c, aom_sad8x32x4d_c)
+
+        BFP0(BLOCK_32X8, aom_sad32x8_c, aom_variance32x8_c, aom_sad32x8x4d_c)
+
+        BFP0(BLOCK_16X64, aom_sad16x64_c, aom_variance16x64_c, aom_sad16x64x4d_c)
+
+        BFP0(BLOCK_64X16, aom_sad64x16_c, aom_variance64x16_c, aom_sad64x16x4d_c)
+
+        BFP0(BLOCK_128X128, aom_sad128x128_c, aom_variance128x128_c, aom_sad128x128x4d_c)
+
+        BFP0(BLOCK_128X64, aom_sad128x64_c, aom_variance128x64_c, aom_sad128x64x4d_c)
+
+        BFP0(BLOCK_64X128, aom_sad64x128_c, aom_variance64x128_c, aom_sad64x128x4d_c)
+
+     
+        BFP0(BLOCK_32X16, aom_sad32x16_c, aom_variance32x16_c, aom_sad32x16x4d_c)
+
+        BFP0(BLOCK_16X32, aom_sad16x32_c, aom_variance16x32_c, aom_sad16x32x4d_c)
+
+        BFP0(BLOCK_64X32, aom_sad64x32_c, aom_variance64x32_c, aom_sad64x32x4d_c)
+
+     
+        BFP0(BLOCK_32X64, aom_sad32x64_c, aom_variance32x64_c, aom_sad32x64x4d_c)
+
+      
+        BFP0(BLOCK_32X32, aom_sad32x32_c, aom_variance32x32_c, aom_sad32x32x4d_c)
+
+        BFP0(BLOCK_64X64, aom_sad64x64_c, aom_variance64x64_c, aom_sad64x64x4d_c)
+
+       
+        BFP0(BLOCK_16X16, aom_sad16x16_c, aom_variance16x16_c, aom_sad16x16x4d_c)
+
+        BFP0(BLOCK_16X8, aom_sad16x8_c, aom_variance16x8_c, aom_sad16x8x4d_c)
+
+     
+        BFP0(BLOCK_8X16, aom_sad8x16_c, aom_variance8x16_c, aom_sad8x16x4d_c)
+
+        BFP0(BLOCK_8X8, aom_sad8x8_c, aom_variance8x8_c, aom_sad8x8x4d_c)
+
+        BFP0(BLOCK_8X4, aom_sad8x4_c, aom_variance8x4_c, aom_sad8x4x4d_c)
+        
+       
+        BFP0(BLOCK_4X8, aom_sad4x8_c, aom_variance4x8_c, aom_sad4x8x4d_c)
+       
+        BFP0(BLOCK_4X4, aom_sad4x4_c, aom_variance4x4_c, aom_sad4x4x4d_c)
+}
+
+
+// #define NEW_DIAMOND_SEARCH
+
+static INLINE const uint8_t *get_buf_from_mv(const struct buf_2d *buf,
+                                             const MV *mv) {
+  return &buf->buf[mv->row * buf->stride + mv->col];
+}
+
+void av1_set_mv_search_range(MvLimits *mv_limits, const MV *mv) {
+  int col_min = (mv->col >> 3) - MAX_FULL_PEL_VAL + (mv->col & 7 ? 1 : 0);
+  int row_min = (mv->row >> 3) - MAX_FULL_PEL_VAL + (mv->row & 7 ? 1 : 0);
+  int col_max = (mv->col >> 3) + MAX_FULL_PEL_VAL;
+  int row_max = (mv->row >> 3) + MAX_FULL_PEL_VAL;
+
+  col_min = AOMMAX(col_min, (MV_LOW >> 3) + 1);
+  row_min = AOMMAX(row_min, (MV_LOW >> 3) + 1);
+  col_max = AOMMIN(col_max, (MV_UPP >> 3) - 1);
+  row_max = AOMMIN(row_max, (MV_UPP >> 3) - 1);
+
+  // Get intersection of UMV window and valid MV window to reduce # of checks
+  // in diamond search.
+  if (mv_limits->col_min < col_min) mv_limits->col_min = col_min;
+  if (mv_limits->col_max > col_max) mv_limits->col_max = col_max;
+  if (mv_limits->row_min < row_min) mv_limits->row_min = row_min;
+  if (mv_limits->row_max > row_max) mv_limits->row_max = row_max;
+}
+
+
+
+MV_JOINT_TYPE av1_get_mv_joint(const MV *mv);
+
+static INLINE int mv_cost(const MV *mv, const int *joint_cost,
+                          int *const comp_cost[2]) {
+  return joint_cost[av1_get_mv_joint(mv)] + comp_cost[0][mv->row] +
+         comp_cost[1][mv->col];
+}
+
+
+#define PIXEL_TRANSFORM_ERROR_SCALE 4
+static int mv_err_cost(const MV *mv, const MV *ref, const int *mvjcost,
+                       int *mvcost[2], int error_per_bit) {
+  if (mvcost) {
+    const MV diff = { mv->row - ref->row, mv->col - ref->col };
+    return (int)ROUND_POWER_OF_TWO_64(
+        (int64_t)mv_cost(&diff, mvjcost, mvcost) * error_per_bit,
+        RDDIV_BITS + AV1_PROB_COST_SHIFT - RD_EPB_SHIFT +
+            PIXEL_TRANSFORM_ERROR_SCALE);
+  }
+  return 0;
+}
+
+static int mvsad_err_cost(const IntraBcContext *x, const MV *mv, const MV *ref,
+                          int sad_per_bit) {
+  const MV diff = { (mv->row - ref->row) * 8, (mv->col - ref->col) * 8 };
+  return ROUND_POWER_OF_TWO(
+      (unsigned)mv_cost(&diff, x->nmv_vec_cost, x->mv_cost_stack) * sad_per_bit,
+      AV1_PROB_COST_SHIFT);
+}
+
+void av1_init3smotion_compensation(search_site_config *cfg, int stride) {
+  int len, ss_count = 1;
+
+  cfg->ss[0].mv.col = cfg->ss[0].mv.row = 0;
+  cfg->ss[0].offset = 0;
+
+  for (len = MAX_FIRST_STEP; len > 0; len /= 2) {
+    // Generate offsets for 8 search sites per step.
+    const MV ss_mvs[8] = { { -len, 0 },   { len, 0 },     { 0, -len },
+                           { 0, len },    { -len, -len }, { -len, len },
+                           { len, -len }, { len, len } };
+    int i;
+    for (i = 0; i < 8; ++i) {
+      search_site *const ss = &cfg->ss[ss_count++];
+      ss->mv = ss_mvs[i];
+      ss->offset = ss->mv.row * stride + ss->mv.col;
+    }
+  }
+
+  cfg->ss_count = ss_count;
+  cfg->searches_per_step = 8;
+}
+
+static INLINE int check_bounds(const MvLimits *mv_limits, int row, int col,
+                               int range) {
+  return ((row - range) >= mv_limits->row_min) &
+         ((row + range) <= mv_limits->row_max) &
+         ((col - range) >= mv_limits->col_min) &
+         ((col + range) <= mv_limits->col_max);
+}
+
+static INLINE int is_mv_in(const MvLimits *mv_limits, const MV *mv) {
+  return (mv->col >= mv_limits->col_min) && (mv->col <= mv_limits->col_max) &&
+         (mv->row >= mv_limits->row_min) && (mv->row <= mv_limits->row_max);
+}
+
+#define CHECK_BETTER                                                      \
+  {                                                                       \
+    if (thissad < bestsad) {                                              \
+      if (use_mvcost)                                                     \
+        thissad += mvsad_err_cost(x, &this_mv, &fcenter_mv, sad_per_bit); \
+      if (thissad < bestsad) {                                            \
+        bestsad = thissad;                                                \
+        best_site = i;                                                    \
+      }                                                                   \
+    }                                                                     \
+  }
+
+#define MAX_PATTERN_SCALES 11
+#define MAX_PATTERN_CANDIDATES 8  // max number of canddiates per scale
+#define PATTERN_CANDIDATES_REF 3  // number of refinement candidates
+
+int av1_get_mvpred_var(const IntraBcContext *x, const MV *best_mv,
+                       const MV *center_mv, const aom_variance_fn_ptr_t *vfp,
+                       int use_mvcost) {
+   
+  const struct buf_2d *const what = &x->plane[0].src;
+  const struct buf_2d *const in_what = &x->xdplane[0].pre[0];
+  const MV mv = { best_mv->row * 8, best_mv->col * 8 };
+  unsigned int unused;
+
+  return vfp->vf(what->buf, what->stride, get_buf_from_mv(in_what, best_mv),
+                 in_what->stride, &unused) +
+         (use_mvcost ? mv_err_cost(&mv, center_mv, x->nmv_vec_cost,
+                                   x->mv_cost_stack, x->errorperbit)
+                     : 0);
+}
+
+// Exhuastive motion search around a given centre position with a given
+// step size.
+static int exhuastive_mesh_search(IntraBcContext  *x, MV *ref_mv, MV *best_mv,
+                                  int range, int step, int sad_per_bit,
+                                  const aom_variance_fn_ptr_t *fn_ptr,
+                                  const MV *center_mv) {
+   
+  const struct buf_2d *const what = &x->plane[0].src;
+  const struct buf_2d *const in_what = &x->xdplane[0].pre[0];
+  MV fcenter_mv = { center_mv->row, center_mv->col };
+  unsigned int best_sad = INT_MAX;
+  int r, c, i;
+  int start_col, end_col, start_row, end_row;
+  int col_step = (step > 1) ? step : 4;
+
+  assert(step >= 1);
+
+  clamp_mv(&fcenter_mv, x->mv_limits.col_min, x->mv_limits.col_max,
+           x->mv_limits.row_min, x->mv_limits.row_max);
+  *best_mv = fcenter_mv;
+  best_sad =
+      fn_ptr->sdf(what->buf, what->stride,
+                  get_buf_from_mv(in_what, &fcenter_mv), in_what->stride) +
+      mvsad_err_cost(x, &fcenter_mv, ref_mv, sad_per_bit);
+  start_row = AOMMAX(-range, x->mv_limits.row_min - fcenter_mv.row);
+  start_col = AOMMAX(-range, x->mv_limits.col_min - fcenter_mv.col);
+  end_row = AOMMIN(range, x->mv_limits.row_max - fcenter_mv.row);
+  end_col = AOMMIN(range, x->mv_limits.col_max - fcenter_mv.col);
+
+  for (r = start_row; r <= end_row; r += step) {
+    for (c = start_col; c <= end_col; c += col_step) {
+      // Step > 1 means we are not checking every location in this pass.
+      if (step > 1) {
+        const MV mv = { fcenter_mv.row + r, fcenter_mv.col + c };
+        unsigned int sad =
+            fn_ptr->sdf(what->buf, what->stride, get_buf_from_mv(in_what, &mv),
+                        in_what->stride);
+        if (sad < best_sad) {
+          sad += mvsad_err_cost(x, &mv, ref_mv, sad_per_bit);
+          if (sad < best_sad) {
+            best_sad = sad;
+            x->second_best_mv.as_mv = *best_mv;
+            *best_mv = mv;
+          }
+        }
+      } else {
+        // 4 sads in a single call if we are checking every location
+        if (c + 3 <= end_col) {
+          unsigned int sads[4];
+          const uint8_t *addrs[4];
+          for (i = 0; i < 4; ++i) {
+            const MV mv = { fcenter_mv.row + r, fcenter_mv.col + c + i };
+            addrs[i] = get_buf_from_mv(in_what, &mv);
+          }
+          fn_ptr->sdx4df(what->buf, what->stride, addrs, in_what->stride, sads);
+
+          for (i = 0; i < 4; ++i) {
+            if (sads[i] < best_sad) {
+              const MV mv = { fcenter_mv.row + r, fcenter_mv.col + c + i };
+              const unsigned int sad =
+                  sads[i] + mvsad_err_cost(x, &mv, ref_mv, sad_per_bit);
+              if (sad < best_sad) {
+                best_sad = sad;
+                x->second_best_mv.as_mv = *best_mv;
+                *best_mv = mv;
+              }
+            }
+          }
+        } else {
+          for (i = 0; i < end_col - c; ++i) {
+            const MV mv = { fcenter_mv.row + r, fcenter_mv.col + c + i };
+            unsigned int sad =
+                fn_ptr->sdf(what->buf, what->stride,
+                            get_buf_from_mv(in_what, &mv), in_what->stride);
+            if (sad < best_sad) {
+              sad += mvsad_err_cost(x, &mv, ref_mv, sad_per_bit);
+              if (sad < best_sad) {
+                best_sad = sad;
+                x->second_best_mv.as_mv = *best_mv;
+                *best_mv = mv;
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+
+  return best_sad;
+}
+
+
+int av1_diamond_search_sad_c(IntraBcContext  *x, const search_site_config *cfg,
+                             MV *ref_mv, MV *best_mv, int search_param,
+                             int sad_per_bit, int *num00,
+                             const aom_variance_fn_ptr_t *fn_ptr,
+                             const MV *center_mv) {
+  int i, j, step;
+
+ 
+  uint8_t *what = x->plane[0].src.buf;
+  const int what_stride = x->plane[0].src.stride;
+  const uint8_t *in_what;
+  const int in_what_stride = x->xdplane[0].pre[0].stride;
+  const uint8_t *best_address;
+
+  unsigned int bestsad = INT_MAX;
+  int best_site = 0;
+  int last_site = 0;
+
+  int ref_row;
+  int ref_col;
+
+  // search_param determines the length of the initial step and hence the number
+  // of iterations.
+  // 0 = initial step (MAX_FIRST_STEP) pel
+  // 1 = (MAX_FIRST_STEP/2) pel,
+  // 2 = (MAX_FIRST_STEP/4) pel...
+  const search_site *ss = &cfg->ss[search_param * cfg->searches_per_step];
+  const int tot_steps = (cfg->ss_count / cfg->searches_per_step) - search_param;
+
+  const MV fcenter_mv = { center_mv->row >> 3, center_mv->col >> 3 };
+  clamp_mv(ref_mv, x->mv_limits.col_min, x->mv_limits.col_max,
+           x->mv_limits.row_min, x->mv_limits.row_max);
+  ref_row = ref_mv->row;
+  ref_col = ref_mv->col;
+  *num00 = 0;
+  best_mv->row = ref_row;
+  best_mv->col = ref_col;
+
+  // Work out the start point for the search
+  in_what = x->xdplane[0].pre[0].buf + ref_row * in_what_stride + ref_col;
+  best_address = in_what;
+
+  // Check the starting position
+  bestsad = fn_ptr->sdf(what, what_stride, in_what, in_what_stride) +
+            mvsad_err_cost(x, best_mv, &fcenter_mv, sad_per_bit);
+
+  i = 1;
+
+  for (step = 0; step < tot_steps; step++) {
+    int all_in = 1, t;
+
+    // All_in is true if every one of the points we are checking are within
+    // the bounds of the image.
+    all_in &= ((best_mv->row + ss[i].mv.row) > x->mv_limits.row_min);
+    all_in &= ((best_mv->row + ss[i + 1].mv.row) < x->mv_limits.row_max);
+    all_in &= ((best_mv->col + ss[i + 2].mv.col) > x->mv_limits.col_min);
+    all_in &= ((best_mv->col + ss[i + 3].mv.col) < x->mv_limits.col_max);
+
+    // If all the pixels are within the bounds we don't check whether the
+    // search point is valid in this loop,  otherwise we check each point
+    // for validity..
+    if (all_in) {
+      unsigned int sad_array[4];
+
+      for (j = 0; j < cfg->searches_per_step; j += 4) {
+        unsigned char const *block_offset[4];
+
+        for (t = 0; t < 4; t++)
+          block_offset[t] = ss[i + t].offset + best_address;
+
+        fn_ptr->sdx4df(what, what_stride, block_offset, in_what_stride,
+                       sad_array);
+
+        for (t = 0; t < 4; t++, i++) {
+          if (sad_array[t] < bestsad) {
+            const MV this_mv = { best_mv->row + ss[i].mv.row,
+                                 best_mv->col + ss[i].mv.col };
+            sad_array[t] +=
+                mvsad_err_cost(x, &this_mv, &fcenter_mv, sad_per_bit);
+            if (sad_array[t] < bestsad) {
+              bestsad = sad_array[t];
+              best_site = i;
+            }
+          }
+        }
+      }
+    } else {
+      for (j = 0; j < cfg->searches_per_step; j++) {
+        // Trap illegal vectors
+        const MV this_mv = { best_mv->row + ss[i].mv.row,
+                             best_mv->col + ss[i].mv.col };
+
+        if (is_mv_in(&x->mv_limits, &this_mv)) {
+          const uint8_t *const check_here = ss[i].offset + best_address;
+          unsigned int thissad =
+              fn_ptr->sdf(what, what_stride, check_here, in_what_stride);
+
+          if (thissad < bestsad) {
+            thissad += mvsad_err_cost(x, &this_mv, &fcenter_mv, sad_per_bit);
+            if (thissad < bestsad) {
+              bestsad = thissad;
+              best_site = i;
+            }
+          }
+        }
+        i++;
+      }
+    }
+    if (best_site != last_site) {
+      x->second_best_mv.as_mv = *best_mv;
+      best_mv->row += ss[best_site].mv.row;
+      best_mv->col += ss[best_site].mv.col;
+      best_address += ss[best_site].offset;
+      last_site = best_site;
+#if defined(NEW_DIAMOND_SEARCH)
+      while (1) {
+        const MV this_mv = { best_mv->row + ss[best_site].mv.row,
+                             best_mv->col + ss[best_site].mv.col };
+        if (is_mv_in(&x->mv_limits, &this_mv)) {
+          const uint8_t *const check_here = ss[best_site].offset + best_address;
+          unsigned int thissad =
+              fn_ptr->sdf(what, what_stride, check_here, in_what_stride);
+          if (thissad < bestsad) {
+            thissad += mvsad_err_cost(x, &this_mv, &fcenter_mv, sad_per_bit);
+            if (thissad < bestsad) {
+              bestsad = thissad;
+              best_mv->row += ss[best_site].mv.row;
+              best_mv->col += ss[best_site].mv.col;
+              best_address += ss[best_site].offset;
+              continue;
+            }
+          }
+        }
+        break;
+      }
+#endif
+    } else if (best_address == in_what) {
+      (*num00)++;
+    }
+  }
+  return bestsad;
+}
+
+
+
+/* do_refine: If last step (1-away) of n-step search doesn't pick the center
+              point as the best match, we will do a final 1-away diamond
+              refining search  */
+static int full_pixel_diamond(PictureControlSet_t *pcs, IntraBcContext /*MACROBLOCK*/ *x,
+                              MV *mvp_full, int step_param, int sadpb,
+                              int further_steps, int do_refine, int *cost_list,
+                              const aom_variance_fn_ptr_t *fn_ptr,
+                              const MV *ref_mv) {
+  MV temp_mv;
+  int thissme, n, num00 = 0;
+  (void)cost_list;
+  /*int bestsme = cpi->diamond_search_sad(x, &cpi->ss_cfg, mvp_full, &temp_mv,
+                                        step_param, sadpb, &n, fn_ptr, ref_mv);*/
+  int bestsme = av1_diamond_search_sad_c(x, &pcs->ss_cfg, mvp_full, &temp_mv,
+      step_param, sadpb, &n, fn_ptr, ref_mv);
+
+  if (bestsme < INT_MAX)
+    bestsme = av1_get_mvpred_var(x, &temp_mv, ref_mv, fn_ptr, 1);
+  x->best_mv.as_mv = temp_mv;
+
+  // If there won't be more n-step search, check to see if refining search is
+  // needed.
+  if (n > further_steps) do_refine = 0;
+
+  while (n < further_steps) {
+    ++n;
+
+    if (num00) {
+      num00--;
+    } else {
+      /*thissme = cpi->diamond_search_sad(x, &cpi->ss_cfg, mvp_full, &temp_mv,
+                                        step_param + n, sadpb, &num00, fn_ptr,
+                                        ref_mv);*/
+      thissme = av1_diamond_search_sad_c(x, &pcs->ss_cfg, mvp_full, &temp_mv,
+          step_param + n, sadpb, &num00, fn_ptr,
+          ref_mv);
+
+      if (thissme < INT_MAX)
+        thissme = av1_get_mvpred_var(x, &temp_mv, ref_mv, fn_ptr, 1);
+
+      // check to see if refining search is needed.
+      if (num00 > further_steps - n) do_refine = 0;
+
+      if (thissme < bestsme) {
+        bestsme = thissme;
+        x->best_mv.as_mv = temp_mv;
+      }
+    }
+  }
+
+  // final 1-away diamond refining search
+  if (do_refine) {
+    const int search_range = 8;
+    MV best_mv = x->best_mv.as_mv;
+    thissme = av1_refining_search_sad(x, &best_mv, sadpb, search_range, fn_ptr,
+                                      ref_mv);
+    if (thissme < INT_MAX)
+      thissme = av1_get_mvpred_var(x, &best_mv, ref_mv, fn_ptr, 1);
+    if (thissme < bestsme) {
+      bestsme = thissme;
+      x->best_mv.as_mv = best_mv;
+    }
+  }
+
+  // Return cost list.
+ /* if (cost_list) {
+    calc_int_cost_list(x, ref_mv, sadpb, fn_ptr, &x->best_mv.as_mv, cost_list);
+  }*/
+  return bestsme;
+}
+
+#define MIN_RANGE 7
+#define MAX_RANGE 256
+#define MIN_INTERVAL 1
+// Runs an limited range exhaustive mesh search using a pattern set
+// according to the encode speed profile.
+static int full_pixel_exhaustive(PictureControlSet_t *pcs, IntraBcContext  *x,
+                                 const MV *centre_mv_full, int sadpb,
+                                 int *cost_list,
+                                 const aom_variance_fn_ptr_t *fn_ptr,
+                                 const MV *ref_mv, MV *dst_mv) {
+    const SPEED_FEATURES *const sf = &pcs->sf;// cpi->sf;
+  MV temp_mv = { centre_mv_full->row, centre_mv_full->col };
+  MV f_ref_mv = { ref_mv->row >> 3, ref_mv->col >> 3 };
+  int bestsme;
+  int i;
+  int interval = sf->mesh_patterns[0].interval;
+  int range = sf->mesh_patterns[0].range;
+  int baseline_interval_divisor;
+
+  // Keep track of number of exhaustive calls (this frame in this thread).
+  //CHKN if (x->ex_search_count_ptr != NULL) ++(*x->ex_search_count_ptr);
+
+  // Trap illegal values for interval and range for this function.
+  if ((range < MIN_RANGE) || (range > MAX_RANGE) || (interval < MIN_INTERVAL) ||
+      (interval > range))
+    return INT_MAX;
+
+  baseline_interval_divisor = range / interval;
+
+  // Check size of proposed first range against magnitude of the centre
+  // value used as a starting point.
+  range = AOMMAX(range, (5 * AOMMAX(abs(temp_mv.row), abs(temp_mv.col))) / 4);
+  range = AOMMIN(range, MAX_RANGE);
+  interval = AOMMAX(interval, range / baseline_interval_divisor);
+
+  // initial search
+  bestsme = exhuastive_mesh_search(x, &f_ref_mv, &temp_mv, range, interval,
+                                   sadpb, fn_ptr, &temp_mv);
+
+  if ((interval > MIN_INTERVAL) && (range > MIN_RANGE)) {
+    // Progressive searches with range and step size decreasing each time
+    // till we reach a step size of 1. Then break out.
+    for (i = 1; i < MAX_MESH_STEP; ++i) {
+      // First pass with coarser step and longer range
+      bestsme = exhuastive_mesh_search(
+          x, &f_ref_mv, &temp_mv, sf->mesh_patterns[i].range,
+          sf->mesh_patterns[i].interval, sadpb, fn_ptr, &temp_mv);
+
+      if (sf->mesh_patterns[i].interval == 1) break;
+    }
+  }
+
+  if (bestsme < INT_MAX)
+    bestsme = av1_get_mvpred_var(x, &temp_mv, ref_mv, fn_ptr, 1);
+  *dst_mv = temp_mv;
+
+  // Return cost list.
+ /* if (cost_list) {
+    calc_int_cost_list(x, ref_mv, sadpb, fn_ptr, dst_mv, cost_list);
+  }*/
+  return bestsme;
+}
+
+
+int av1_refining_search_sad(IntraBcContext  *x, MV *ref_mv, int error_per_bit,
+                            int search_range,
+                            const aom_variance_fn_ptr_t *fn_ptr,
+                            const MV *center_mv) {
+  
+  const MV neighbors[4] = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };
+  const struct buf_2d *const what = &x->plane[0].src;
+  const struct buf_2d *const in_what = &x->xdplane[0].pre[0];
+  const MV fcenter_mv = { center_mv->row >> 3, center_mv->col >> 3 };
+  const uint8_t *best_address = get_buf_from_mv(in_what, ref_mv);
+  unsigned int best_sad =
+      fn_ptr->sdf(what->buf, what->stride, best_address, in_what->stride) +
+      mvsad_err_cost(x, ref_mv, &fcenter_mv, error_per_bit);
+  int i, j;
+
+  for (i = 0; i < search_range; i++) {
+    int best_site = -1;
+    const int all_in = ((ref_mv->row - 1) > x->mv_limits.row_min) &
+                       ((ref_mv->row + 1) < x->mv_limits.row_max) &
+                       ((ref_mv->col - 1) > x->mv_limits.col_min) &
+                       ((ref_mv->col + 1) < x->mv_limits.col_max);
+
+    if (all_in) {
+      unsigned int sads[4];
+      const uint8_t *const positions[4] = { best_address - in_what->stride,
+                                            best_address - 1, best_address + 1,
+                                            best_address + in_what->stride };
+
+      fn_ptr->sdx4df(what->buf, what->stride, positions, in_what->stride, sads);
+
+      for (j = 0; j < 4; ++j) {
+        if (sads[j] < best_sad) {
+          const MV mv = { ref_mv->row + neighbors[j].row,
+                          ref_mv->col + neighbors[j].col };
+          sads[j] += mvsad_err_cost(x, &mv, &fcenter_mv, error_per_bit);
+          if (sads[j] < best_sad) {
+            best_sad = sads[j];
+            best_site = j;
+          }
+        }
+      }
+    } else {
+      for (j = 0; j < 4; ++j) {
+        const MV mv = { ref_mv->row + neighbors[j].row,
+                        ref_mv->col + neighbors[j].col };
+
+        if (is_mv_in(&x->mv_limits, &mv)) {
+          unsigned int sad =
+              fn_ptr->sdf(what->buf, what->stride,
+                          get_buf_from_mv(in_what, &mv), in_what->stride);
+          if (sad < best_sad) {
+            sad += mvsad_err_cost(x, &mv, &fcenter_mv, error_per_bit);
+            if (sad < best_sad) {
+              best_sad = sad;
+              best_site = j;
+            }
+          }
+        }
+      }
+    }
+
+    if (best_site == -1) {
+      break;
+    } else {
+      x->second_best_mv.as_mv = *ref_mv;
+      ref_mv->row += neighbors[best_site].row;
+      ref_mv->col += neighbors[best_site].col;
+      best_address = get_buf_from_mv(in_what, ref_mv);
+    }
+  }
+
+  return best_sad;
+}
+
+int av1_full_pixel_search(PictureControlSet_t *pcs, IntraBcContext  *x, block_size bsize,
+                          MV *mvp_full, int step_param, int method,
+                          int run_mesh_search, int error_per_bit,
+                          int *cost_list, const MV *ref_mv, int var_max, int rd,
+                          int x_pos, int y_pos, int intra) {
+
+
+  const SPEED_FEATURES *const sf = &pcs->sf;
+  const aom_variance_fn_ptr_t *fn_ptr = &mefn_ptr[bsize];
+  int var = 0;
+
+  if (cost_list) {
+    cost_list[0] = INT_MAX;
+    cost_list[1] = INT_MAX;
+    cost_list[2] = INT_MAX;
+    cost_list[3] = INT_MAX;
+    cost_list[4] = INT_MAX;
+  }
+
+  // Keep track of number of searches (this frame in this thread).
+  //if (x->m_search_count_ptr != NULL) ++(*x->m_search_count_ptr);
+
+  switch (method) {
+    case FAST_DIAMOND:
+      //var = fast_dia_search(x, mvp_full, step_param, error_per_bit, 0,
+      //                      cost_list, fn_ptr, 1, ref_mv);
+      break;
+    case FAST_HEX:
+      //var = fast_hex_search(x, mvp_full, step_param, error_per_bit, 0,
+      //                      cost_list, fn_ptr, 1, ref_mv);
+      break;
+    case HEX:
+      //var = av1_hex_search(x, mvp_full, step_param, error_per_bit, 1, cost_list,
+      //                     fn_ptr, 1, ref_mv);
+      break;
+    case SQUARE:
+      //var = square_search(x, mvp_full, step_param, error_per_bit, 1, cost_list,
+      //                    fn_ptr, 1, ref_mv);
+      break;
+    case BIGDIA:
+      //var = bigdia_search(x, mvp_full, step_param, error_per_bit, 1, cost_list,
+      //                    fn_ptr, 1, ref_mv);
+      break;
+    case NSTEP:
+      var = full_pixel_diamond(pcs, x, mvp_full, step_param, error_per_bit,
+                               MAX_MVSEARCH_STEPS - 1 - step_param, 1,
+                               cost_list, fn_ptr, ref_mv);
+
+      // Should we allow a follow on exhaustive search?
+      if(1)// (is_exhaustive_allowed(cpi, x))   
+      {
+        //int exhuastive_thr = sf->exhaustive_searches_thresh;
+        //exhuastive_thr >>=
+        //    10 - (mi_size_wide_log2[bsize] + mi_size_high_log2[bsize]);
+
+        // Threshold variance for an exhaustive full search.
+        //if (var > exhuastive_thr)   
+        {
+          int var_ex;
+          MV tmp_mv_ex;
+          var_ex =
+              full_pixel_exhaustive(pcs, x, &x->best_mv.as_mv, error_per_bit,
+                                    cost_list, fn_ptr, ref_mv, &tmp_mv_ex);
+
+          if (var_ex < var) {
+            var = var_ex;
+            x->best_mv.as_mv = tmp_mv_ex;
+          }
+        }
+      }
+
+      break;
+    default: assert(0 && "Invalid search method.");
+  }
+
+
+  // Should we allow a follow on exhaustive search?
+  if (!run_mesh_search) {
+    if (method == NSTEP) {
+      //if (is_exhaustive_allowed(cpi, x))
+      {
+        int exhuastive_thr = sf->exhaustive_searches_thresh;
+        exhuastive_thr >>=
+            10 - (mi_size_wide_log2[bsize] + mi_size_high_log2[bsize]);
+        // Threshold variance for an exhaustive full search.
+        if (var > exhuastive_thr) run_mesh_search = 1;
+      }
+    }
+  }
+
+  //if (run_mesh_search)
+  if(1)
+  {
+    int var_ex;
+    MV tmp_mv_ex;
+    var_ex = full_pixel_exhaustive(pcs, x, &x->best_mv.as_mv, error_per_bit,
+                                   cost_list, fn_ptr, ref_mv, &tmp_mv_ex);
+    if (var_ex < var) {
+      var = var_ex;
+      x->best_mv.as_mv = tmp_mv_ex;
+    }
+  }
+
+  if (method != NSTEP && rd && var < var_max)
+    var = av1_get_mvpred_var(x, &x->best_mv.as_mv, ref_mv, fn_ptr, 1);
+
+
+  do {
+    //CHKN if (!intra || !av1_use_hash_me(&cpi->common)) break;
+
+    // already single ME
+    // get block size and original buffer of current block
+    const int block_height = block_size_high[bsize];
+    const int block_width = block_size_wide[bsize];
+    if (block_height == block_width && x_pos >= 0 && y_pos >= 0) {
+      if (block_width == 4 || block_width == 8 || block_width == 16 ||
+          block_width == 32 || block_width == 64 || block_width == 128) {
+        uint8_t *what = x->plane[0].src.buf;
+        const int what_stride = x->plane[0].src.stride;
+        uint32_t hash_value1, hash_value2;
+        MV best_hash_mv;
+        int best_hash_cost = INT_MAX;
+
+        // for the hashMap
+        hash_table *ref_frame_hash = &pcs->hash_table;
+
+        av1_get_block_hash_value(what, what_stride, block_width, &hash_value1,
+                                 &hash_value2, 0, pcs, x);
+
+        const int count = av1_hash_table_count(ref_frame_hash, hash_value1);
+        // for intra, at least one matching can be found, itself.
+        if (count <= (intra ? 1 : 0)) {
+          break;
+        }
+ 
+        Iterator iterator =
+            av1_hash_get_first_iterator(ref_frame_hash, hash_value1);
+        for (int i = 0; i < count; i++, iterator_increment(&iterator)) {
+          block_hash ref_block_hash = *(block_hash *)(iterator_get(&iterator));
+          if (hash_value2 == ref_block_hash.hash_value2) {
+            // For intra, make sure the prediction is from valid area.
+            if (intra) {
+              const int mi_col = x_pos / MI_SIZE;
+              const int mi_row = y_pos / MI_SIZE;
+              const MV dv = { 8 * (ref_block_hash.y - y_pos),
+                              8 * (ref_block_hash.x - x_pos) };
+              if (!av1_is_dv_valid(dv, x->xd, mi_row, mi_col,
+                                   bsize, pcs->parent_pcs_ptr->sequence_control_set_ptr->mib_size_log2))
+                continue;
+            }
+            MV hash_mv;
+            hash_mv.col = ref_block_hash.x - x_pos;
+            hash_mv.row = ref_block_hash.y - y_pos;
+            if (!is_mv_in(&x->mv_limits, &hash_mv)) continue;
+            const int refCost =
+                av1_get_mvpred_var(x, &hash_mv, ref_mv, fn_ptr, 1);
+            if (refCost < best_hash_cost) {
+              best_hash_cost = refCost;
+              best_hash_mv = hash_mv;
+            }
+          }
+        }
+
+        if (best_hash_cost < var) {
+          x->second_best_mv = x->best_mv;
+          x->best_mv.as_mv = best_hash_mv;
+          var = best_hash_cost;
+        }
+
+
+      }
+    }
+  } while (0);
+
+
+  return 0;//CHKN  var;
+}
+
+#endif
diff --git a/Source/Lib/Codec/av1me.h b/Source/Lib/Codec/av1me.h
new file mode 100644
index 0000000..9e0fa1f
--- /dev/null
+++ b/Source/Lib/Codec/av1me.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) 2016, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 2 Clause License and
+ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
+ * was not distributed with this source code in the LICENSE file, you can
+ * obtain it at www.aomedia.org/license/software. If the Alliance for Open
+ * Media Patent License 1.0 was not distributed with this source code in the
+ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
+ */
+
+#ifndef AOM_AV1_ENCODER_MCOMP_H_
+#define AOM_AV1_ENCODER_MCOMP_H_
+
+#include "EbDefinitions.h"
+#include "EbCodingUnit.h"
+#include "EbUtility.h"
+
+
+
+//#include "av1/encoder/block.h"
+//#include "aom_dsp/variance.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// The maximum number of steps in a step search given the largest
+// allowed initial step
+#define MAX_MVSEARCH_STEPS 11
+// Max full pel mv specified in the unit of full pixel
+// Enable the use of motion vector in range [-1023, 1023].
+#define MAX_FULL_PEL_VAL ((1 << (MAX_MVSEARCH_STEPS - 1)) - 1)
+// Maximum size of the first step in full pel units
+#define MAX_FIRST_STEP (1 << (MAX_MVSEARCH_STEPS - 1))
+// Allowed motion vector pixel distance outside image border
+// for Block_16x16
+#define BORDER_MV_PIXELS_B16 (16 + AOM_INTERP_EXTEND)
+
+#define SEARCH_RANGE_8P 3
+#define SEARCH_GRID_STRIDE_8P (2 * SEARCH_RANGE_8P + 1)
+#define SEARCH_GRID_CENTER_8P \
+  (SEARCH_RANGE_8P * SEARCH_GRID_STRIDE_8P + SEARCH_RANGE_8P)
+
+// motion search site
+typedef struct search_site {
+  MV mv;
+  int offset;
+} search_site;
+
+typedef struct search_site_config {
+  search_site ss[8 * MAX_MVSEARCH_STEPS + 1];
+  int ss_count;
+  int searches_per_step;
+} search_site_config;
+
+typedef struct {
+  MV coord;
+  int coord_offset;
+} search_neighbors;
+
+
+void av1_init_dsmotion_compensation(search_site_config *cfg, int stride);
+void av1_init3smotion_compensation(search_site_config *cfg, int stride);
+
+void av1_set_mv_search_range(MvLimits *mv_limits, const MV *mv);
+
+#if 1 //---CHKN
+
+
+struct AV1_COMP;
+struct SPEED_FEATURES;
+
+
+int av1_full_pixel_search(struct PictureControlSet_s *pcs, IntraBcContext /*MACROBLOCK*/ *x,
+                          block_size bsize, MV *mvp_full, int step_param,
+                          int method, int run_mesh_search, int error_per_bit,
+                          int *cost_list, const MV *ref_mv, int var_max, int rd,
+                          int x_pos, int y_pos, int intra);
+
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif//----CHKN
+#endif  // AOM_AV1_ENCODER_MCOMP_H_
diff --git a/Source/Lib/Codec/hash.c b/Source/Lib/Codec/hash.c
new file mode 100644
index 0000000..4f54868
--- /dev/null
+++ b/Source/Lib/Codec/hash.c
@@ -0,0 +1,125 @@
+/*
+ * Copyright (c) 2016, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 2 Clause License and
+ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
+ * was not distributed with this source code in the LICENSE file, you can
+ * obtain it at www.aomedia.org/license/software. If the Alliance for Open
+ * Media Patent License 1.0 was not distributed with this source code in the
+ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
+ */
+
+#include "hash.h"
+
+static void crc_calculator_process_data(CRC_CALCULATOR *p_crc_calculator,
+                                        uint8_t *pData, uint32_t dataLength) {
+  for (uint32_t i = 0; i < dataLength; i++) {
+    const uint8_t index =
+        (p_crc_calculator->remainder >> (p_crc_calculator->bits - 8)) ^
+        pData[i];
+    p_crc_calculator->remainder <<= 8;
+    p_crc_calculator->remainder ^= p_crc_calculator->table[index];
+  }
+}
+
+static void crc_calculator_reset(CRC_CALCULATOR *p_crc_calculator) {
+  p_crc_calculator->remainder = 0;
+}
+
+static uint32_t crc_calculator_get_crc(CRC_CALCULATOR *p_crc_calculator) {
+  return p_crc_calculator->remainder & p_crc_calculator->final_result_mask;
+}
+
+static void crc_calculator_init_table(CRC_CALCULATOR *p_crc_calculator) {
+  const uint32_t high_bit = 1 << (p_crc_calculator->bits - 1);
+  const uint32_t byte_high_bit = 1 << (8 - 1);
+
+  for (uint32_t value = 0; value < 256; value++) {
+    uint32_t remainder = 0;
+    for (uint8_t mask = byte_high_bit; mask != 0; mask >>= 1) {
+      if (value & mask) {
+        remainder ^= high_bit;
+      }
+
+      if (remainder & high_bit) {
+        remainder <<= 1;
+        remainder ^= p_crc_calculator->trunc_poly;
+      } else {
+        remainder <<= 1;
+      }
+    }
+    p_crc_calculator->table[value] = remainder;
+  }
+}
+
+void av1_crc_calculator_init(CRC_CALCULATOR *p_crc_calculator, uint32_t bits,
+                             uint32_t truncPoly) {
+  p_crc_calculator->remainder = 0;
+  p_crc_calculator->bits = bits;
+  p_crc_calculator->trunc_poly = truncPoly;
+  p_crc_calculator->final_result_mask = (1 << bits) - 1;
+  crc_calculator_init_table(p_crc_calculator);
+}
+
+uint32_t av1_get_crc_value(void *crc_calculator, uint8_t *p, int length) {
+  CRC_CALCULATOR *p_crc_calculator = (CRC_CALCULATOR *)crc_calculator;
+  crc_calculator_reset(p_crc_calculator);
+  crc_calculator_process_data(p_crc_calculator, p, length);
+  return crc_calculator_get_crc(p_crc_calculator);
+}
+
+/* CRC-32C (iSCSI) polynomial in reversed bit order. */
+#define POLY 0x82f63b78
+
+/* Construct table for software CRC-32C calculation. */
+void av1_crc32c_calculator_init(CRC32C *p_crc32c) {
+  uint32_t crc;
+
+  for (int n = 0; n < 256; n++) {
+    crc = n;
+    crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
+    crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
+    crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
+    crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
+    crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
+    crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
+    crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
+    crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
+    p_crc32c->table[0][n] = crc;
+  }
+  for (int n = 0; n < 256; n++) {
+    crc = p_crc32c->table[0][n];
+    for (int k = 1; k < 8; k++) {
+      crc = p_crc32c->table[0][crc & 0xff] ^ (crc >> 8);
+      p_crc32c->table[k][n] = crc;
+    }
+  }
+}
+
+/* Table-driven software version as a fall-back.  This is about 15 times slower
+ than using the hardware instructions.  This assumes little-endian integers,
+ as is the case on Intel processors that the assembler code here is for. */
+uint32_t av1_get_crc32c_value_c(CRC32C *p, uint8_t *buf, size_t len) {
+  const uint8_t *next = (const uint8_t *)(buf);
+  uint64_t crc;
+
+  crc = 0 ^ 0xffffffff;
+  while (len && ((uintptr_t)next & 7) != 0) {
+    crc = p->table[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);
+    len--;
+  }
+  while (len >= 8) {
+    crc ^= *(uint64_t *)next;
+    crc = p->table[7][crc & 0xff] ^ p->table[6][(crc >> 8) & 0xff] ^
+          p->table[5][(crc >> 16) & 0xff] ^ p->table[4][(crc >> 24) & 0xff] ^
+          p->table[3][(crc >> 32) & 0xff] ^ p->table[2][(crc >> 40) & 0xff] ^
+          p->table[1][(crc >> 48) & 0xff] ^ p->table[0][crc >> 56];
+    next += 8;
+    len -= 8;
+  }
+  while (len) {
+    crc = p->table[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);
+    len--;
+  }
+  return (uint32_t)crc ^ 0xffffffff;
+}
diff --git a/Source/Lib/Codec/hash.h b/Source/Lib/Codec/hash.h
new file mode 100644
index 0000000..1f2aef6
--- /dev/null
+++ b/Source/Lib/Codec/hash.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2016, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 2 Clause License and
+ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
+ * was not distributed with this source code in the LICENSE file, you can
+ * obtain it at www.aomedia.org/license/software. If the Alliance for Open
+ * Media Patent License 1.0 was not distributed with this source code in the
+ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
+ */
+
+#ifndef AOM_AV1_ENCODER_HASH_H_
+#define AOM_AV1_ENCODER_HASH_H_
+
+//#include "config/aom_config.h"
+
+//#include "aom/aom_integer.h"
+#include "EbDefinitions.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct _crc_calculator {
+  uint32_t remainder;
+  uint32_t trunc_poly;
+  uint32_t bits;
+  uint32_t table[256];
+  uint32_t final_result_mask;
+} CRC_CALCULATOR;
+
+// Initialize the crc calculator. It must be executed at least once before
+// calling av1_get_crc_value().
+void av1_crc_calculator_init(CRC_CALCULATOR *p_crc_calculator, uint32_t bits,
+                             uint32_t truncPoly);
+uint32_t av1_get_crc_value(void *crc_calculator, uint8_t *p, int length);
+
+// CRC32C: POLY = 0x82f63b78;
+typedef struct _CRC32C {
+  /* Table for a quadword-at-a-time software crc. */
+  uint32_t table[8][256];
+} CRC32C;
+
+// init table for software version crc32c
+void av1_crc32c_calculator_init(CRC32C *p_crc32c);
+
+#define AOM_BUFFER_SIZE_FOR_BLOCK_HASH (4096)
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif  // AOM_AV1_ENCODER_HASH_H_
diff --git a/Source/Lib/Codec/hash_motion.c b/Source/Lib/Codec/hash_motion.c
new file mode 100644
index 0000000..b488ca9
--- /dev/null
+++ b/Source/Lib/Codec/hash_motion.c
@@ -0,0 +1,491 @@
+/*
+ * Copyright (c) 2018, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 2 Clause License and
+ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
+ * was not distributed with this source code in the LICENSE file, you can
+ * obtain it at www.aomedia.org/license/software. If the Alliance for Open
+ * Media Patent License 1.0 was not distributed with this source code in the
+ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
+ */
+
+#include <assert.h>
+#include "EbCodingUnit.h"
+#if ICOPY
+
+#include "hash.h"
+#include "hash_motion.h"
+#include "EbPictureControlSet.h"
+
+
+void aom_free(void *memblk);
+static const int crc_bits = 16;
+static const int block_size_bits = 3;
+
+static void hash_table_clear_all(hash_table *p_hash_table) {
+  if (p_hash_table->p_lookup_table == NULL) {
+    return;
+  }
+  int max_addr = 1 << (crc_bits + block_size_bits);
+  for (int i = 0; i < max_addr; i++) {
+    if (p_hash_table->p_lookup_table[i] != NULL) {
+      aom_vector_destroy(p_hash_table->p_lookup_table[i]);
+      aom_free(p_hash_table->p_lookup_table[i]);
+      p_hash_table->p_lookup_table[i] = NULL;
+    }
+  }
+}
+
+// TODO(youzhou@microsoft.com): is higher than 8 bits screen content supported?
+// If yes, fix this function
+static void get_pixels_in_1D_char_array_by_block_2x2(uint8_t *y_src, int stride,
+                                                     uint8_t *p_pixels_in1D) {
+  uint8_t *p_pel = y_src;
+  int index = 0;
+  for (int i = 0; i < 2; i++) {
+    for (int j = 0; j < 2; j++) {
+      p_pixels_in1D[index++] = p_pel[j];
+    }
+    p_pel += stride;
+  }
+}
+
+static void get_pixels_in_1D_short_array_by_block_2x2(uint16_t *y_src,
+                                                      int stride,
+                                                      uint16_t *p_pixels_in1D) {
+  uint16_t *p_pel = y_src;
+  int index = 0;
+  for (int i = 0; i < 2; i++) {
+    for (int j = 0; j < 2; j++) {
+      p_pixels_in1D[index++] = p_pel[j];
+    }
+    p_pel += stride;
+  }
+}
+
+static int is_block_2x2_row_same_value(uint8_t *p) {
+  if (p[0] != p[1] || p[2] != p[3]) {
+    return 0;
+  }
+  return 1;
+}
+
+static int is_block16_2x2_row_same_value(uint16_t *p) {
+  if (p[0] != p[1] || p[2] != p[3]) {
+    return 0;
+  }
+  return 1;
+}
+
+static int is_block_2x2_col_same_value(uint8_t *p) {
+  if ((p[0] != p[2]) || (p[1] != p[3])) {
+    return 0;
+  }
+  return 1;
+}
+
+static int is_block16_2x2_col_same_value(uint16_t *p) {
+  if ((p[0] != p[2]) || (p[1] != p[3])) {
+    return 0;
+  }
+  return 1;
+}
+
+// the hash value (hash_value1 consists two parts, the first 3 bits relate to
+// the block size and the remaining 16 bits are the crc values. This fuction
+// is used to get the first 3 bits.
+static int hash_block_size_to_index(int block_size) {
+  switch (block_size) {
+    case 4: return 0;
+    case 8: return 1;
+    case 16: return 2;
+    case 32: return 3;
+    case 64: return 4;
+    case 128: return 5;
+    default: return -1;
+  }
+}
+
+//void av1_hash_table_init(hash_table *p_hash_table, MACROBLOCK *x) {
+//  if (x->g_crc_initialized == 0) {
+//    av1_crc_calculator_init(&x->crc_calculator1, 24, 0x5D6DCB);
+//    av1_crc_calculator_init(&x->crc_calculator2, 24, 0x864CFB);
+//    x->g_crc_initialized = 1;
+//  }
+//  p_hash_table->p_lookup_table = NULL;
+//}
+
+void av1_hash_table_destroy(hash_table *p_hash_table) {
+  hash_table_clear_all(p_hash_table);
+  aom_free(p_hash_table->p_lookup_table);
+  p_hash_table->p_lookup_table = NULL;
+}
+
+EbErrorType  av1_hash_table_create(hash_table *p_hash_table) {
+
+    EbErrorType err_code = EB_ErrorNone;;
+
+  if (p_hash_table->p_lookup_table != NULL) {
+    hash_table_clear_all(p_hash_table);
+    return err_code;
+  }
+  const int max_addr = 1 << (crc_bits + block_size_bits);
+  //p_hash_table->p_lookup_table = (Vector **)malloc(sizeof(p_hash_table->p_lookup_table[0]) * max_addr);
+     EB_MALLOC(Vector **, p_hash_table->p_lookup_table,sizeof(p_hash_table->p_lookup_table[0]) * max_addr, EB_N_PTR);
+  memset(p_hash_table->p_lookup_table, 0,
+         sizeof(p_hash_table->p_lookup_table[0]) * max_addr);
+
+  return err_code;
+}
+
+static void hash_table_add_to_table(hash_table *p_hash_table,
+                                    uint32_t hash_value,
+                                    block_hash *curr_block_hash) {
+  if (p_hash_table->p_lookup_table[hash_value] == NULL) {
+    p_hash_table->p_lookup_table[hash_value] =
+        malloc(sizeof(p_hash_table->p_lookup_table[0][0]));
+    aom_vector_setup(p_hash_table->p_lookup_table[hash_value], 10,
+                     sizeof(curr_block_hash[0]));
+    aom_vector_push_back(p_hash_table->p_lookup_table[hash_value],
+                         curr_block_hash);
+  } else {
+    aom_vector_push_back(p_hash_table->p_lookup_table[hash_value],
+                         curr_block_hash);
+  }
+}
+
+int32_t av1_hash_table_count(const hash_table *p_hash_table,
+                             uint32_t hash_value) {
+  if (p_hash_table->p_lookup_table[hash_value] == NULL) {
+    return 0;
+  } else {
+    return (int32_t)(p_hash_table->p_lookup_table[hash_value]->size);
+  }
+}
+
+Iterator av1_hash_get_first_iterator(hash_table *p_hash_table,
+                                     uint32_t hash_value) {
+  assert(av1_hash_table_count(p_hash_table, hash_value) > 0);
+  return aom_vector_begin(p_hash_table->p_lookup_table[hash_value]);
+}
+
+int32_t av1_has_exact_match(hash_table *p_hash_table, uint32_t hash_value1,
+                            uint32_t hash_value2) {
+  if (p_hash_table->p_lookup_table[hash_value1] == NULL) {
+    return 0;
+  }
+  Iterator iterator =
+      aom_vector_begin(p_hash_table->p_lookup_table[hash_value1]);
+  Iterator last = aom_vector_end(p_hash_table->p_lookup_table[hash_value1]);
+  for (; !iterator_equals(&iterator, &last); iterator_increment(&iterator)) {
+    if ((*(block_hash *)iterator_get(&iterator)).hash_value2 == hash_value2) {
+      return 1;
+    }
+  }
+  return 0;
+}
+
+void av1_generate_block_2x2_hash_value(const Yv12BufferConfig *picture,
+                                       uint32_t *pic_block_hash[2],
+                                       int8_t *pic_block_same_info[3],
+                                       PictureControlSet_t * pcs) {
+  const int width = 2;
+  const int height = 2;
+  const int x_end = picture->y_crop_width - width + 1;
+  const int y_end = picture->y_crop_height - height + 1;
+
+  const int length = width * 2;
+  if (picture->flags & YV12_FLAG_HIGHBITDEPTH) {
+    uint16_t p[4];
+    int pos = 0;
+    for (int y_pos = 0; y_pos < y_end; y_pos++) {
+      for (int x_pos = 0; x_pos < x_end; x_pos++) {
+        get_pixels_in_1D_short_array_by_block_2x2(
+            CONVERT_TO_SHORTPTR(picture->y_buffer) + y_pos * picture->y_stride +
+                x_pos,
+            picture->y_stride, p);
+        pic_block_same_info[0][pos] = is_block16_2x2_row_same_value(p);
+        pic_block_same_info[1][pos] = is_block16_2x2_col_same_value(p);
+
+        pic_block_hash[0][pos] = av1_get_crc_value(
+            &pcs->crc_calculator1, (uint8_t *)p, length * sizeof(p[0]));
+        pic_block_hash[1][pos] = av1_get_crc_value(
+            &pcs->crc_calculator2, (uint8_t *)p, length * sizeof(p[0]));
+        pos++;
+      }
+      pos += width - 1;
+    }
+  } else {
+    uint8_t p[4];
+    int pos = 0;
+    for (int y_pos = 0; y_pos < y_end; y_pos++) {
+      for (int x_pos = 0; x_pos < x_end; x_pos++) {
+        get_pixels_in_1D_char_array_by_block_2x2(
+            picture->y_buffer + y_pos * picture->y_stride + x_pos,
+            picture->y_stride, p);
+        pic_block_same_info[0][pos] = is_block_2x2_row_same_value(p);
+        pic_block_same_info[1][pos] = is_block_2x2_col_same_value(p);
+
+        pic_block_hash[0][pos] =
+            av1_get_crc_value(&pcs->crc_calculator1, p, length * sizeof(p[0]));
+        pic_block_hash[1][pos] =
+            av1_get_crc_value(&pcs->crc_calculator2, p, length * sizeof(p[0]));
+        pos++;
+      }
+      pos += width - 1;
+    }
+  }
+}
+
+void av1_generate_block_hash_value(const Yv12BufferConfig *picture,
+                                   int block_size,
+                                   uint32_t *src_pic_block_hash[2],
+                                   uint32_t *dst_pic_block_hash[2],
+                                   int8_t *src_pic_block_same_info[3],
+                                   int8_t *dst_pic_block_same_info[3],
+                                   PictureControlSet_t * pcs  ) {
+  const int pic_width = picture->y_crop_width;
+  const int x_end = picture->y_crop_width - block_size + 1;
+  const int y_end = picture->y_crop_height - block_size + 1;
+
+  const int src_size = block_size >> 1;
+  const int quad_size = block_size >> 2;
+
+  uint32_t p[4];
+  const int length = sizeof(p);
+
+  int pos = 0;
+  for (int y_pos = 0; y_pos < y_end; y_pos++) {
+    for (int x_pos = 0; x_pos < x_end; x_pos++) {
+      p[0] = src_pic_block_hash[0][pos];
+      p[1] = src_pic_block_hash[0][pos + src_size];
+      p[2] = src_pic_block_hash[0][pos + src_size * pic_width];
+      p[3] = src_pic_block_hash[0][pos + src_size * pic_width + src_size];
+      dst_pic_block_hash[0][pos] =
+          av1_get_crc_value(&pcs->crc_calculator1, (uint8_t *)p, length);
+
+      p[0] = src_pic_block_hash[1][pos];
+      p[1] = src_pic_block_hash[1][pos + src_size];
+      p[2] = src_pic_block_hash[1][pos + src_size * pic_width];
+      p[3] = src_pic_block_hash[1][pos + src_size * pic_width + src_size];
+      dst_pic_block_hash[1][pos] =
+          av1_get_crc_value(&pcs->crc_calculator2, (uint8_t *)p, length);
+
+      dst_pic_block_same_info[0][pos] =
+          src_pic_block_same_info[0][pos] &&
+          src_pic_block_same_info[0][pos + quad_size] &&
+          src_pic_block_same_info[0][pos + src_size] &&
+          src_pic_block_same_info[0][pos + src_size * pic_width] &&
+          src_pic_block_same_info[0][pos + src_size * pic_width + quad_size] &&
+          src_pic_block_same_info[0][pos + src_size * pic_width + src_size];
+
+      dst_pic_block_same_info[1][pos] =
+          src_pic_block_same_info[1][pos] &&
+          src_pic_block_same_info[1][pos + src_size] &&
+          src_pic_block_same_info[1][pos + quad_size * pic_width] &&
+          src_pic_block_same_info[1][pos + quad_size * pic_width + src_size] &&
+          src_pic_block_same_info[1][pos + src_size * pic_width] &&
+          src_pic_block_same_info[1][pos + src_size * pic_width + src_size];
+      pos++;
+    }
+    pos += block_size - 1;
+  }
+
+  if (block_size >= 4) {
+    const int size_minus_1 = block_size - 1;
+    pos = 0;
+    for (int y_pos = 0; y_pos < y_end; y_pos++) {
+      for (int x_pos = 0; x_pos < x_end; x_pos++) {
+        dst_pic_block_same_info[2][pos] =
+            (!dst_pic_block_same_info[0][pos] &&
+             !dst_pic_block_same_info[1][pos]) ||
+            (((x_pos & size_minus_1) == 0) && ((y_pos & size_minus_1) == 0));
+        pos++;
+      }
+      pos += block_size - 1;
+    }
+  }
+}
+
+void av1_add_to_hash_map_by_row_with_precal_data(hash_table *p_hash_table,
+                                                 uint32_t *pic_hash[2],
+                                                 int8_t *pic_is_same,
+                                                 int pic_width, int pic_height,
+                                                 int block_size) {
+  const int x_end = pic_width - block_size + 1;
+  const int y_end = pic_height - block_size + 1;
+
+  const int8_t *src_is_added = pic_is_same;
+  const uint32_t *src_hash[2] = { pic_hash[0], pic_hash[1] };
+
+  int add_value = hash_block_size_to_index(block_size);
+  assert(add_value >= 0);
+  add_value <<= crc_bits;
+  const int crc_mask = (1 << crc_bits) - 1;
+
+  for (int x_pos = 0; x_pos < x_end; x_pos++) {
+    for (int y_pos = 0; y_pos < y_end; y_pos++) {
+      const int pos = y_pos * pic_width + x_pos;
+      // valid data
+      if (src_is_added[pos]) {
+        block_hash curr_block_hash;
+        curr_block_hash.x = x_pos;
+        curr_block_hash.y = y_pos;
+
+        const uint32_t hash_value1 = (src_hash[0][pos] & crc_mask) + add_value;
+        curr_block_hash.hash_value2 = src_hash[1][pos];
+
+        hash_table_add_to_table(p_hash_table, hash_value1, &curr_block_hash);
+      }
+    }
+  }
+}
+
+int av1_hash_is_horizontal_perfect(const Yv12BufferConfig *picture,
+                                   int block_size, int x_start, int y_start) {
+  const int stride = picture->y_stride;
+  const uint8_t *p = picture->y_buffer + y_start * stride + x_start;
+
+  if (picture->flags & YV12_FLAG_HIGHBITDEPTH) {
+    const uint16_t *p16 = CONVERT_TO_SHORTPTR(p);
+    for (int i = 0; i < block_size; i++) {
+      for (int j = 1; j < block_size; j++) {
+        if (p16[j] != p16[0]) {
+          return 0;
+        }
+      }
+      p16 += stride;
+    }
+  } else {
+    for (int i = 0; i < block_size; i++) {
+      for (int j = 1; j < block_size; j++) {
+        if (p[j] != p[0]) {
+          return 0;
+        }
+      }
+      p += stride;
+    }
+  }
+
+  return 1;
+}
+
+int av1_hash_is_vertical_perfect(const Yv12BufferConfig *picture,
+                                 int block_size, int x_start, int y_start) {
+  const int stride = picture->y_stride;
+  const uint8_t *p = picture->y_buffer + y_start * stride + x_start;
+
+  if (picture->flags & YV12_FLAG_HIGHBITDEPTH) {
+    const uint16_t *p16 = CONVERT_TO_SHORTPTR(p);
+    for (int i = 0; i < block_size; i++) {
+      for (int j = 1; j < block_size; j++) {
+        if (p16[j * stride + i] != p16[i]) {
+          return 0;
+        }
+      }
+    }
+  } else {
+    for (int i = 0; i < block_size; i++) {
+      for (int j = 1; j < block_size; j++) {
+        if (p[j * stride + i] != p[i]) {
+          return 0;
+        }
+      }
+    }
+  }
+  return 1;
+}
+
+void av1_get_block_hash_value(uint8_t *y_src, int stride, int block_size,
+                              uint32_t *hash_value1, uint32_t *hash_value2,
+                              int use_highbitdepth, struct PictureControlSet_s * pcs, IntraBcContext  *x) {
+  uint32_t to_hash[4];
+  const int add_value = hash_block_size_to_index(block_size) << crc_bits;
+  assert(add_value >= 0);
+  const int crc_mask = (1 << crc_bits) - 1;
+
+  // 2x2 subblock hash values in current CU
+  int sub_block_in_width = (block_size >> 1);
+  if (use_highbitdepth) {
+    uint16_t pixel_to_hash[4];
+    uint16_t *y16_src = CONVERT_TO_SHORTPTR(y_src);
+    for (int y_pos = 0; y_pos < block_size; y_pos += 2) {
+      for (int x_pos = 0; x_pos < block_size; x_pos += 2) {
+        int pos = (y_pos >> 1) * sub_block_in_width + (x_pos >> 1);
+        get_pixels_in_1D_short_array_by_block_2x2(
+            y16_src + y_pos * stride + x_pos, stride, pixel_to_hash);
+        assert(pos < AOM_BUFFER_SIZE_FOR_BLOCK_HASH);
+        x->hash_value_buffer[0][0][pos] =
+            av1_get_crc_value(&pcs->crc_calculator1, (uint8_t *)pixel_to_hash,
+                              sizeof(pixel_to_hash));
+        x->hash_value_buffer[1][0][pos] =
+            av1_get_crc_value(&pcs->crc_calculator2, (uint8_t *)pixel_to_hash,
+                              sizeof(pixel_to_hash));
+      }
+    }
+  } else {
+    uint8_t pixel_to_hash[4];
+    for (int y_pos = 0; y_pos < block_size; y_pos += 2) {
+      for (int x_pos = 0; x_pos < block_size; x_pos += 2) {
+        int pos = (y_pos >> 1) * sub_block_in_width + (x_pos >> 1);
+        get_pixels_in_1D_char_array_by_block_2x2(y_src + y_pos * stride + x_pos,
+                                                 stride, pixel_to_hash);
+        assert(pos < AOM_BUFFER_SIZE_FOR_BLOCK_HASH);
+        x->hash_value_buffer[0][0][pos] = av1_get_crc_value(
+            &pcs->crc_calculator1, pixel_to_hash, sizeof(pixel_to_hash));
+        x->hash_value_buffer[1][0][pos] = av1_get_crc_value(
+            &pcs->crc_calculator2, pixel_to_hash, sizeof(pixel_to_hash));
+      }
+    }
+  }
+
+  int src_sub_block_in_width = sub_block_in_width;
+  sub_block_in_width >>= 1;
+
+  int src_idx = 1;
+  int dst_idx = 0;
+
+  // 4x4 subblock hash values to current block hash values
+  for (int sub_width = 4; sub_width <= block_size; sub_width *= 2) {
+    src_idx = 1 - src_idx;
+    dst_idx = 1 - dst_idx;
+
+    int dst_pos = 0;
+    for (int y_pos = 0; y_pos < sub_block_in_width; y_pos++) {
+      for (int x_pos = 0; x_pos < sub_block_in_width; x_pos++) {
+        int srcPos = (y_pos << 1) * src_sub_block_in_width + (x_pos << 1);
+
+        assert(srcPos + 1 < AOM_BUFFER_SIZE_FOR_BLOCK_HASH);
+        assert(srcPos + src_sub_block_in_width + 1 <
+               AOM_BUFFER_SIZE_FOR_BLOCK_HASH);
+        assert(dst_pos < AOM_BUFFER_SIZE_FOR_BLOCK_HASH);
+        to_hash[0] = x->hash_value_buffer[0][src_idx][srcPos];
+        to_hash[1] = x->hash_value_buffer[0][src_idx][srcPos + 1];
+        to_hash[2] =
+            x->hash_value_buffer[0][src_idx][srcPos + src_sub_block_in_width];
+        to_hash[3] = x->hash_value_buffer[0][src_idx]
+                                         [srcPos + src_sub_block_in_width + 1];
+
+        x->hash_value_buffer[0][dst_idx][dst_pos] = av1_get_crc_value(
+            &pcs->crc_calculator1, (uint8_t *)to_hash, sizeof(to_hash));
+
+        to_hash[0] = x->hash_value_buffer[1][src_idx][srcPos];
+        to_hash[1] = x->hash_value_buffer[1][src_idx][srcPos + 1];
+        to_hash[2] =
+            x->hash_value_buffer[1][src_idx][srcPos + src_sub_block_in_width];
+        to_hash[3] = x->hash_value_buffer[1][src_idx]
+                                         [srcPos + src_sub_block_in_width + 1];
+        x->hash_value_buffer[1][dst_idx][dst_pos] = av1_get_crc_value(
+            &pcs->crc_calculator2, (uint8_t *)to_hash, sizeof(to_hash));
+        dst_pos++;
+      }
+    }
+
+    src_sub_block_in_width = sub_block_in_width;
+    sub_block_in_width >>= 1;
+  }
+
+  *hash_value1 = (x->hash_value_buffer[0][dst_idx][0] & crc_mask) + add_value;
+  *hash_value2 = x->hash_value_buffer[1][dst_idx][0];
+}
+#endif
\ No newline at end of file
diff --git a/Source/Lib/Codec/hash_motion.h b/Source/Lib/Codec/hash_motion.h
new file mode 100644
index 0000000..b8d5dee
--- /dev/null
+++ b/Source/Lib/Codec/hash_motion.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2016, Alliance for Open Media. All rights reserved
+ *
+ * This source code is subject to the terms of the BSD 2 Clause License and
+ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
+ * was not distributed with this source code in the LICENSE file, you can
+ * obtain it at www.aomedia.org/license/software. If the Alliance for Open
+ * Media Patent License 1.0 was not distributed with this source code in the
+ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
+ */
+
+#ifndef AOM_AV1_ENCODER_HASH_MOTION_H_
+#define AOM_AV1_ENCODER_HASH_MOTION_H_
+
+//#include "config/aom_config.h"
+
+//#include "aom/aom_integer.h"
+//#include "aom_scale/yv12config.h"
+#include "EbDefinitions.h"
+#include "EbCodingUnit.h"
+#include "vector.h"
+#include "EbPictureBufferDesc.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// store a block's hash info.
+// x and y are the position from the top left of the picture
+// hash_value2 is used to store the second hash value
+typedef struct _block_hash {
+  int16_t x;
+  int16_t y;
+  uint32_t hash_value2;
+} block_hash;
+
+typedef struct _hash_table {
+  Vector **p_lookup_table;
+} hash_table;
+
+void av1_hash_table_init(hash_table *p_hash_table, struct Macroblock *x);
+void av1_hash_table_destroy(hash_table *p_hash_table);
+EbErrorType  av1_hash_table_create(hash_table *p_hash_table);
+int32_t av1_hash_table_count(const hash_table *p_hash_table,
+                             uint32_t hash_value);
+Iterator av1_hash_get_first_iterator(hash_table *p_hash_table,
+                                     uint32_t hash_value);
+int32_t av1_has_exact_match(hash_table *p_hash_table, uint32_t hash_value1,
+                            uint32_t hash_value2);
+void av1_generate_block_2x2_hash_value(const Yv12BufferConfig *picture,
+                                       uint32_t *pic_block_hash[2],
+                                       int8_t *pic_block_same_info[3],
+                                      struct PictureControlSet_s * pcs);
+void av1_generate_block_hash_value(const Yv12BufferConfig *picture,
+                                   int block_size,
+                                   uint32_t *src_pic_block_hash[2],
+                                   uint32_t *dst_pic_block_hash[2],
+                                   int8_t *src_pic_block_same_info[3],
+                                   int8_t *dst_pic_block_same_info[3],
+                                   struct PictureControlSet_s * pcs);
+void av1_add_to_hash_map_by_row_with_precal_data(hash_table *p_hash_table,
+                                                 uint32_t *pic_hash[2],
+                                                 int8_t *pic_is_same,
+                                                 int pic_width, int pic_height,
+                                                 int block_size);
+
+// check whether the block starts from (x_start, y_start) with the size of
+// block_size x block_size has the same color in all rows
+int av1_hash_is_horizontal_perfect(const Yv12BufferConfig *picture,
+                                   int block_size, int x_start, int y_start);
+// check whether the block starts from (x_start, y_start) with the size of
+// block_size x block_size has the same color in all columns
+int av1_hash_is_vertical_perfect(const Yv12BufferConfig *picture,
+                                 int block_size, int x_start, int y_start);
+void av1_get_block_hash_value(uint8_t *y_src, int stride, int block_size,
+                              uint32_t *hash_value1, uint32_t *hash_value2,
+                              int use_highbitdepth, struct PictureControlSet_s * pcs, struct IntraBcContext /*MACROBLOCK*/ *x);
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif  // AOM_AV1_ENCODER_HASH_MOTION_H_
diff --git a/Source/Lib/Codec/vector.c b/Source/Lib/Codec/vector.c
new file mode 100644
index 0000000..7ecfab0
--- /dev/null
+++ b/Source/Lib/Codec/vector.c
@@ -0,0 +1,543 @@
+/*
+The MIT License(MIT)
+Copyright(c) 2016 Peter Goldsborough
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files(the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software is furnished to do so,
+subject to the following conditions :
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/
+
+#define __STDC_WANT_LIB_EXT1__ 1
+
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "vector.h"
+#define MAX(a, b) ((a) > (b) ? (a) : (b))
+int aom_vector_setup(Vector *vector, size_t capacity, size_t element_size) {
+  assert(vector != NULL);
+
+  if (vector == NULL) return VECTOR_ERROR;
+
+  vector->size = 0;
+  vector->capacity = MAX(VECTOR_MINIMUM_CAPACITY, capacity);
+  vector->element_size = element_size;
+  vector->data = malloc(vector->capacity * element_size);
+
+  return vector->data == NULL ? VECTOR_ERROR : VECTOR_SUCCESS;
+}
+
+int aom_vector_copy(Vector *destination, Vector *source) {
+  assert(destination != NULL);
+  assert(source != NULL);
+  assert(aom_vector_is_initialized(source));
+  assert(!aom_vector_is_initialized(destination));
+
+  if (destination == NULL) return VECTOR_ERROR;
+  if (source == NULL) return VECTOR_ERROR;
+  if (aom_vector_is_initialized(destination)) return VECTOR_ERROR;
+  if (!aom_vector_is_initialized(source)) return VECTOR_ERROR;
+
+  /* Copy ALL the data */
+  destination->size = source->size;
+  destination->capacity = source->size * 2;
+  destination->element_size = source->element_size;
+
+  /* Note that we are not necessarily allocating the same capacity */
+  destination->data = malloc(destination->capacity * source->element_size);
+  if (destination->data == NULL) return VECTOR_ERROR;
+
+  memcpy(destination->data, source->data, aom_vector_byte_size(source));
+
+  return VECTOR_SUCCESS;
+}
+
+int aom_vector_copy_assign(Vector *destination, Vector *source) {
+  assert(destination != NULL);
+  assert(source != NULL);
+  assert(aom_vector_is_initialized(source));
+  assert(aom_vector_is_initialized(destination));
+
+  if (destination == NULL) return VECTOR_ERROR;
+  if (source == NULL) return VECTOR_ERROR;
+  if (!aom_vector_is_initialized(destination)) return VECTOR_ERROR;
+  if (!aom_vector_is_initialized(source)) return VECTOR_ERROR;
+
+  aom_vector_destroy(destination);
+
+  return aom_vector_copy(destination, source);
+}
+
+int aom_vector_move(Vector *destination, Vector *source) {
+  assert(destination != NULL);
+  assert(source != NULL);
+
+  if (destination == NULL) return VECTOR_ERROR;
+  if (source == NULL) return VECTOR_ERROR;
+
+  *destination = *source;
+  source->data = NULL;
+
+  return VECTOR_SUCCESS;
+}
+
+int aom_vector_move_assign(Vector *destination, Vector *source) {
+  aom_vector_swap(destination, source);
+  return aom_vector_destroy(source);
+}
+
+int aom_vector_swap(Vector *destination, Vector *source) {
+  void *temp;
+
+  assert(destination != NULL);
+  assert(source != NULL);
+  assert(aom_vector_is_initialized(source));
+  assert(aom_vector_is_initialized(destination));
+
+  if (destination == NULL) return VECTOR_ERROR;
+  if (source == NULL) return VECTOR_ERROR;
+  if (!aom_vector_is_initialized(destination)) return VECTOR_ERROR;
+  if (!aom_vector_is_initialized(source)) return VECTOR_ERROR;
+
+  _vector_swap(&destination->size, &source->size);
+  _vector_swap(&destination->capacity, &source->capacity);
+  _vector_swap(&destination->element_size, &source->element_size);
+
+  temp = destination->data;
+  destination->data = source->data;
+  source->data = temp;
+
+  return VECTOR_SUCCESS;
+}
+
+int aom_vector_destroy(Vector *vector) {
+  assert(vector != NULL);
+
+  if (vector == NULL) return VECTOR_ERROR;
+
+  free(vector->data);
+  vector->data = NULL;
+
+  return VECTOR_SUCCESS;
+}
+
+/* Insertion */
+int aom_vector_push_back(Vector *vector, void *element) {
+  assert(vector != NULL);
+  assert(element != NULL);
+
+  if (_vector_should_grow(vector)) {
+    if (_vector_adjust_capacity(vector) == VECTOR_ERROR) {
+      return VECTOR_ERROR;
+    }
+  }
+
+  _vector_assign(vector, vector->size, element);
+
+  ++vector->size;
+
+  return VECTOR_SUCCESS;
+}
+
+int aom_vector_push_front(Vector *vector, void *element) {
+  return aom_vector_insert(vector, 0, element);
+}
+
+int aom_vector_insert(Vector *vector, size_t index, void *element) {
+  void *offset;
+
+  assert(vector != NULL);
+  assert(element != NULL);
+  assert(index <= vector->size);
+
+  if (vector == NULL) return VECTOR_ERROR;
+  if (element == NULL) return VECTOR_ERROR;
+  if (vector->element_size == 0) return VECTOR_ERROR;
+  if (index > vector->size) return VECTOR_ERROR;
+
+  if (_vector_should_grow(vector)) {
+    if (_vector_adjust_capacity(vector) == VECTOR_ERROR) {
+      return VECTOR_ERROR;
+    }
+  }
+
+  /* Move other elements to the right */
+  if (_vector_move_right(vector, index) == VECTOR_ERROR) {
+    return VECTOR_ERROR;
+  }
+
+  /* Insert the element */
+  offset = _vector_offset(vector, index);
+  memcpy(offset, element, vector->element_size);
+  ++vector->size;
+
+  return VECTOR_SUCCESS;
+}
+
+int aom_vector_assign(Vector *vector, size_t index, void *element) {
+  assert(vector != NULL);
+  assert(element != NULL);
+  assert(index < vector->size);
+
+  if (vector == NULL) return VECTOR_ERROR;
+  if (element == NULL) return VECTOR_ERROR;
+  if (vector->element_size == 0) return VECTOR_ERROR;
+  if (index >= vector->size) return VECTOR_ERROR;
+
+  _vector_assign(vector, index, element);
+
+  return VECTOR_SUCCESS;
+}
+
+/* Deletion */
+int aom_vector_pop_back(Vector *vector) {
+  assert(vector != NULL);
+  assert(vector->size > 0);
+
+  if (vector == NULL) return VECTOR_ERROR;
+  if (vector->element_size == 0) return VECTOR_ERROR;
+
+  --vector->size;
+
+#ifndef VECTOR_NO_SHRINK
+  if (_vector_should_shrink(vector)) {
+    _vector_adjust_capacity(vector);
+  }
+#endif
+
+  return VECTOR_SUCCESS;
+}
+
+int aom_vector_pop_front(Vector *vector) { return aom_vector_erase(vector, 0); }
+
+int aom_vector_erase(Vector *vector, size_t index) {
+  assert(vector != NULL);
+  assert(index < vector->size);
+
+  if (vector == NULL) return VECTOR_ERROR;
+  if (vector->element_size == 0) return VECTOR_ERROR;
+  if (index >= vector->size) return VECTOR_ERROR;
+
+  /* Just overwrite */
+  _vector_move_left(vector, index);
+
+#ifndef VECTOR_NO_SHRINK
+  if (--vector->size == vector->capacity / 4) {
+    _vector_adjust_capacity(vector);
+  }
+#endif
+
+  return VECTOR_SUCCESS;
+}
+
+int aom_vector_clear(Vector *vector) { return aom_vector_resize(vector, 0); }
+
+/* Lookup */
+void *aom_vector_get(Vector *vector, size_t index) {
+  assert(vector != NULL);
+  assert(index < vector->size);
+
+  if (vector == NULL) return NULL;
+  if (vector->element_size == 0) return NULL;
+  if (index >= vector->size) return NULL;
+
+  return _vector_offset(vector, index);
+}
+
+const void *aom_vector_const_get(const Vector *vector, size_t index) {
+  assert(vector != NULL);
+  assert(index < vector->size);
+
+  if (vector == NULL) return NULL;
+  if (vector->element_size == 0) return NULL;
+  if (index >= vector->size) return NULL;
+
+  return _vector_const_offset(vector, index);
+}
+
+void *aom_vector_front(Vector *vector) { return aom_vector_get(vector, 0); }
+
+void *aom_vector_back(Vector *vector) {
+  return aom_vector_get(vector, vector->size - 1);
+}
+
+/* Information */
+
+bool aom_vector_is_initialized(const Vector *vector) {
+  return vector->data != NULL;
+}
+
+size_t aom_vector_byte_size(const Vector *vector) {
+  return vector->size * vector->element_size;
+}
+
+size_t aom_vector_free_space(const Vector *vector) {
+  return vector->capacity - vector->size;
+}
+
+bool aom_vector_is_empty(const Vector *vector) { return vector->size == 0; }
+
+/* Memory management */
+int aom_vector_resize(Vector *vector, size_t new_size) {
+  if (new_size <= vector->capacity * VECTOR_SHRINK_THRESHOLD) {
+    vector->size = new_size;
+    if (_vector_reallocate(vector, new_size * VECTOR_GROWTH_FACTOR) == -1) {
+      return VECTOR_ERROR;
+    }
+  } else if (new_size > vector->capacity) {
+    if (_vector_reallocate(vector, new_size * VECTOR_GROWTH_FACTOR) == -1) {
+      return VECTOR_ERROR;
+    }
+  }
+
+  vector->size = new_size;
+
+  return VECTOR_SUCCESS;
+}
+
+int aom_vector_reserve(Vector *vector, size_t minimum_capacity) {
+  if (minimum_capacity > vector->capacity) {
+    if (_vector_reallocate(vector, minimum_capacity) == VECTOR_ERROR) {
+      return VECTOR_ERROR;
+    }
+  }
+
+  return VECTOR_SUCCESS;
+}
+
+int aom_vector_shrink_to_fit(Vector *vector) {
+  return _vector_reallocate(vector, vector->size);
+}
+
+/* Iterators */
+Iterator aom_vector_begin(Vector *vector) { return aom_vector_iterator(vector, 0); }
+
+Iterator aom_vector_end(Vector *vector) {
+  return aom_vector_iterator(vector, vector->size);
+}
+
+Iterator aom_vector_iterator(Vector *vector, size_t index) {
+  Iterator iterator = { NULL, 0 };
+
+  assert(vector != NULL);
+  assert(index <= vector->size);
+
+  if (vector == NULL) return iterator;
+  if (index > vector->size) return iterator;
+  if (vector->element_size == 0) return iterator;
+
+  iterator.pointer = _vector_offset(vector, index);
+  iterator.element_size = vector->element_size;
+
+  return iterator;
+}
+
+void *iterator_get(Iterator *iterator) { return iterator->pointer; }
+
+int iterator_erase(Vector *vector, Iterator *iterator) {
+  size_t index = iterator_index(vector, iterator);
+
+  if (aom_vector_erase(vector, index) == VECTOR_ERROR) {
+    return VECTOR_ERROR;
+  }
+
+  *iterator = aom_vector_iterator(vector, index);
+
+  return VECTOR_SUCCESS;
+}
+
+void iterator_increment(Iterator *iterator) {
+  assert(iterator != NULL);
+  // iterator->pointer += iterator->element_size;
+  iterator->pointer =
+      (unsigned char *)iterator->pointer + iterator->element_size;
+}
+
+void iterator_decrement(Iterator *iterator) {
+  assert(iterator != NULL);
+  // iterator->pointer -= iterator->element_size;
+  iterator->pointer =
+      (unsigned char *)iterator->pointer - iterator->element_size;
+}
+
+void *iterator_next(Iterator *iterator) {
+  void *current = iterator->pointer;
+  iterator_increment(iterator);
+
+  return current;
+}
+
+void *iterator_previous(Iterator *iterator) {
+  void *current = iterator->pointer;
+  iterator_decrement(iterator);
+
+  return current;
+}
+
+bool iterator_equals(Iterator *first, Iterator *second) {
+  assert(first->element_size == second->element_size);
+  return first->pointer == second->pointer;
+}
+
+bool iterator_is_before(Iterator *first, Iterator *second) {
+  assert(first->element_size == second->element_size);
+  return first->pointer < second->pointer;
+}
+
+bool iterator_is_after(Iterator *first, Iterator *second) {
+  assert(first->element_size == second->element_size);
+  return first->pointer > second->pointer;
+}
+
+size_t iterator_index(Vector *vector, Iterator *iterator) {
+  assert(vector != NULL);
+  assert(iterator != NULL);
+  // return (iterator->pointer - vector->data) / vector->element_size;
+  return ((unsigned char *)iterator->pointer - (unsigned char *)vector->data) /
+         vector->element_size;
+}
+
+/***** PRIVATE *****/
+
+bool _vector_should_grow(Vector *vector) {
+  assert(vector->size <= vector->capacity);
+  return vector->size == vector->capacity;
+}
+
+bool _vector_should_shrink(Vector *vector) {
+  assert(vector->size <= vector->capacity);
+  return vector->size == vector->capacity * VECTOR_SHRINK_THRESHOLD;
+}
+
+size_t _vector_free_bytes(const Vector *vector) {
+  return aom_vector_free_space(vector) * vector->element_size;
+}
+
+void *_vector_offset(Vector *vector, size_t index) {
+  // return vector->data + (index * vector->element_size);
+  return (unsigned char *)vector->data + (index * vector->element_size);
+}
+
+const void *_vector_const_offset(const Vector *vector, size_t index) {
+  // return vector->data + (index * vector->element_size);
+  return (unsigned char *)vector->data + (index * vector->element_size);
+}
+
+void _vector_assign(Vector *vector, size_t index, void *element) {
+  /* Insert the element */
+  void *offset = _vector_offset(vector, index);
+  memcpy(offset, element, vector->element_size);
+}
+
+int _vector_move_right(Vector *vector, size_t index) {
+  assert(vector->size < vector->capacity);
+
+  /* The location where to start to move from. */
+  void *offset = _vector_offset(vector, index);
+
+  /* How many to move to the right. */
+  size_t elements_in_bytes = (vector->size - index) * vector->element_size;
+
+#ifdef __STDC_LIB_EXT1__
+  size_t right_capacity_in_bytes =
+      (vector->capacity - (index + 1)) * vector->element_size;
+
+  /* clang-format off */
+    int return_code =  memmove_s(
+        offset + vector->element_size,
+        right_capacity_in_bytes,
+        offset,
+        elements_in_bytes);
+
+  /* clang-format on */
+
+  return return_code == 0 ? VECTOR_SUCCESS : VECTOR_ERROR;
+
+#else
+  // memmove(offset + vector->element_size, offset, elements_in_bytes);
+  memmove((unsigned char *)offset + vector->element_size, offset,
+          elements_in_bytes);
+  return VECTOR_SUCCESS;
+#endif
+}
+
+void _vector_move_left(Vector *vector, size_t index) {
+  size_t right_elements_in_bytes;
+  void *offset;
+
+  /* The offset into the memory */
+  offset = _vector_offset(vector, index);
+
+  /* How many to move to the left */
+  right_elements_in_bytes = (vector->size - index - 1) * vector->element_size;
+
+  // memmove(offset, offset + vector->element_size, right_elements_in_bytes);
+  memmove(offset, (unsigned char *)offset + vector->element_size,
+          right_elements_in_bytes);
+}
+
+int _vector_adjust_capacity(Vector *vector) {
+  return _vector_reallocate(vector,
+                            MAX(1, vector->size * VECTOR_GROWTH_FACTOR));
+}
+
+int _vector_reallocate(Vector *vector, size_t new_capacity) {
+  size_t new_capacity_in_bytes;
+  void *old;
+  assert(vector != NULL);
+
+  if (new_capacity < VECTOR_MINIMUM_CAPACITY) {
+    if (vector->capacity > VECTOR_MINIMUM_CAPACITY) {
+      new_capacity = VECTOR_MINIMUM_CAPACITY;
+    } else {
+      /* NO-OP */
+      return VECTOR_SUCCESS;
+    }
+  }
+
+  new_capacity_in_bytes = new_capacity * vector->element_size;
+  old = vector->data;
+
+  if ((vector->data = malloc(new_capacity_in_bytes)) == NULL) {
+    return VECTOR_ERROR;
+  }
+
+#ifdef __STDC_LIB_EXT1__
+  /* clang-format off */
+    if (memcpy_s(vector->data,
+                             new_capacity_in_bytes,
+                             old,
+                             aom_vector_byte_size(vector)) != 0) {
+        return VECTOR_ERROR;
+    }
+/* clang-format on */
+#else
+  memcpy(vector->data, old, aom_vector_byte_size(vector));
+#endif
+
+  vector->capacity = new_capacity;
+
+  free(old);
+
+  return VECTOR_SUCCESS;
+}
+
+void _vector_swap(size_t *first, size_t *second) {
+  size_t temp = *first;
+  *first = *second;
+  *second = temp;
+}
diff --git a/Source/Lib/Codec/vector.h b/Source/Lib/Codec/vector.h
new file mode 100644
index 0000000..9ef1c60
--- /dev/null
+++ b/Source/Lib/Codec/vector.h
@@ -0,0 +1,159 @@
+/*
+The MIT License(MIT)
+Copyright(c) 2016 Peter Goldsborough
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files(the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software is furnished to do so,
+subject to the following conditions :
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/
+
+#ifndef VECTOR_H
+#define VECTOR_H
+
+#include <stdbool.h>
+#include <stddef.h>
+
+/***** DEFINITIONS *****/
+
+#define VECTOR_MINIMUM_CAPACITY 2
+#define VECTOR_GROWTH_FACTOR 2
+#define VECTOR_SHRINK_THRESHOLD (1 / 4)
+
+#define VECTOR_ERROR -1
+#define VECTOR_SUCCESS 0
+
+#define VECTOR_UNINITIALIZED NULL
+#define VECTOR_INITIALIZER \
+  { 0, 0, 0, VECTOR_UNINITIALIZED }
+
+/***** STRUCTURES *****/
+
+typedef struct Vector {
+  size_t size;
+  size_t capacity;
+  size_t element_size;
+
+  void *data;
+} Vector;
+
+typedef struct Iterator {
+  void *pointer;
+  size_t element_size;
+} Iterator;
+
+/***** METHODS *****/
+
+/* Constructor */
+int aom_vector_setup(Vector *vector, size_t capacity, size_t element_size);
+
+/* Copy Constructor */
+int aom_vector_copy(Vector *destination, Vector *source);
+
+/* Copy Assignment */
+int aom_vector_copy_assign(Vector *destination, Vector *source);
+
+/* Move Constructor */
+int aom_vector_move(Vector *destination, Vector *source);
+
+/* Move Assignment */
+int aom_vector_move_assign(Vector *destination, Vector *source);
+
+int aom_vector_swap(Vector *destination, Vector *source);
+
+/* Destructor */
+int aom_vector_destroy(Vector *vector);
+
+/* Insertion */
+int aom_vector_push_back(Vector *vector, void *element);
+int aom_vector_push_front(Vector *vector, void *element);
+int aom_vector_insert(Vector *vector, size_t index, void *element);
+int aom_vector_assign(Vector *vector, size_t index, void *element);
+
+/* Deletion */
+int aom_vector_pop_back(Vector *vector);
+int aom_vector_pop_front(Vector *vector);
+int aom_vector_erase(Vector *vector, size_t index);
+int aom_vector_clear(Vector *vector);
+
+/* Lookup */
+void *aom_vector_get(Vector *vector, size_t index);
+const void *aom_vector_const_get(const Vector *vector, size_t index);
+void *aom_vector_front(Vector *vector);
+void *aom_vector_back(Vector *vector);
+#define VECTOR_GET_AS(type, aom_vector_pointer, index) \
+  *((type *)aom_vector_get((aom_vector_pointer), (index)))
+
+/* Information */
+bool aom_vector_is_initialized(const Vector *vector);
+size_t aom_vector_byte_size(const Vector *vector);
+size_t aom_vector_free_space(const Vector *vector);
+bool aom_vector_is_empty(const Vector *vector);
+
+/* Memory management */
+int aom_vector_resize(Vector *vector, size_t new_size);
+int aom_vector_reserve(Vector *vector, size_t minimum_capacity);
+int aom_vector_shrink_to_fit(Vector *vector);
+
+/* Iterators */
+Iterator aom_vector_begin(Vector *vector);
+Iterator aom_vector_end(Vector *vector);
+Iterator aom_vector_iterator(Vector *vector, size_t index);
+
+void *iterator_get(Iterator *iterator);
+#define ITERATOR_GET_AS(type, iterator) *((type *)iterator_get((iterator)))
+
+int iterator_erase(Vector *vector, Iterator *iterator);
+
+void iterator_increment(Iterator *iterator);
+void iterator_decrement(Iterator *iterator);
+
+void *iterator_next(Iterator *iterator);
+void *iterator_previous(Iterator *iterator);
+
+bool iterator_equals(Iterator *first, Iterator *second);
+bool iterator_is_before(Iterator *first, Iterator *second);
+bool iterator_is_after(Iterator *first, Iterator *second);
+
+size_t iterator_index(Vector *vector, Iterator *iterator);
+
+#define VECTOR_FOR_EACH(aom_vector_pointer, iterator_name)           \
+  for (Iterator(iterator_name) = aom_vector_begin((aom_vector_pointer)), \
+      end = aom_vector_end((aom_vector_pointer));                        \
+       !iterator_equals(&(iterator_name), &end);                 \
+       iterator_increment(&(iterator_name)))
+
+/***** PRIVATE *****/
+
+//#define MAX(a, b) ((a) > (b) ? (a) : (b))
+
+bool _vector_should_grow(Vector *vector);
+bool _vector_should_shrink(Vector *vector);
+
+size_t _vector_free_bytes(const Vector *vector);
+void *_vector_offset(Vector *vector, size_t index);
+const void *_vector_const_offset(const Vector *vector, size_t index);
+
+void _vector_assign(Vector *vector, size_t index, void *element);
+
+int _vector_move_right(Vector *vector, size_t index);
+void _vector_move_left(Vector *vector, size_t index);
+
+int _vector_adjust_capacity(Vector *vector);
+int _vector_reallocate(Vector *vector, size_t new_capacity);
+
+void _vector_swap(size_t *first, size_t *second);
+
+#endif /* VECTOR_H */
-- 
2.19.1.windows.1

